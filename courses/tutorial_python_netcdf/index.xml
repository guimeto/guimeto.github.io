<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Overview | GDueymes</title>
    <link>/courses/tutorial_python_netcdf/</link>
      <atom:link href="/courses/tutorial_python_netcdf/index.xml" rel="self" type="application/rss+xml" />
    <description>Overview</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 09 Sep 2018 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>Overview</title>
      <link>/courses/tutorial_python_netcdf/</link>
    </image>
    
    <item>
      <title>1 Netcdf Part 1</title>
      <link>/courses/tutorial_python_netcdf/1-netcdf_tutorial/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0100</pubDate>
      <guid>/courses/tutorial_python_netcdf/1-netcdf_tutorial/</guid>
      <description>

&lt;p&gt;Network Common Data Form (Netcdf) is a way to create, access, and share scientific data in a format that is self-documenting and transparent for many types of machines.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/xarray.png&#34; alt=&#34;image0&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The Netcdf file itself has information describing the data it contains.&lt;/p&gt;

&lt;p&gt;A NetCDF file has dimensions, variables, and attributes.&lt;/p&gt;

&lt;p&gt;Here is a small example of a NetCDF file, to illustrate these concepts of dimensions, variables and attributes.&lt;/p&gt;

&lt;p&gt;The notation used to describe this NetCDF file is called Network Common Data Language (CDL). It gives a &amp;ldquo;text&amp;rdquo; version that allows an easy understanding of the structure and contents of a binary NetCDF file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;netcdf ./data/NARR_tasmax_201701.nc {
  dimensions:
x = 349;
y = 277;
time = 31;
  variables:
float lon(y=277, x=349);
  :units = &amp;quot;degrees_east&amp;quot;;
  :long_name = &amp;quot;Longitude&amp;quot;;
  :CoordinateAxisType = &amp;quot;Lon&amp;quot;;

float lat(y=277, x=349);
  :units = &amp;quot;degrees_north&amp;quot;;
  :long_name = &amp;quot;Latitude&amp;quot;;
  :CoordinateAxisType = &amp;quot;Lat&amp;quot;;

double time(time=31);
  :long_name = &amp;quot;Time&amp;quot;;
  :delta_t = &amp;quot;&amp;quot;;

float tasmax(time=31, y=277, x=349);
  :long_name = &amp;quot;Daily maximum temperature&amp;quot;;
  :units = &amp;quot;Celcius&amp;quot;;
  :missing_value = -999.0; // double
  :coordinates = &amp;quot;lon lat&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;Panoply is an apensource software used to quickly read aned visualize Netcdf file:
&lt;a href=&#34;https://www.giss.nasa.gov/tools/panoply/download/&#34; target=&#34;_blank&#34;&gt;https://www.giss.nasa.gov/tools/panoply/download/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The python module that we will use in this section is netCDF4:
&lt;a href=&#34;https://pypi.org/project/netCDF4/&#34; target=&#34;_blank&#34;&gt;https://pypi.org/project/netCDF4/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To install it under anaconda: &lt;b&gt;conda install -c anaconda netcdf4&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/CanESM2_rcp85_r1i1p1_global_tos.jpg&#34; alt=&#34;image0&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-create-a-netcdf-file&#34;&gt;1- Create a Netcdf file:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from netCDF4 import Dataset
import os 
import warnings
warnings.filterwarnings(&amp;quot;ignore&amp;quot;)

file_name = &amp;quot;./DATA/2D_Temperature.nc&amp;quot;
if os.path.isfile(file_name):
    os.remove(file_name)
    
#open the file for writing, you can Also specify format=&amp;quot;NETCDF4_CLASSIC&amp;quot; or &amp;quot;NETCDF3_CLASSIC&amp;quot;
#The format is NETCDF4 by default
ds = Dataset(file_name, mode=&amp;quot;w&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Netcdf4-python: &lt;b&gt;createDimension&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We will create here a 2D field: (20,20)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ds.createDimension(&amp;quot;x&amp;quot;, 20)
ds.createDimension(&amp;quot;y&amp;quot;, 20)
ds.createDimension(&amp;quot;time&amp;quot;, None)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;class &#39;netCDF4._netCDF4.Dimension&#39;&amp;gt; (unlimited): name = &#39;time&#39;, size = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Netcdf4-python: &lt;b&gt;createVariable&lt;/b&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;var1 = ds.createVariable(&amp;quot;field1&amp;quot;, &amp;quot;f4&amp;quot;, (&amp;quot;time&amp;quot;, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;))
var2 = ds.createVariable(&amp;quot;field2&amp;quot;, &amp;quot;f4&amp;quot;, (&amp;quot;time&amp;quot;, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;))

#add netcdf attributes
var1.units = &amp;quot;Celcius&amp;quot;
var1.long_name = &amp;quot;Surface air temperature&amp;quot;

var2.units = &amp;quot;Kelvin&amp;quot;
var2.long_name = &amp;quot;Surface air temperature&amp;quot;

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can now assign our field or variable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#generate random data and tell the program where it should go
import numpy as np
data = np.random.randn(10, 20, 20)
var1[:] = data
var2[:] =  data + 273.15
#actually write data to the disk
ds.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-read-a-netcdf-file&#34;&gt;2- Read a Netcdf file&lt;/h2&gt;

&lt;p&gt;We will read the file Netcdf4 that we created previously.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from netCDF4 import Dataset
ds = Dataset(&amp;quot;./DATA/2D_Temperature.nc&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will select our variables of interest: no data is loaded at this level.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Which variables are in our Netcdf file ?
print(ds.variables.keys())

data1_var = ds.variables[&amp;quot;field1&amp;quot;]
data2_var = ds.variables[&amp;quot;field2&amp;quot;]

#What&#39;s the dimension ?
print(data1_var.dimensions, data1_var.shape)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;odict_keys([&#39;field1&#39;, &#39;field2&#39;])
(&#39;time&#39;, &#39;x&#39;, &#39;y&#39;) (10, 20, 20)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now read our file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#now we ask to really read the data into the memory
all_data = data1_var[:]
#print all_data.shape
data1 = data1_var[1,:,:]
data2 = data2_var[2,:,:]
#data1
print(data1.shape, all_data.shape, all_data.mean(axis = 0).mean(axis = 0).mean(axis = 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(20, 20) (10, 20, 20) 0.0055584796
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-examples-of-manipulations-of-a-netcdf-file&#34;&gt;3- Examples of manipulations of a Netcdf file&lt;/h2&gt;

&lt;p&gt;In this example we will work with daily maximum temperature data for all January months from 1971 to 2000 from the CRCM5 regional model developed at the ESCER center.&lt;/p&gt;

&lt;p&gt;We will import our own module for calculating temperature indices, this module is calld Indices_Temperature.&lt;/p&gt;

&lt;p&gt;At first we will import the necessary libraries and define the input parameters.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from netCDF4 import Dataset
import Indices_Temperature
import numpy as np

Mois=&#39;01&#39;
model=&#39;CRCM5-v1_NAM-44_ll_CCCma-CanESM2&#39;
path_model=&#39;CRCM5-v1_CCCma-CanESM2_historical&#39;
variable=&#39;tasmax&#39;
indice = &#39;Tmax90p&#39;
yi = 1971
yf = 2000
#########################################################
rep_data=&#39;./DATA/CRCM5/&#39;
rep_out=&#39;./DATA/CRCM5/&#39;
tot=(yf-yi)+1 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Let&amp;rsquo;s open &amp;lsquo;CRCM5-v1_NAM-44_ll_CCCma-CanESM2_historical_tasmax_197101.nc&amp;rsquo; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;nc_Modc=Dataset(&#39;./DATA/CRCM5/&#39;+model+&#39;_historical_&#39;+variable+&#39;_197101.nc&#39;,&#39;r&#39;)
lats=nc_Modc.variables[&#39;lat&#39;][:]
lons=nc_Modc.variables[&#39;lon&#39;][:]
varc=nc_Modc.variables[variable][:]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## Quick look of our file: 
print(&#39;-----------------------------------------&#39;)
print(&#39;Temperature dimension = &#39;,varc.shape)
print(&#39;Minimum of temperature = &#39;, np.nanmin(varc))
print(&#39;Maximum of temperature = &#39;, np.nanmax(varc))
print(&#39;-----------------------------------------&#39;)
print(&#39;-----------------------------------------&#39;)
print(&#39;Latitude dimension= &#39;,lats.shape)
print(&#39;Minimum of latitude = &#39;, np.min(lats))
print(&#39;Maximum of latitude = &#39;, np.max(lats))
print(&#39;-----------------------------------------&#39;)
print(&#39;-----------------------------------------&#39;)
print(&#39;Longitude dimesion = &#39;,lons.shape)
print(&#39;Minimum of longitude = &#39;, np.min(lons))
print(&#39;Maximum of longitude = &#39;, np.max(lons))

Temperature dimension =  (31, 130, 155)
Minimum of temperature =  -57.66677
Maximum of temperature =  30.657953
Latitude dimension=  (130, 155)
Minimum of latitude =  12.538727
Maximum of latitude =  75.86
Longitude dimesion =  (130, 155)
Minimum of longitude =  -170.71053
Maximum of longitude =  -23.28948
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can now loop over all our Netcdf files and apply a function to calculate our indice.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;nt=0
IND = np.zeros((tot,130,155),dtype=float)
for year in range(yi,yf+1):
    ###### ouverture et lecture des fichiers Netcdf
    hist=model+&#39;_historical_&#39;+variable+&#39;_&#39;+str(year)+Mois+&#39;.nc&#39;     
    modelc=rep_data+&#39;/&#39;+hist
    nc_Modc=Dataset(modelc,&#39;r&#39;)
    lats=nc_Modc.variables[&#39;lat&#39;][:]
    lons=nc_Modc.variables[&#39;lon&#39;][:]
    varc=nc_Modc.variables[variable][:]
    
    ###### boucle sur tous les points de grille et calcul de l&#39;indice
    for ni in range(0, len(varc[0])):
        for nj in range(0, len(varc[0][0])):
            if indice == &#39;Mean_tasmax&#39;:
                IND[nt,ni,nj]=Indices_Temperature.MOY(varc[:,ni,nj])
                description=&#39;Monthly Mean of tasmax&#39;
                unite=&#39;°Celcius&#39;
            elif indice == &#39;Tmax90p&#39;:
                IND[nt,ni,nj]=Indices_Temperature.Tmax90p(varc[:,ni,nj])
                description=&#39;Monthly Mean of Tmax90p&#39; 
                unite=&#39;°Celcius&#39;               
    nt+=1 
    
    ###### Écriture du fichier Netcdf en sortie
C = Dataset(rep_out+model+&#39;_historical_&#39;+indice+&#39;_&#39;+str(yi)+&#39;-&#39;+str(yf)+&#39;_&#39;+Mois+&#39;.nc&#39;, &#39;w&#39;)
C.description = &#39;Indice temperature&#39;
C.conventions = &#39;CF-1.0&#39;  
C.model_id = model
C.grid=&#39;latlon&#39;
C.CDO = &#39;Climate Data Operators version 1.6.2 (http://code.zmaw.de/projects/cdo)&#39;
C.institution = &#39;UQAM - ESCER Center, University of Quebec in Montreal&#39;
C.contact = &#39;Guillaume Dueymes&#39;
########################################
# Dimensions
C.createDimension(&#39;x&#39;, len(varc[0][0]))
C.createDimension(&#39;y&#39;, len(varc[0]))
C.createDimension(&#39;time&#39;, tot)

var=C.createVariable(str(indice), np.float32, (&#39;time&#39;,&#39;y&#39;,&#39;x&#39;)) 
var.long_name = str(description)
var.unit = str(unite)
lat=C.createVariable(&#39;lat&#39;, np.float32, (&#39;y&#39;,&#39;x&#39;))
lon=C.createVariable(&#39;lon&#39;, np.float32, (&#39;y&#39;,&#39;x&#39;)) 

time = C.createVariable(&#39;time&#39;, np.float64, (&#39;time&#39;,))
time.long_name = &#39;time&#39;

for var in [&#39;lon&#39;,&#39;lat&#39;,&#39;time&#39;]:
    for att in nc_Modc.variables[var].ncattrs():
        setattr(C.variables[var],att,getattr(nc_Modc.variables[var],att))

time[:]=range(1,nt+1)
lat[:,:] = lats
lon[:,:] = lons
C.variables[str(indice)][:,:,:] = IND[::]
C.close()
    
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;IND.shape
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(30, 130, 155)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-netcdf-gridpoint-extraction&#34;&gt;4- Netcdf gridpoint extraction&lt;/h2&gt;

&lt;p&gt;In this example we will work with maximum daily temperature data from Regional Reanalysis (NARR) Regional Reanalysis. For more information about this product:&lt;/p&gt;

&lt;p&gt;www.emc.ncep.noaa.gov/mmb/rreanl&lt;/p&gt;

&lt;p&gt;The Netcdf files that we will open are daily values from January 1, 2017 to December 31, 2017. Files are archived by month.&lt;/p&gt;

&lt;p&gt;The NARR grid point closest to the ECCC Montréal / McTavish weather station (45.5N, -73.8W) will be extracted here.&lt;/p&gt;

&lt;p&gt;We first import the libraries.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import netCDF4
import numpy as np
import pandas as pd
import datetime
from datetime import date, timedelta
from dateutil.relativedelta import relativedelta
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;rep1=&#39;./DATA/NARR/&#39;
model=&#39;NARR&#39;
variable=&#39;tasmax&#39;
variable_name=&#39;Temperature maximale&#39;
yeari=2017
monthi=1
yearf = 2017
monthf = 12
station=&#39;Montreal&#39; 
lati = 45.5
loni = -73.8

day_start=1
day_end = pd.date_range(&#39;{}-{}&#39;.format(yearf, monthf), periods=1, freq=&#39;M&#39;).day.tolist()[0]
start=datetime.datetime(yeari,monthi,day_start)
end=datetime.datetime(yearf,monthf,day_end)
d0 = date(yeari, monthi, day_start)
d1 = date(yearf, monthf, day_end)
delta = d1 - d0
nb_days = delta.days+1
var_data=np.zeros(nb_days)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We define a function that will calculate the distance between each grid point of the Netcdf file and our reference latitude / longitude. We then deduce the minimum distance.&lt;/p&gt;

&lt;p&gt;The other function allows us to increment our months when reading Netcdf files.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def getclosest_ij(lats,lons,latpt,lonpt):
     # find squared distance of every point on grid
     dist_sq = (lats-latpt)**2 + (lons-lonpt)**2 
     # 1D index of minimum dist_sq element
     minindex_flattened = dist_sq.argmin()
     # Get 2D index for latvals and lonvals arrays from 1D index
     return np.unravel_index(minindex_flattened, lats.shape)

def add_month(now):
    try:
        then = (now + relativedelta(months=1)).replace(day=now.day)
    except ValueError:
        then = (now + relativedelta(months=2)).replace(day=1)
    return then
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can know apply our function over each grid point, month by month and save the value into a DataFrame.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
i=0
IND=[]
# Début de notre boucle temporelle
incr=start
while incr &amp;lt;= end:
    filename= rep1 + model + &#39;_&#39; + variable + &#39;_&#39; + str(incr.year) + &#39;{:02d}&#39;.format(incr.month) + &#39;.nc&#39;   
    f = netCDF4.Dataset(filename)
   # print(f.variables.keys()) # get all variable names
    var = f.variables[variable] # temperature variable
    #print(temp) 
    #temp.dimensions
    #temp.shape
    lat, lon = f.variables[&#39;lat&#39;], f.variables[&#39;lon&#39;]
    #print(lat)
    #print(lon)
    #print(lat[:])
    # extract lat/lon values (in degrees) to numpy arrays
    latvals = lat[:]; lonvals = lon[:] 
    # a function to find the index of the point closest pt
    # (in squared distance) to give lat/lon value.    
    iy_min, ix_min = getclosest_ij(latvals, lonvals, lati, loni)
    #print(iy_min)
    #print(ix_min)
    IND.append(var[:,iy_min,ix_min])
    incr=add_month(incr)
    
flattened_list = [y for x in IND for y in x]
start=datetime.datetime(yeari,monthi,day_start)
TIME=[]
for i in range(0,nb_days,1): 
 #   TIME.append((start+timedelta(days=i)).strftime(&amp;quot;%Y-%m-%d&amp;quot;))
    TIME.append((start+timedelta(days=i)))
dataFrame_NARR = pd.DataFrame({&#39;Date&#39;: TIME, variable_name: flattened_list}, columns = [&#39;Date&#39;,variable_name]) 
dataFrame_NARR = dataFrame_NARR.set_index(&#39;Date&#39;)   
dataFrame_NARR.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Date&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Temperature maximale&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2017-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.893957&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2017-01-02 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.53144&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2017-01-03 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.73783&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2017-01-04 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.240698&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2017-01-05 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.791754&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We save our DataFrame in csv.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataFrame_NARR.to_csv(&#39;./DATA/NARR/NARR_&#39;+station+&#39;_1pt_&#39;+str(variable)+&#39;_&#39;+ &#39;{:02d}&#39;.format(monthi) + str(yeari)+&#39;_&#39;+ &#39;{:02d}&#39;.format(monthf) + str(yearf)+&#39;.csv&#39;)    
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Observation vs NARR
Now we have extracted our gridpoint near Montreal, we can compare these values with observations.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We will extract the data from the Montreal McTavish station and put them in the NARR dataFrame.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataframe_station = pd.read_csv(&#39;./DATA/station/MONTREAL_TAVISH_tasmax_1948_2017.csv&#39;, header=None, names=[&#39;Maximum temperature: OBS&#39;])
start = date(1948, 1, 1)
end = date(2017, 12, 31)
delta=(end-start) 
nb_days = delta.days + 1 
rng = pd.date_range(start, periods=nb_days, freq=&#39;D&#39;)

dataframe_station[&#39;datetime&#39;] = rng
dataframe_station.index = dataframe_station[&#39;datetime&#39;] 
dataframe_station = dataframe_station.drop([&amp;quot;datetime&amp;quot;], axis=1)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataframe_station.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;datetime&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Maximum temperature: OBS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;1948-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-10&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;1948-01-02 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-3.9&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;1948-01-03 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.6&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;1948-01-04 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-2.8&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;1948-01-05 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-2.2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataFrame_NARR = dataFrame_NARR.rename(columns={&amp;quot;Temperature maximale&amp;quot;: &amp;quot;Maximum temperature: NARR&amp;quot;})
df_NARR_Station = pd.concat([dataframe_station,dataFrame_NARR],axis=1)
df_NARR_Station.tail()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Maximum temperature: OBS&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Maximum temperature: NARR&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2017-12-27 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-17.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-18.819&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2017-12-28 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-20.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-19.3721&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2017-12-29 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-18.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-16.4532&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2017-12-30 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-17.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-16.2088&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2017-12-31 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-18.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-16.7728&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We want to plot valeurs for 2016 and 2017 years.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df=df_NARR_Station.loc[&#39;2016&#39; : &#39;2017&#39;]
df.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Maximum temperature: OBS&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Maximum temperature: NARR&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2016-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2016-01-02 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2016-01-03 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2016-01-04 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-13.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2016-01-05 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-7.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib.pyplot as plt
color = [&#39;black&#39;, &#39;red&#39;]
fig = plt.figure(figsize=(16,8))
plt.plot(df.index, df[&#39;Maximum temperature: NARR&#39;][:],  label=&#39;NARR Temperature&#39;, linewidth=2, c=color[0])
plt.plot(df.index, df[&#39;Maximum temperature: OBS&#39;][:],  label=&#39;Observation Temperature&#39;, linewidth=2, c=color[1])

# Autre méthode pour tracer avec Pandas
#df_NARR_Station[&#39;2017&#39;].plot(figsize=(10,5))

plt.xlabel(&amp;quot;Time&amp;quot;)
plt.ylabel(&amp;quot;Temperature&amp;quot;, {&#39;color&#39;: &#39;black&#39;, &#39;fontsize&#39;: 10})
plt.title(&amp;quot;Time serie: Station MTL vs NARR&amp;quot;, y=1.05)
plt.legend(loc=&#39;upper left&#39;, ncol=1, bbox_to_anchor=(0, 1, 1, 0),fontsize =10)
plt.savefig(&amp;quot;figures/NARR_time_Serie_temperature.png&amp;quot;, dpi=300, bbox_inches=&#39;tight&#39;)   # bbox_inches= : option qui permet de propostionner le graphique lors de l&#39;enregistrement
plt.show()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/NARR_time_Serie_temperature.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Example of using the &lt;b&gt; .rolling () &amp;lt;/ b&amp;gt; function to calculate a moving average on a signal.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib.pyplot as plt
df_NARR_Station[&#39;rollingmean5 Station&#39;]=  df_NARR_Station[&#39;Maximum temperature: OBS&#39;].rolling(window=5).mean()
df_NARR_Station[&#39;rollingmean5 NARR&#39;]=  df_NARR_Station[&#39;Maximum temperature: NARR&#39;].rolling(window=5).mean()
df_NARR_Station.tail()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Maximum temperature: OBS&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Maximum temperature: NARR&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;rollingmean5 Station&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;rollingmean5 NARR&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2017-12-27 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-17.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-18.819&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-8.04&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-8.31893&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2017-12-28 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-20.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-19.3721&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-11.12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-11.0995&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2017-12-29 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-18.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-16.4532&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-13.88&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-13.6478&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2017-12-30 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-17.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-16.2088&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-16.12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-15.6138&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2017-12-31 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-18.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-16.7728&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-18.42&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-17.5252&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df_NARR_Station[&#39;2017-01&#39;:&#39;2017-12&#39;].plot(figsize=(16,8))
plt.xlabel(&amp;quot;Temps&amp;quot;)
plt.ylabel(&amp;quot;Température&amp;quot;)
plt.title(&amp;quot;Maximum temperature time serie: Station MTL vs NARR&amp;quot;, y=1.05)
plt.savefig(&amp;quot;figures/NARR_time_Serie_temperature2.png&amp;quot;, dpi=300, bbox_inches=&#39;tight&#39;)   # bbox_inches= : option qui permet de propostionner le graphique lors de l&#39;enregistrement
plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/NARR_time_Serie_temperature2.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2 Netcdf Part 2</title>
      <link>/courses/tutorial_python_netcdf/2-netcdf_tutorial_2/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0100</pubDate>
      <guid>/courses/tutorial_python_netcdf/2-netcdf_tutorial_2/</guid>
      <description>&lt;p&gt;Instead of extracting a grid point, we may want to extract a domain / box delimited by latitudes and longitudes.&lt;/p&gt;

&lt;p&gt;In this example we will work with the annual mean of daily maximum temperature data from several regional models of CORDEX-NAM44.&lt;/p&gt;

&lt;p&gt;We will extract all the grid points from the region between &lt;b&gt; 47degN and 51degN of latitude and between -72degW and -64degW of longitude &lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;We will then plot the inter-annual variability of the mean annual temperature anomalies.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/CORDEX_domaine.png&#34; alt=&#34;image0&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# we first inmport librairies
import netCDF4
import numpy as np
import pandas as pd
from datetime import datetime
import matplotlib.pylab as plt
import warnings; warnings.filterwarnings(action=&#39;ignore&#39;)
import seaborn as sns
from matplotlib import gridspec

# path and variable name
rep=&#39;./DATA/Inter_annual_anomaly/&#39;
variable_in = &#39;Mean_tasmax&#39;

# list of periods we want to use
list_period = [&#39;2011-2040&#39;,&#39;2041-2070&#39;,&#39;2071-2100&#39;]

# list of models
list_rcp45 = [&#39;CRCM5-v1_NAM-44_ll_CCCma-CanESM2_rcp45&#39;, &#39;CRCM5-v1_NAM-44_ll_MPI-M-MPI-ESM-LR_rcp45&#39; ]

# Area to extract
latbounds = [ 47 , 51 ]
lonbounds = [ -72 , -64 ] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will make a loop over each model and period to make the extraction:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 
df_rcp45 = []
matrix_45 = []
for period in list_period: 
    globals()[&#39;flattened_list_&#39;+period] = []  # we define a global variable 
    for i in range(0,len(list_rcp45)):
        filename= rep +&#39;anomalie_&#39; +  list_rcp45[i] +  &#39;_&#39; + variable_in + &#39;_&#39; + period  + &#39;_1971-2000.nc&#39;   
        nc = netCDF4.Dataset(filename)
        # we here read netcdf values
        var = nc.variables[variable_in][:]  
        lats = nc.variables[&#39;lat&#39;][:]; lons = nc.variables[&#39;lon&#39;][:]
        # in this part, we extract our domain 
        subset = ((lats &amp;gt; latbounds[0]) &amp;amp; (lats &amp;lt; latbounds[1]) &amp;amp; 
             (lons &amp;gt; lonbounds[0]) &amp;amp; (lons &amp;lt; lonbounds[1]))
        data=pd.DataFrame(var[:,subset], dtype=&#39;float&#39;) 
        globals()[&#39;flattened_list_&#39;+period].append(data.mean(axis=1))
        
    df_rcp45.append(pd.DataFrame(globals()[&#39;flattened_list_&#39;+period]).T) 
    
df_rcp45 = pd.concat(df_rcp45)
df_rcp45.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;0&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.72084&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.288691&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.4762&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.885357&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.581686&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.541863&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.390671&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.0141989&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.14842&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.29417&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We can add datetime index in our DataFrame.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;TIME=[]
for y in range(int(list_period[0].split(&#39;-&#39;)[0]),int(list_period[-1].split(&#39;-&#39;)[-1])+1,1):
    TIME.append(datetime.strptime(str(y), &#39;%Y&#39;))
    
df_rcp45[&#39;Date&#39;] = TIME   
df_rcp45.index = df_rcp45[&#39;Date&#39;]
df_rcp45 = df_rcp45.drop([&amp;quot;Date&amp;quot;], axis=1) 
df_rcp45.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Date&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;0&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2011-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.72084&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.288691&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2012-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.4762&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.885357&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2013-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.581686&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.541863&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2014-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.390671&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.0141989&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2015-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.14842&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.29417&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We then want, for each year, the intra-model variability. For this, we will calculate the minimum and maximum values by applying the &lt;b&gt; .apply &lt;/b&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df_rcp45[&#39;min&#39;] = df_rcp45.apply(np.min, axis=1)
df_rcp45[&#39;max&#39;] = df_rcp45.apply(np.max, axis=1)
df_rcp45[&#39;mean&#39;] = df_rcp45.apply(np.mean, axis=1)
df_rcp45.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Date&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;0&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;min&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;max&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;mean&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2011-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.72084&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.288691&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.288691&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.72084&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.716076&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2012-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.4762&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.885357&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.885357&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.4762&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.18078&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2013-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.581686&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.541863&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.541863&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.581686&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.561774&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2014-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.390671&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.0141989&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.0141989&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.390671&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.188236&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2015-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.14842&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.29417&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.14842&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.29417&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.2213&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We will make the same work with RCMs in future condition with rcp8.5 scenario and RCMs in historical conditions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;list_rcp85 = [&#39;CRCM5-v1_NAM-44_ll_CCCma-CanESM2_rcp85&#39;,&#39;CRCM5-v1_NAM-44_ll_MPI-M-MPI-ESM-MR_rcp85&#39;]
df_rcp85 = []
matrix_85 = []
for period in list_period: 
    globals()[&#39;flattened_list_&#39;+period] = []
    for i in range(0,len(list_rcp85)):
        filename= rep + &#39;anomalie_&#39; +  list_rcp85[i] +  &#39;_&#39; + variable_in + &#39;_&#39; + period  + &#39;_1971-2000.nc&#39;   
        nc = netCDF4.Dataset(filename)
        var = nc.variables[variable_in][:]  
        lats = nc.variables[&#39;lat&#39;][:]; lons = nc.variables[&#39;lon&#39;][:]            
        subset = ((lats &amp;gt; latbounds[0]) &amp;amp; (lats &amp;lt; latbounds[1]) &amp;amp; 
             (lons &amp;gt; lonbounds[0]) &amp;amp; (lons &amp;lt; lonbounds[1]))
        #mask = np.where(subset)
        data=pd.DataFrame(var[:,subset], dtype=&#39;float&#39;) 
        globals()[&#39;flattened_list_&#39;+period].append(data.mean(axis=1))        
    df_rcp85.append(pd.DataFrame(globals()[&#39;flattened_list_&#39;+period]).T) 
    
df_rcp85 = pd.concat(df_rcp85)
df_rcp85[&#39;Date&#39;] = TIME   
df_rcp85.index = df_rcp85[&#39;Date&#39;]
df_rcp85 = df_rcp85.drop([&amp;quot;Date&amp;quot;], axis=1)  

df_rcp85[&#39;min&#39;] = df_rcp85.apply(np.min, axis=1)
df_rcp85[&#39;max&#39;] = df_rcp85.apply(np.max, axis=1)
df_rcp85[&#39;mean&#39;] = df_rcp85.apply(np.mean, axis=1)

### historical RCMs
list_histo = [&#39;CRCM5-v1_NAM-44_ll_CCCma-CanESM2_historical&#39;, &#39;CRCM5-v1_NAM-44_ll_MPI-M-MPI-ESM-LR_historical&#39;]
df_histo = []
globals()[&#39;flattened_list_&#39;+period] = []
for i in range(0,len(list_histo)):
    filename= rep + &#39;anomalie_&#39; +  list_histo[i] +  &#39;_&#39; + variable_in + &#39;_1971-2000_1971-2000.nc&#39;   
    nc = netCDF4.Dataset(filename)
    var = nc.variables[variable_in][:]  
    lats = nc.variables[&#39;lat&#39;][:]; lons = nc.variables[&#39;lon&#39;][:]
    
    subset = ((lats &amp;gt; latbounds[0]) &amp;amp; (lats &amp;lt; latbounds[1]) &amp;amp; 
         (lons &amp;gt; lonbounds[0]) &amp;amp; (lons &amp;lt; lonbounds[1]))
    #mask = np.where(subset)
    data=pd.DataFrame(var[:,subset], dtype=&#39;float&#39;) 
    globals()[&#39;flattened_list_&#39;+period].append(data.mean(axis=1))        
df_histo.append(pd.DataFrame(globals()[&#39;flattened_list_&#39;+period]).T) 
TIME=[]
for y in range(1971,2001,1):
    TIME.append(datetime.strptime(str(y), &#39;%Y&#39;))  
    
df_histo = pd.concat(df_histo)
df_histo[&#39;Date&#39;] = TIME   
df_histo.index = df_histo[&#39;Date&#39;]
df_histo = df_histo.drop([&amp;quot;Date&amp;quot;], axis=1)  

df_histo[&#39;min&#39;] = df_histo.apply(np.min, axis=1)
df_histo[&#39;max&#39;] = df_histo.apply(np.max, axis=1)
df_histo[&#39;mean&#39;] = df_histo.apply(np.mean, axis=1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We put all results in the same DataFrame:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;result = []
result = pd.DataFrame({&#39;min_rcp45&#39;: df_rcp45[&#39;min&#39;], &#39;max_rcp45&#39;: df_rcp45[&#39;max&#39;],&#39;mean_rcp45&#39;: df_rcp45[&#39;mean&#39;],
                       &#39;min_rcp85&#39;: df_rcp85[&#39;min&#39;], &#39;max_rcp85&#39;: df_rcp85[&#39;max&#39;],&#39;mean_rcp85&#39;: df_rcp85[&#39;mean&#39;],
                       &#39;min_histo&#39;: df_histo[&#39;min&#39;], &#39;max_histo&#39;: df_histo[&#39;max&#39;],&#39;mean_histo&#39;: df_histo[&#39;mean&#39;]},
        columns = [&#39;min_rcp45&#39;,&#39;max_rcp45&#39;,&#39;mean_rcp45&#39;,&#39;min_rcp85&#39;,&#39;max_rcp85&#39;,&#39;mean_rcp85&#39;,&#39;min_histo&#39;,&#39;max_histo&#39;,&#39;mean_histo&#39;]) 

result.tail()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Date&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;min_rcp45&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;max_rcp45&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;mean_rcp45&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;min_rcp85&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;max_rcp85&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;mean_rcp85&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;min_histo&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;max_histo&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;mean_histo&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2096-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.89008&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.49628&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.19318&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5.44184&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8.03633&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.73908&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2097-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.86389&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5.06262&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.46325&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.10506&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.35563&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.73034&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2098-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.28996&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.60365&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.4468&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.58306&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.14778&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.86542&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2099-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.94984&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.26892&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.60938&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.40518&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.04316&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.72417&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2100-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.99867&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.27685&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.13776&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.16794&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.96608&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.56701&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We can now plot our inter-annual variability:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;color = [&#39;black&#39;,&#39;blue&#39;, &#39;red&#39;]
fig = plt.figure(figsize=(10, 6)) 
gs = gridspec.GridSpec(1, 2, width_ratios=[6, 1]) 
gs.update( wspace=0.04)
ax1 = plt.subplot(gs[0])

plt.rcParams[&amp;quot;figure.figsize&amp;quot;]=[16,9]       #  
plt.plot(result.index.year, result[&#39;mean_histo&#39;][:],  label=&#39;RCMs historical&#39;, linewidth=2, c=color[0])
plt.plot(result.index.year, result[&#39;mean_rcp45&#39;][:],  label=&#39;RCMs scenario rcp 4.5&#39;, linewidth=2, c=color[1])
plt.plot(result.index.year, result[&#39;mean_rcp85&#39;][:],  label=&#39;RCMs scenario rcp 8.5&#39;, linewidth=2, c=color[2])

plt.fill_between(result.index.year,result[&#39;min_histo&#39;],result[&#39;max_histo&#39;], color = color[0], alpha=.2)
plt.fill_between(result.index.year,result[&#39;min_rcp45&#39;],result[&#39;max_rcp45&#39;], color =  color[1], alpha=.2)
plt.fill_between(result.index.year,result[&#39;min_rcp85&#39;],result[&#39;max_rcp85&#39;], color =  color[2], alpha=.2)
plt.legend(loc=&amp;quot;upper left&amp;quot;, markerscale=1., scatterpoints=1, fontsize=20)

plt.xticks(range(result.index.year[0]-1, result.index.year[-1]+1, 10), fontsize=14)
plt.yticks( fontsize=14)

ax1.grid(axis = &amp;quot;x&amp;quot;, linestyle = &amp;quot;--&amp;quot;, color=&#39;black&#39;, linewidth=0.25, alpha=0.5)
ax1.grid(axis = &amp;quot;y&amp;quot;, linestyle = &amp;quot;--&amp;quot;, color=&#39;black&#39;, linewidth=0.25, alpha=0.5)

plt.setp(plt.gca().get_xticklabels(), rotation=45, ha=&amp;quot;right&amp;quot;)

plt.xlabel(&#39;Date&#39;, fontsize=20, color=&#39;black&#39;, weight=&#39;semibold&#39;)
plt.ylabel(&#39;°C&#39;, fontsize=20, color=&#39;black&#39;, weight=&#39;semibold&#39;)
plt.title(&#39;Annual change in daily maximum temperature: (1971-2100) compared with normal (1971-2000)&#39;, fontsize=20, color=&#39;black&#39;, weight=&#39;semibold&#39;)
 
ax1.set_facecolor(&#39;white&#39;)
plt.yticks( fontsize=14)
plt.show()  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_13_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We would add next to our chart a boxplot on all models for the period 1971-2000 and 2071-2100 only.
We will extract these periods from our matrix result = []&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;list_to_remove = [&#39;min&#39;,&#39;max&#39;,&#39;mean&#39;]
df_histo = df_histo.drop(list_to_remove, axis=1)  
df_rcp45 = df_rcp45.drop(list_to_remove, axis=1)  
df_rcp85 = df_rcp85.drop(list_to_remove, axis=1) 
df_histo = df_histo.loc[&#39;1971&#39; : &#39;2010&#39;].stack()
df_rcp45 = df_rcp45.loc[&#39;2071&#39; : &#39;2100&#39;].stack()
df_rcp85 = df_rcp85.loc[&#39;2071&#39; : &#39;2100&#39;].stack()

matrix_box = pd.DataFrame({&#39;RCMs_histo&#39;: df_histo, &#39;RCMs_rcp45&#39;: df_rcp45,&#39;RCMs_rcp85&#39;: df_rcp85},
        columns = [&#39;RCMs_histo&#39;,&#39;RCMs_rcp45&#39;,&#39;RCMs_rcp85&#39;])
matrix_box.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;RCMs_histo&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;RCMs_rcp45&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;RCMs_rcp85&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;(Timestamp(&amp;lsquo;1971-01-01 00:00:00&amp;rsquo;), 0)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.34157&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;(Timestamp(&amp;lsquo;1971-01-01 00:00:00&amp;rsquo;), 1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.12412&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;(Timestamp(&amp;lsquo;1972-01-01 00:00:00&amp;rsquo;), 0)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.641267&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;(Timestamp(&amp;lsquo;1972-01-01 00:00:00&amp;rsquo;), 1)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.0350673&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;(Timestamp(&amp;lsquo;1973-01-01 00:00:00&amp;rsquo;), 0)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.0541643&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;color = [&#39;black&#39;,&#39;blue&#39;, &#39;red&#39;]
fig = plt.figure(figsize=(22, 12)) 
gs = gridspec.GridSpec(1, 2, width_ratios=[6, 1]) 
gs.update( wspace=0.04)
ax1 = plt.subplot(gs[0])

plt.rcParams[&amp;quot;figure.figsize&amp;quot;]=[16,9]       #  
plt.plot(result.index.year, result[&#39;mean_histo&#39;][:],  label=&#39;RCMs historical&#39;, linewidth=2, c=color[0])
plt.plot(result.index.year, result[&#39;mean_rcp45&#39;][:],  label=&#39;RCMs scenario rcp 4.5&#39;, linewidth=2, c=color[1])
plt.plot(result.index.year, result[&#39;mean_rcp85&#39;][:],  label=&#39;RCMs scenario rcp 8.5&#39;, linewidth=2, c=color[2])

plt.fill_between(result.index.year,result[&#39;min_histo&#39;],result[&#39;max_histo&#39;], color = color[0], alpha=.2)
plt.fill_between(result.index.year,result[&#39;min_rcp45&#39;],result[&#39;max_rcp45&#39;], color =  color[1], alpha=.2)
plt.fill_between(result.index.year,result[&#39;min_rcp85&#39;],result[&#39;max_rcp85&#39;], color =  color[2], alpha=.2)
plt.legend(loc=&amp;quot;upper left&amp;quot;, markerscale=1., scatterpoints=1, fontsize=20)

#ax.set_xlim(result.index.year[0], result.index.year[-1])
plt.xticks(range(result.index.year[0]-1, result.index.year[-1]+1, 10), fontsize=14)
plt.yticks( fontsize=14)

ax1.grid(axis = &amp;quot;x&amp;quot;, linestyle = &amp;quot;--&amp;quot;, color=&#39;black&#39;, linewidth=0.25, alpha=0.5)
ax1.grid(axis = &amp;quot;y&amp;quot;, linestyle = &amp;quot;--&amp;quot;, color=&#39;black&#39;, linewidth=0.25, alpha=0.5)

plt.setp(plt.gca().get_xticklabels(), rotation=45, ha=&amp;quot;right&amp;quot;)

plt.xlabel(&#39;Date&#39;, fontsize=20, color=&#39;black&#39;, weight=&#39;semibold&#39;)
plt.ylabel(&#39;°C&#39;, fontsize=20, color=&#39;black&#39;, weight=&#39;semibold&#39;)
plt.title(&#39;Annual change in daily maximum temperature: (1971-2100) compared with normal (1971-2000)&#39;, fontsize=20, color=&#39;black&#39;, weight=&#39;semibold&#39;)


my_pal = {&amp;quot;RCMs_histo&amp;quot;: &amp;quot;grey&amp;quot;, &amp;quot;RCMs_rcp45&amp;quot;: &amp;quot;blue&amp;quot;, &amp;quot;RCMs_rcp85&amp;quot;:&amp;quot;red&amp;quot;}
ax2 = plt.subplot(gs[1])
#ax2 = matrix_box.boxplot(column=[&#39;RCMs_histo&#39;, &#39;RCMs_rcp45&#39;, &#39;RCMs_rcp85&#39;])
ax2 = sns.boxplot(data=matrix_box, palette=my_pal)  
# Add transparency to colors
for patch in ax2.artists:
 r, g, b, a = patch.get_facecolor()
 patch.set_facecolor((r, g, b, .2))
plt.setp(plt.gca().get_xticklabels(), rotation=45, ha=&amp;quot;right&amp;quot;)
 
ax1.set_facecolor(&#39;white&#39;)
ax2.set_facecolor(&#39;white&#39;)
ax2.spines[&#39;top&#39;].set_visible(False)
ax2.spines[&#39;bottom&#39;].set_visible(False)
ax2.spines[&#39;right&#39;].set_visible(False)
ax2.spines[&#39;left&#39;].set_visible(False)

medians = matrix_box.median().values
median_labels = [str(np.round(s, 2))+&#39; °C&#39; for s in medians]
pos = range(len(medians))
i=0
for tick,label in zip(pos,ax2.get_xticklabels()):
    ax2.text(pos[tick], medians[tick] + 0.1, median_labels[tick], 
            horizontalalignment=&#39;center&#39;, size=&#39;medium&#39;, color = color[i], weight=&#39;semibold&#39;)
    i+=1
x1, x2, x3 = 0, 1, 2
ax2.text(x1, matrix_box.min().min().round()-0.15 , &amp;quot;1971-2000&amp;quot;, ha=&#39;center&#39;, va=&#39;bottom&#39;, size=&#39;medium&#39;, color=&#39;black&#39;, weight=&#39;semibold&#39;)   
ax2.text((x2+x3)*.5, matrix_box.min().median()-0.4 , &amp;quot;2071-2100&amp;quot;, ha=&#39;center&#39;, va=&#39;bottom&#39;, size=&#39;medium&#39;, color=&#39;black&#39;, weight=&#39;semibold&#39;)
plt.yticks( fontsize=14)
    
plt.savefig(&#39;./figures/VI_YEAR_Mean_tasmax.png&#39;, bbox_inches=&#39;tight&#39;, format=&#39;png&#39;, dpi=1000)
plt.show()  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/VI_YEAR_Mean_tasmax.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3 Cartopy</title>
      <link>/courses/tutorial_python_netcdf/3-cartopy_library/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0100</pubDate>
      <guid>/courses/tutorial_python_netcdf/3-cartopy_library/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;/img/netcdf/cartopy.png&#34; alt=&#34;image0&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The Cartopy python library allows you to analyze, process and plot georeferenced data with the help of Matplotlib.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://scitools.org.uk/cartopy/docs/latest/#&#34; target=&#34;_blank&#34;&gt;https://scitools.org.uk/cartopy/docs/latest/#&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To install the library under the prompt of anaconda:
 conda install -c conda-forge cartopy&lt;/p&gt;

&lt;h2 id=&#34;1-example-of-drawing-a-2d-netcdf-field&#34;&gt;1 - Example of drawing a 2D Netcdf field&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;We will work climatology (1981-2010) monthly minimum daily temperature&lt;/li&gt;
&lt;li&gt;At first we will import the Python libraries and open the Netcdf file&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Dataset class of the netCDF4 module is used to open and read Netcdf files.
Here we will store the Netcdf file in the variable nc_fid.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from netCDF4 import Dataset
import warnings
warnings.filterwarnings(&amp;quot;ignore&amp;quot;)

filename=&#39;./DATA/ANUSPLIN/ANUSPLIN_NLDAS_10km_CLIMATO_TASMIN_1981_2010_06.nc&#39;
nc_fid=Dataset(filename,&#39;r&#39;)
nc_fid.variables
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;OrderedDict([(&#39;lon&#39;, &amp;lt;class &#39;netCDF4._netCDF4.Variable&#39;&amp;gt;
              float32 lon(y, x)
                  units: degrees_east
                  long_name: Longitude
                  CoordinateAxisType: Lon
              unlimited dimensions: 
              current shape = (1068, 420)
              filling on, default _FillValue of 9.969209968386869e+36 used),
             (&#39;lat&#39;, &amp;lt;class &#39;netCDF4._netCDF4.Variable&#39;&amp;gt;
              float32 lat(y, x)
                  units: degrees_north
                  long_name: Latitude
                  CoordinateAxisType: Lat
              unlimited dimensions: 
              current shape = (1068, 420)
              filling on, default _FillValue of 9.969209968386869e+36 used),
             (&#39;time&#39;, &amp;lt;class &#39;netCDF4._netCDF4.Variable&#39;&amp;gt;
              float64 time(time)
                  long_name: Time
                  delta_t: 
                  units: Days
              unlimited dimensions: 
              current shape = (1,)
              filling on, default _FillValue of 9.969209968386869e+36 used),
             (&#39;TASMIN&#39;, &amp;lt;class &#39;netCDF4._netCDF4.Variable&#39;&amp;gt;
              float32 TASMIN(time, y, x)
                  long_name: Daily minimum temperature
                  units: Celcius
                  missing_value: -999.0
                  coordinates: lon lat
              unlimited dimensions: 
              current shape = (1, 1068, 420)
              filling on, default _FillValue of 9.969209968386869e+36 used)])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will read TASMIN, lat and lon variables.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lats = nc_fid.variables[&#39;lat&#39;][:]
lons = nc_fid.variables[&#39;lon&#39;][:]
time = nc_fid.variables[&#39;time&#39;][:]
Vals = nc_fid.variables[&#39;TASMIN&#39;][:].squeeze()
print( Vals.shape)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(1068, 420)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will now call the cartopy and matplotlib libraries from Python to create a graphical instance.
The carto library brings functions to visually enrich maps made with cartopy: adding a scale &amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib.pylab as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import numpy as np
import matplotlib as mpl
from carto import scale_bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We create an instance of Cartopy to create a map. We choose here our projection, grid orientation and total coverage.&lt;/p&gt;

&lt;p&gt;Here is a very useful link to choose a projection type: &lt;a href=&#34;https://scitools.org.uk/cartopy/docs/latest/crs/projections.html&#34; target=&#34;_blank&#34;&gt;https://scitools.org.uk/cartopy/docs/latest/crs/projections.html&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;projections = [ccrs.PlateCarree(),
               ccrs.Robinson(),
               ccrs.Mercator(),
               ccrs.Orthographic(),
               ccrs.InterruptedGoodeHomolosine(),
               ccrs.LambertConformal(),
              ]


for proj in projections:
    plt.figure()
    ax = plt.axes(projection=proj)
    ax.stock_img()
    ax.coastlines()
    ax.set_title(f&#39;{type(proj)}&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_7_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_7_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_7_2.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_7_3.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_7_4.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_7_5.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In this example, we will work with a so-called &amp;ldquo;LambertConformal&amp;rdquo; projection.
To create a regional map, we use the GeoAxis set_extent method to limit the size of our region.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig=plt.figure(figsize=(5,3), frameon=True)   
ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-100,-60,18,62])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_9_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We will add some products to our map with Cartopy&amp;rsquo;s cartopy.feature method:
&lt;a href=&#34;https://scitools.org.uk/cartopy/docs/v0.14/matplotlib/feature_interface.html&#34; target=&#34;_blank&#34;&gt;https://scitools.org.uk/cartopy/docs/v0.14/matplotlib/feature_interface.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;|  |  |
|&amp;ndash;|&amp;ndash;|
| cartopy.feature.&lt;b&gt;BORDERS&lt;/b&gt; | Borders |
| cartopy.feature.&lt;b&gt;COASTLINE&lt;/b&gt; | Coast |
| cartopy.feature.&lt;b&gt;LAKES&lt;/b&gt; | Lakes |
| cartopy.feature.&lt;b&gt;LAND&lt;/b&gt; | Continents |
| cartopy.feature.&lt;b&gt;OCEAN&lt;/b&gt; | Ocean |
| cartopy.feature.&lt;b&gt;RIVERS&lt;/b&gt; | Rivers |
| cartopy.feature.&lt;b&gt;STATES&lt;/b&gt; | States |&lt;/p&gt;

&lt;p&gt;We will also add the provinces with Cartopy&amp;rsquo;s NaturalEarthFeature class:
&lt;a href=&#34;https://scitools.org.uk/cartopy/docs/v0.16/matplotlib/feature_interface.html#cartopy.feature.NaturalEarthFeature&#34; target=&#34;_blank&#34;&gt;https://scitools.org.uk/cartopy/docs/v0.16/matplotlib/feature_interface.html#cartopy.feature.NaturalEarthFeature&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We work here by adding layers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# adding caost:
ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-130,-60,18,62])
ax.coastlines(resolution=&#39;110m&#39;);
plt.show()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_11_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# adding land and oceanss:

ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-130,-60,18,62])
ax.coastlines(resolution=&#39;110m&#39;);
ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))
plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_12_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# adding lakes and rivers
ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-130,-60,18,62])
ax.coastlines(resolution=&#39;110m&#39;);
ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))
plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_13_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Adding states
ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-130,-60,18,62])
ax.coastlines(resolution=&#39;110m&#39;);
ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))
states_provinces = cfeature.NaturalEarthFeature(
        category=&#39;cultural&#39;,
        name=&#39;admin_1_states_provinces_lines&#39;,
        scale=&#39;50m&#39;,
        facecolor=&#39;none&#39;)

ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;)
plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_14_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can now fill our map with our georeferenced field with the method pcolormesh of matplotlib: &lt;a href=&#34;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.pcolormesh.html&#34; target=&#34;_blank&#34;&gt;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.pcolormesh.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here Lat Lon coordinates are in 2D, so in each grid point we know the latitude and longitude of our fields.&lt;/p&gt;

&lt;p&gt;It is possible that for a netcdf file Lat and Lon are in 1D. We must then write them in 2D with the following command:&lt;/p&gt;

&lt;p&gt;-lon, lat = np.meshgrid (lons, lats)&lt;/p&gt;

&lt;p&gt;We will also produce our own color palette. Here is a useful link to select our colors and create our palette: &lt;a href=&#34;http://colorbrewer2.org/#type=diverging&amp;amp;scheme=RdYlBu&amp;amp;n=8&#34; target=&#34;_blank&#34;&gt;http://colorbrewer2.org/#type=diverging&amp;amp;scheme=RdYlBu&amp;amp;n=8&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You can also use one of the color palettes predefined by Matplotlip: &lt;a href=&#34;https://matplotlib.org/examples/color/colormaps_reference.html&#34; target=&#34;_blank&#34;&gt;https://matplotlib.org/examples/color/colormaps_reference.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We will use to draw our map type pcolormesh matplotib. Other types of plots are available: &lt;a href=&#34;https://matplotlib.org/basemap/users/examples.html&#34; target=&#34;_blank&#34;&gt;https://matplotlib.org/basemap/users/examples.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To improve the reading of our map, we can at this level add:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a legend under the map: cbar.set_label&lt;/li&gt;

&lt;li&gt;&lt;p&gt;add a color bar with a display interval: plt.colorbar&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Y=np.array([[77,0,111],[115,14,181],[160,17,222],[195,14,240],\
           [0,0,93],[21,38,177],[33,95,227],[32,162,247],[59,224,248],[202,255,250],\
           [4,255,179],[37,181,139],[32,132,81],[72,162,60],[157,240,96],[213,255,166],\
           [241,247,132],[248,185,68],[255,124,4],[235,78,14],[215,32,24],[189,24,40],[162,16,56],[135,16,65],[107,15,73]])/255.

colbar=mpl.colors.ListedColormap(Y)
fig=plt.figure(figsize=(10,6), frameon=True)  
ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-130,-60,18,62])

mm = ax.pcolormesh(lons,\
               lats,\
               Vals,\
               vmin=-28,\
               vmax=28, \
               transform=ccrs.PlateCarree(),\
               cmap=colbar )


ax.coastlines(resolution=&#39;110m&#39;);
ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))

states_provinces = cfeature.NaturalEarthFeature(
    category=&#39;cultural&#39;,
    name=&#39;admin_1_states_provinces_lines&#39;,
    scale=&#39;50m&#39;,
    facecolor=&#39;none&#39;)

ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;)  
ax.stock_img();
plt.show() 

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_16_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If the pallet is not suitable, it is possible to use a palette of Matplotlib.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig=plt.figure(figsize=(10,6), frameon=True)  
ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-130,-60,18,62])

mm = ax.pcolormesh(lons,\
                   lats,\
                   Vals,\
                   vmin=-28,\
                   vmax=28, \
                   transform=ccrs.PlateCarree(),\
                   cmap=&#39;jet&#39; )


ax.coastlines(resolution=&#39;110m&#39;);
ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))

states_provinces = cfeature.NaturalEarthFeature(
        category=&#39;cultural&#39;,
        name=&#39;admin_1_states_provinces_lines&#39;,
        scale=&#39;50m&#39;,
        facecolor=&#39;none&#39;)

ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;)  
ax.stock_img();
plt.show() 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_18_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can finally add:
    - a title to our chart: plt.title
    - a color bar plt.colorbar
    - a title to our color bar: plt.xlabel
    - latitudes and longitudes with the function: gridlines ()
    - a scale bar: scale_bar ()&lt;/p&gt;

&lt;p&gt;Then save our chart with the command: plt.savefig&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Y=np.array([[77,0,111],[115,14,181],[160,17,222],[195,14,240],\
               [0,0,93],[21,38,177],[33,95,227],[32,162,247],[59,224,248],[202,255,250],\
               [4,255,179],[37,181,139],[32,132,81],[72,162,60],[157,240,96],[213,255,166],\
               [241,247,132],[248,185,68],[255,124,4],[235,78,14],[215,32,24],[189,24,40],[162,16,56],[135,16,65],[107,15,73]])/255.

colbar=mpl.colors.ListedColormap(Y)
fig=plt.figure(figsize=(22,12), frameon=True)  
ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-130,-60,18,62])

mm = ax.pcolormesh(lons,\
                   lats,\
                   Vals,\
                   vmin=-28,\
                   vmax=28, \
                   transform=ccrs.PlateCarree(),\
                   cmap=colbar )


ax.coastlines(resolution=&#39;110m&#39;);
ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))

states_provinces = cfeature.NaturalEarthFeature(
        category=&#39;cultural&#39;,
        name=&#39;admin_1_states_provinces_lines&#39;,
        scale=&#39;50m&#39;,
        facecolor=&#39;none&#39;)

ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;)  
ax.stock_img();

# Define gridline locations and draw the lines using cartopy&#39;s built-in gridliner:
xticks = np.arange(-150.0,-40.0,20)
yticks =np.arange(10,80,10)
ax.gridlines()

# Standard 6,000 km scale bar.
scale_bar(ax, (0.85, 0.2), 500 ,plot_kwargs = dict(linestyle=&#39;dashed&#39;, color=&#39;black&#39;))

cbar = plt.colorbar(mm, orientation=&#39;horizontal&#39;, shrink=0.75, drawedges=&#39;True&#39;, ticks=np.arange(-28, 28.1, 4),extend=&#39;both&#39;)
cbar.set_label(u&#39;\n Projection = Lambert Conformal Conic / Lambert Conique Conforme\nResolution: 5 Arcs-Minutes (10 km)\nData provided by Natural Resources Canada and the University of Washington/ Données fournies par Ressources Naturelles Canada et l Université de Washington&#39;, size=&#39;medium&#39;) # Affichage de la légende de la barre de couleur
cbar.ax.tick_params(labelsize=17) 
 
plt.xlabel(u&#39;\n\n\nTemperature / Température (°C)&#39;,size=&#39;x-large&#39;)
string_title=u&#39;Daily Minimum Temperature / Température Minimale Quotidienne\n in June / en Juin \nMonthly Mean Climatology / Climatologie Moyenne Mensuelle (1981 - 2010)\n\n&#39;
plt.title(string_title, size=&#39;xx-large&#39;)
plt.savefig(&#39;./figures/ANUSPLIN_NLDAS_10km_CLIM_TASMIN_06_1981-2010.png&#39;, bbox_inches=&#39;tight&#39;, pad_inches=0.1)
plt.show() 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_20_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-another-example-2d-netcdf&#34;&gt;2 - Another example  2D Netcdf&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;We will work with the climatology of the total monthly precipitation accumulation  (1981-2010) for the month of December.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from netCDF4 import Dataset
import matplotlib.pylab as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import numpy as np
from carto import scale_bar
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;rep_data=&#39;./DATA/ANUSPLIN/&#39;
fic=rep_data+&#39;ANUSPLIN_NLDAS_10km_CLIMATO_PrecTOT_1981_2010_12.nc&#39;
dset=Dataset(fic)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;precip=dset.variables[&#39;PrecTOT&#39;][:].squeeze()
lon=dset.variables[&#39;lon&#39;][:].squeeze()
lat=dset.variables[&#39;lat&#39;][:].squeeze()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## Interrogeons un peu chaque variable
print(&#39;-----------------------------------------&#39;)
print(&#39;dimension de precipitation = &#39;,precip.shape)
print(&#39;Min de precip est = &#39;, np.nanmin(precip))
print(&#39;Max de precip est = &#39;, np.nanmax(precip))
print(&#39;-----------------------------------------&#39;)
print(&#39;-----------------------------------------&#39;)
print(&#39;dimension de latitude = &#39;,lat.shape)
print(&#39;Min de lat est = &#39;, np.min(lat))
print(&#39;Max de lat est = &#39;, np.max(lat))
print(&#39;-----------------------------------------&#39;)
print(&#39;-----------------------------------------&#39;)
print(&#39;dimension de longitude = &#39;,lon.shape)
print(&#39;Min de lon est = &#39;, np.min(lon))
print(&#39;Max de lon est = &#39;, np.max(lon))
print(&#39;-----------------------------------------&#39;)
dimension de precipitation =  (1068, 420)
Min de precip est =  2.2327309
Max de precip est =  809.1944
dimension de latitude =  (1068, 420)
Min de lat est =  25.125
Max de lat est =  60.041664
dimension de longitude =  (1068, 420)
Min de lon est =  -140.95833
Max de lon est =  -52.04167
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(22,12))

ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-130,-60,18,62])
ax.coastlines(resolution=&#39;110m&#39;);
ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))

## Choisissons une colormap
cmap0=plt.cm.jet_r
cmap0.set_under(&#39;w&#39;) ## on met en blanc les valeurs inferieures au min de clev
cmap0.set_over(&#39;darkblue&#39;) ## bleu fonce pour les valeurs extremes de pluie

mm = ax.pcolormesh(lon,\
               lat,\
               precip,\
               vmin=0,\
               vmax=150, \
               transform=ccrs.PlateCarree(),\
               cmap=cmap0 )

states_provinces = cfeature.NaturalEarthFeature(
    category=&#39;cultural&#39;,
    name=&#39;admin_1_states_provinces_lines&#39;,
    scale=&#39;50m&#39;,
    facecolor=&#39;none&#39;)

ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;)  
ax.stock_img();

ax.gridlines()

# Define gridline locations and draw the lines using cartopy&#39;s built-in gridliner:
xticks = np.arange(-150.0,-40.0,20)
yticks =np.arange(10,80,10)

fig.canvas.draw()

# Standard 6,000 km scale bar.
scale_bar(ax, (0.85, 0.2), 500 ,plot_kwargs = dict(linestyle=&#39;dashed&#39;, color=&#39;black&#39;))

cbar = plt.colorbar(mm, shrink=0.75, drawedges=&#39;True&#39;, ticks=np.arange(0, 150.1, 20),extend=&#39;both&#39;)
cbar.ax.tick_params(labelsize=17) 

plt.xlabel(u&#39;\Precipitation (mm)&#39;,size=&#39;x-large&#39;)
string_title=u&#39;Precipitation climatology ANUSPLIN: December 1981-2010&#39;
plt.title(string_title, size=&#39;xx-large&#39;)
plt.savefig(&#39;./figures/My_2Dlalon_plot.png&#39;, bbox_inches=&#39;tight&#39;, pad_inches=0.1,  dpi=150)
plt.show()  
plt.close()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_26_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-cartopy-example-with-overplot&#34;&gt;3 - Cartopy: example with overplot&lt;/h2&gt;

&lt;p&gt;Sometimes we want to have many plots on the same picture.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We will work the climatologies of the total monthly accumulation of precipitation (1981-2010) for all the months of the year.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We will produce the same previous operation but for each month using a loop for.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## we import librairies that we need

from netCDF4 import Dataset
import matplotlib.pylab as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import numpy as np
from carto import scale_bar

month_name=[&amp;quot;Jan&amp;quot;,&amp;quot;Feb&amp;quot;,&amp;quot;Mar&amp;quot;,&amp;quot;Apr&amp;quot;,&amp;quot;May&amp;quot;,&amp;quot;June&amp;quot;,&amp;quot;Jul&amp;quot;,&amp;quot;Aug&amp;quot;,&amp;quot;Sep&amp;quot;,&amp;quot;Oct&amp;quot;,&amp;quot;Nov&amp;quot;,&amp;quot;Dec&amp;quot;]
rep_data=&#39;./DATA/ANUSPLIN/&#39;

fig=plt.figure(figsize=(12,15))
clevs=np.arange(5,150.1,5)
## Colormap we will use
cmap0=plt.cm.jet_r
cmap0.set_under(&#39;w&#39;) 
cmap0.set_over(&#39;darkblue&#39;)

for imonth in np.arange(1,13):  # loop over 12 months
    ax=fig.add_subplot(4,3,imonth, projection=ccrs.LambertConformal())   
    fic=rep_data+&#39;ANUSPLIN_NLDAS_10km_CLIMATO_PrecTOT_1981_2010_&#39;+&#39;{:02d}&#39;.format(imonth)+&#39;.nc&#39;
    dset=Dataset(fic)
    precip=dset.variables[&#39;PrecTOT&#39;][:].squeeze()
    lon=dset.variables[&#39;lon&#39;][:].squeeze()
    lat=dset.variables[&#39;lat&#39;][:].squeeze()
    
    ax.set_extent([-130,-60,18,62])
    ax.coastlines(resolution=&#39;110m&#39;);
    ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))
    ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))
    ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))
    ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))

    mm = ax.pcolormesh(lon,\
                   lat,\
                   precip,\
                   vmin=0,\
                   vmax=150, \
                   transform=ccrs.PlateCarree(),\
                   cmap=cmap0 )
    plt.title(&#39;Normale &#39;+ month_name[imonth-1],fontsize=12)
    states_provinces = cfeature.NaturalEarthFeature(
        category=&#39;cultural&#39;,
        name=&#39;admin_1_states_provinces_lines&#39;,
        scale=&#39;50m&#39;,
        facecolor=&#39;none&#39;)

    ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;)  
    ax.stock_img();
    ax.gridlines();
    # Standard 6,000 km scale bar.
    scale_bar(ax, (0.85, 0.2), 500 ,plot_kwargs = dict(linestyle=&#39;dashed&#39;, color=&#39;black&#39;))

plt.savefig(&#39;./figures/My_2Dlalon_multipanel_plot.png&#39;)
plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_28_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-cartopy-modis&#34;&gt;4 - Cartopy:  MODIS&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lance-modis.eosdis.nasa.gov/imagery/gallery/2012270-0926/Miriam.A2012270.2050.2km.jpg&#34; target=&#34;_blank&#34;&gt;https://lance-modis.eosdis.nasa.gov/imagery/gallery/2012270-0926/Miriam.A2012270.2050.2km.jpg&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://lance-modis.eosdis.nasa.gov/imagery/gallery/2012270-0926/Miriam.A2012270.2050.txt&#34; target=&#34;_blank&#34;&gt;https://lance-modis.eosdis.nasa.gov/imagery/gallery/2012270-0926/Miriam.A2012270.2050.txt&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(12, 20))

fname = &#39;./figures/Miriam.A2012270.2050.1km.jpg&#39;
img_extent = (-120.67660000000001, -106.32104523100001, 13.2301484511245, 30.766899999999502)
img = plt.imread(fname)

ax = plt.axes(projection=ccrs.PlateCarree())

# set a margin around the data
ax.set_xmargin(0.05)
ax.set_ymargin(0.10)

# ajout de l&#39;image
ax.imshow(img, origin=&#39;upper&#39;, extent=img_extent, transform=ccrs.PlateCarree())
ax.coastlines(resolution=&#39;50m&#39;, color=&#39;black&#39;, linewidth=1)

# ajout d&#39;une ville
ax.plot(-117.1625, 32.715, &#39;bo&#39;, markersize=7, transform=ccrs.Geodetic())
ax.text(-117, 33, &#39;San Diego&#39;, transform=ccrs.Geodetic())
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Text(-117, 33, &#39;San Diego&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_30_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>4 Xarray</title>
      <link>/courses/tutorial_python_netcdf/4-xarray_library/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0100</pubDate>
      <guid>/courses/tutorial_python_netcdf/4-xarray_library/</guid>
      <description>

&lt;p&gt;In this tutorial, we will use the features of the Python xarray library to process and analyze Netcdf files.&lt;/p&gt;

&lt;p&gt;To install the library under anaconda:&lt;/p&gt;

&lt;p&gt;$ conda install xarray&lt;/p&gt;

&lt;p&gt;Here is an example of structure of a Netcdf file under xarray:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/xarray.png&#34; alt=&#34;image0&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt; DataArray &lt;/b&gt;&lt;/p&gt;

&lt;p&gt;xarray.DataArray is xarray’s implementation of a labeled, multi-dimensional array. It has several key properties:
|  |  |
|&amp;ndash;|&amp;ndash;|
| &lt;b&gt;values&lt;/b&gt; |  a numpy.ndarray holding the array’s values |
| &lt;b&gt;dims&lt;/b&gt; |  dimension names for each axis (e.g., (&amp;lsquo;x&amp;rsquo;, &amp;lsquo;y&amp;rsquo;, &amp;lsquo;z&amp;rsquo;,&amp;lsquo;time&amp;rsquo;)) |
| &lt;b&gt;coords&lt;/b&gt; | a dict-like container of arrays (coordinates) that label each point (e.g., 1-dimensional arrays of numbers, datetime objects or strings) |
| &lt;b&gt;attrs&lt;/b&gt; |  an OrderedDict to hold arbitrary metadata (attributes) |&lt;/p&gt;

&lt;p&gt;&lt;b&gt; DataSet &lt;/b&gt;&lt;/p&gt;

&lt;p&gt;xarray.Dataset is xarray’s multi-dimensional equivalent of a DataFrame. It is a dict-like container of labeled arrays (DataArray objects) with aligned dimensions. It is designed as an in-memory representation of the data model from the netCDF file format.&lt;/p&gt;

&lt;p&gt;xarray.DataSet is a collection of DataArrays. Each NetCDF file contains a DataSet.&lt;/p&gt;

&lt;h2 id=&#34;1-open-a-netcdf-file&#34;&gt;1- Open a Netcdf file&lt;/h2&gt;

&lt;p&gt;We will open and store the data of a Netcdf file in a Dataset.&lt;/p&gt;

&lt;p&gt;First we need to import librairies and create aliases.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import xarray as xr
import warnings; warnings.filterwarnings(action=&#39;ignore&#39;)
from matplotlib import pyplot as plt
%matplotlib inline
plt.rcParams[&#39;figure.figsize&#39;] = (8,5)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;To import and store as dataset only one Netcdf file:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We will work with temperature fields from cera20c reanalysis.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;unique_dataDIR = &#39;./DATA/CERA20C/cera20c_member0_TAS_197101_day.nc&#39;
TAS = xr.open_dataset(unique_dataDIR)
TAS
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (bnds: 2, latitude: 145, longitude: 288, time: 31)
Coordinates:
  * longitude  (longitude) float32 0.0 1.25 2.5 3.75 ... 356.25 357.5 358.75
  * latitude   (latitude) float32 90.0 88.75 87.5 86.25 ... -87.5 -88.75 -90.0
  * time       (time) datetime64[ns] 1971-01-01T10:30:00 ... 1971-01-31T10:30:00
Dimensions without coordinates: bnds
Data variables:
    time_bnds  (time, bnds) datetime64[ns] ...
    t2m        (time, latitude, longitude) float32 ...
Attributes:
    CDI:          Climate Data Interface version 1.6.9 (http://mpimet.mpg.de/...
    Conventions:  CF-1.6
    history:      Thu Oct 25 14:29:40 2018: cdo daymean ./TAS/cera20c_member0...
    CDO:          Climate Data Operators version 1.6.9 (http://mpimet.mpg.de/...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;If we want to import several Netcdf files:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here, we want to store all files&amp;rsquo; names starting with &amp;lsquo;cera20c_member0&lt;em&gt;TAS&lt;/em&gt;&amp;rsquo; and located in &amp;lsquo;./data/cera20c/&amp;rsquo; path.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;multi_dataDIR = &#39;./DATA/CERA20C/cera20c_member0_TAS_*.nc&#39;
TAS2 = xr.open_mfdataset(multi_dataDIR)
TAS2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (bnds: 2, latitude: 145, longitude: 288, time: 365)
Coordinates:
  * longitude  (longitude) float32 0.0 1.25 2.5 3.75 ... 356.25 357.5 358.75
  * latitude   (latitude) float32 90.0 88.75 87.5 86.25 ... -87.5 -88.75 -90.0
  * time       (time) datetime64[ns] 1971-01-01T10:30:00 ... 1971-12-31T10:30:00
Dimensions without coordinates: bnds
Data variables:
    time_bnds  (time, bnds) datetime64[ns] dask.array&amp;lt;shape=(365, 2), chunksize=(31, 2)&amp;gt;
    t2m        (time, latitude, longitude) float32 dask.array&amp;lt;shape=(365, 145, 288), chunksize=(31, 145, 288)&amp;gt;
Attributes:
    CDI:          Climate Data Interface version 1.6.9 (http://mpimet.mpg.de/...
    Conventions:  CF-1.6
    history:      Thu Oct 25 14:29:40 2018: cdo daymean ./TAS/cera20c_member0...
    CDO:          Climate Data Operators version 1.6.9 (http://mpimet.mpg.de/...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Combine Netcdf:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To combine variables and coordinates between multiple DataArray and/or Dataset objects, use merge(). It can merge a list of Dataset, DataArray or dictionaries of objects convertible to DataArray objects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;multi_dataDIR = &#39;./DATA/CERA20C/cera20c_member0_TAS_*.nc&#39;
TAS2 = xr.open_mfdataset(multi_dataDIR)
multi_dataDIR2 = &#39;./DATA/CERA20C/cera20c_member0_SIC_*.nc&#39;
SIC2 = xr.open_mfdataset(multi_dataDIR2)

DS_new = xr.merge([TAS2,SIC2])
DS_new
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (bnds: 2, latitude: 145, longitude: 288, time: 365)
Coordinates:
  * longitude  (longitude) float32 0.0 1.25 2.5 3.75 ... 356.25 357.5 358.75
  * latitude   (latitude) float32 90.0 88.75 87.5 86.25 ... -87.5 -88.75 -90.0
  * time       (time) datetime64[ns] 1971-01-01T10:30:00 ... 1971-12-31T10:30:00
Dimensions without coordinates: bnds
Data variables:
    time_bnds  (time, bnds) datetime64[ns] dask.array&amp;lt;shape=(365, 2), chunksize=(31, 2)&amp;gt;
    t2m        (time, latitude, longitude) float32 dask.array&amp;lt;shape=(365, 145, 288), chunksize=(31, 145, 288)&amp;gt;
    siconc     (time, latitude, longitude) float32 dask.array&amp;lt;shape=(365, 145, 288), chunksize=(31, 145, 288)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-exploring-the-data&#34;&gt;2- Exploring the data&lt;/h2&gt;

&lt;p&gt;We can quickly explore our datasets by using some methods of the xarray library:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DS.var&lt;/li&gt;
&lt;li&gt;DS.dims&lt;/li&gt;
&lt;li&gt;DS.coords&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DS.attrs&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;DS_new.var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;bound method ImplementsDatasetReduce._reduce_method.&lt;locals&gt;.wrapped_func of &lt;xarray.Dataset&gt;
Dimensions:    (bnds: 2, latitude: 145, longitude: 288, time: 365)
Coordinates:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;longitude  (longitude) float32 0.0 1.25 2.5 3.75 &amp;hellip; 356.25 357.5 358.75&lt;/li&gt;
&lt;li&gt;latitude   (latitude) float32 90.0 88.75 87.5 86.25 &amp;hellip; -87.5 -88.75 -90.0&lt;/li&gt;

&lt;li&gt;&lt;p&gt;time       (time) datetime64[ns] 1971-01-01T10:30:00 &amp;hellip; 1971-12-31T10:30:00
Dimensions without coordinates: bnds
Data variables:
time_bnds  (time, bnds) datetime64[ns] dask.array&lt;shape=(365, 2), chunksize=(31, 2)&gt;
t2m        (time, latitude, longitude) float32 dask.array&lt;shape=(365, 145, 288), chunksize=(31, 145, 288)&gt;
siconc     (time, latitude, longitude) float32 dask.array&lt;shape=(365, 145, 288), chunksize=(31, 145, 288)&gt;&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;DS_new.dims
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Frozen(SortedKeysDict({&amp;lsquo;longitude&amp;rsquo;: 288, &amp;lsquo;latitude&amp;rsquo;: 145, &amp;lsquo;time&amp;rsquo;: 365, &amp;lsquo;bnds&amp;rsquo;: 2}))&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;DS_new.coords
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Coordinates:
  * longitude  (longitude) float32 0.0 1.25 2.5 3.75 &amp;hellip; 356.25 357.5 358.75
  * latitude   (latitude) float32 90.0 88.75 87.5 86.25 &amp;hellip; -87.5 -88.75 -90.0
  * time       (time) datetime64[ns] 1971-01-01T10:30:00 &amp;hellip; 1971-12-31T10:30:00&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;DS_new.attrs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OrderedDict()&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-basic-operations-with-xarray&#34;&gt;3- Basic operations with Xarray:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Select a date:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can use .sel() method to select one timestamp from our Dataset.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;DS_date = DS_new.sel(time=&#39;1971-01-01&#39;)
DS_date
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (bnds: 2, latitude: 145, longitude: 288, time: 1)
Coordinates:
  * longitude  (longitude) float32 0.0 1.25 2.5 3.75 ... 356.25 357.5 358.75
  * latitude   (latitude) float32 90.0 88.75 87.5 86.25 ... -87.5 -88.75 -90.0
  * time       (time) datetime64[ns] 1971-01-01T10:30:00
Dimensions without coordinates: bnds
Data variables:
    time_bnds  (time, bnds) datetime64[ns] dask.array&amp;lt;shape=(1, 2), chunksize=(1, 2)&amp;gt;
    t2m        (time, latitude, longitude) float32 dask.array&amp;lt;shape=(1, 145, 288), chunksize=(1, 145, 288)&amp;gt;
    siconc     (time, latitude, longitude) float32 dask.array&amp;lt;shape=(1, 145, 288), chunksize=(1, 145, 288)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Select time range&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can select a time range with slicing&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;DS_date_range = DS_new.sel(time=slice(&#39;1971-06-01&#39;, &#39;1971-08-31&#39;))
DS_date_range
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (bnds: 2, latitude: 145, longitude: 288, time: 92)
Coordinates:
  * longitude  (longitude) float32 0.0 1.25 2.5 3.75 ... 356.25 357.5 358.75
  * latitude   (latitude) float32 90.0 88.75 87.5 86.25 ... -87.5 -88.75 -90.0
  * time       (time) datetime64[ns] 1971-06-01T10:30:00 ... 1971-08-31T10:30:00
Dimensions without coordinates: bnds
Data variables:
    time_bnds  (time, bnds) datetime64[ns] dask.array&amp;lt;shape=(92, 2), chunksize=(30, 2)&amp;gt;
    t2m        (time, latitude, longitude) float32 dask.array&amp;lt;shape=(92, 145, 288), chunksize=(30, 145, 288)&amp;gt;
    siconc     (time, latitude, longitude) float32 dask.array&amp;lt;shape=(92, 145, 288), chunksize=(30, 145, 288)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Export a dataset&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can export our dataset into dataframe and then use Pandas library to make analysis.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df = DS_date_range.to_dataframe()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;time_bnds&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;t2m&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;siconc&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;(0, 90.0, 0.0, Timestamp(&amp;lsquo;1971-06-01 10:30:00&amp;rsquo;))&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1971-06-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;266.296&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.990234&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;(0, 90.0, 0.0, Timestamp(&amp;lsquo;1971-06-02 10:30:00&amp;rsquo;))&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1971-06-02 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;264.76&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.988525&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;(0, 90.0, 0.0, Timestamp(&amp;lsquo;1971-06-03 10:30:00&amp;rsquo;))&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1971-06-03 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;265.866&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.987502&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;(0, 90.0, 0.0, Timestamp(&amp;lsquo;1971-06-04 10:30:00&amp;rsquo;))&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1971-06-04 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;265.947&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.98738&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;(0, 90.0, 0.0, Timestamp(&amp;lsquo;1971-06-05 10:30:00&amp;rsquo;))&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1971-06-05 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;266.126&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.987152&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df.describe()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;t2m&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;siconc&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;count&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.68384e+06&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.68384e+06&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;mean&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;267.002&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.141752&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;std&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;25.852&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.312001&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;min&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;192.562&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;25%&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;273.221&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;50%&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;285.734&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;75%&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;296.388&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;max&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;314.804&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Time mean&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Mean_array = DS_date_range.mean(dim=&#39;time&#39;)
Mean_array.values
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;bound method Mapping.values of &lt;xarray.Dataset&gt;
Dimensions:    (latitude: 145, longitude: 288)
Coordinates:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;longitude  (longitude) float32 0.0 1.25 2.5 3.75 &amp;hellip; 356.25 357.5 358.75&lt;/li&gt;
&lt;li&gt;latitude   (latitude) float32 90.0 88.75 87.5 86.25 &amp;hellip; -87.5 -88.75 -90.0
Data variables:
t2m        (latitude, longitude) float32 dask.array&lt;shape=(145, 288), chunksize=(145, 288)&gt;
siconc     (latitude, longitude) float32 dask.array&lt;shape=(145, 288), chunksize=(145, 288)&gt;&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To save our results into csv:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Mean_array.t2m.to_dataframe().to_csv(&#39;./DATA/CERA20C_T2m_mean.csv&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mean over all latitudes and longitudes grid points:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;DS_date_range.t2m.mean(dim=(&#39;latitude&#39;, &#39;longitude&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;xarray.DataArray &#39;t2m&#39; (time: 92)&gt;
dask.array&lt;shape=(92,), dtype=float32, chunksize=(30,)&gt;
Coordinates:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;time     (time) datetime64[ns] 1971-06-01T10:30:00 &amp;hellip; 1971-08-31T10:30:00&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;DS_date_range.t2m.mean(dim=(&#39;latitude&#39;, &#39;longitude&#39;)).plot()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[&lt;matplotlib.lines.Line2D at 0xabe86a0&gt;]&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_27_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;To save into csv:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;DS_date_range.t2m.mean(dim=(&#39;time&#39;, &#39;longitude&#39;)).to_dataframe().to_csv(&#39;./DATA/CERA20C_T2m_2Dmean.csv&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Quick plot with Xarray&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import cartopy.crs as ccrs
fig=plt.figure(figsize=(10,10), frameon=True) 

ax = plt.axes(projection=ccrs.Orthographic(-80, 35))
Mean_array.t2m.plot.contourf(ax=ax, transform=ccrs.PlateCarree());
ax.set_global(); ax.coastlines();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_31_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Basic operations with Xarray:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this example, we will mean DS_date_range over time and apply a substration to change units.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;centigrade = DS_date_range.t2m.mean(dim=&#39;time&#39;) - 273.16
centigrade.values
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;array([[ -1.2229004,  -1.2229004,  -1.2229004, ...,  -1.2229004,
         -1.2229004,  -1.2229004],
       [ -1.3348389,  -1.3311157,  -1.3274231, ...,  -1.3488159,
         -1.3442383,  -1.3395386],
       [ -1.6027222,  -1.5914001,  -1.5804138, ...,  -1.6451721,
         -1.631012 ,  -1.6168518],
       ...,
       [-58.547928 , -58.5663   , -58.58455  , ..., -58.314026 ,
        -58.391983 , -58.46997  ],
       [-59.556473 , -59.577957 , -59.59955  , ..., -59.478424 ,
        -59.50441  , -59.53041  ],
       [-60.739105 , -60.739105 , -60.739105 , ..., -60.739105 ,
        -60.739105 , -60.739105 ]], dtype=float32)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig=plt.figure(figsize=(10,10), frameon=True)
ax = plt.axes(projection=ccrs.Orthographic(-80, 35))
centigrade.plot.contourf(ax=ax, transform=ccrs.PlateCarree());
ax.set_global(); ax.coastlines();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_34_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Groupby() method:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;groupdby() method with Xarray is very usefull to group our datasets by month, season, year&amp;hellip; and then apply function to compute indices.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;DS_new
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (bnds: 2, latitude: 145, longitude: 288, time: 365)
Coordinates:
  * longitude  (longitude) float32 0.0 1.25 2.5 3.75 ... 356.25 357.5 358.75
  * latitude   (latitude) float32 90.0 88.75 87.5 86.25 ... -87.5 -88.75 -90.0
  * time       (time) datetime64[ns] 1971-01-01T10:30:00 ... 1971-12-31T10:30:00
Dimensions without coordinates: bnds
Data variables:
    time_bnds  (time, bnds) datetime64[ns] dask.array&amp;lt;shape=(365, 2), chunksize=(31, 2)&amp;gt;
    t2m        (time, latitude, longitude) float32 dask.array&amp;lt;shape=(365, 145, 288), chunksize=(31, 145, 288)&amp;gt;
    siconc     (time, latitude, longitude) float32 dask.array&amp;lt;shape=(365, 145, 288), chunksize=(31, 145, 288)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# monthly mean:
DS_month = DS_new.groupby(&#39;time.month&#39;).mean(&#39;time&#39;)
DS_month
#DS_month.to_dataframe()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 145, longitude: 288, month: 12)
Coordinates:
  * longitude  (longitude) float32 0.0 1.25 2.5 3.75 ... 356.25 357.5 358.75
  * latitude   (latitude) float32 90.0 88.75 87.5 86.25 ... -87.5 -88.75 -90.0
  * month      (month) int64 1 2 3 4 5 6 7 8 9 10 11 12
Data variables:
    t2m        (month, latitude, longitude) float32 dask.array&amp;lt;shape=(12, 145, 288), chunksize=(1, 145, 288)&amp;gt;
    siconc     (month, latitude, longitude) float32 dask.array&amp;lt;shape=(12, 145, 288), chunksize=(1, 145, 288)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use this method to compute climatology and then anomalies.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;climatology = DS_new.groupby(&#39;time.month&#39;).mean(&#39;time&#39;)
anomalies = DS_new.groupby(&#39;time.month&#39;) - climatology
anomalies
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 145, longitude: 288, time: 365)
Coordinates:
  * longitude  (longitude) float32 0.0 1.25 2.5 3.75 ... 356.25 357.5 358.75
  * latitude   (latitude) float32 90.0 88.75 87.5 86.25 ... -87.5 -88.75 -90.0
  * time       (time) datetime64[ns] 1971-01-01T10:30:00 ... 1971-12-31T10:30:00
    month      (time) int64 1 1 1 1 1 1 1 1 1 1 ... 12 12 12 12 12 12 12 12 12
Data variables:
    t2m        (time, latitude, longitude) float32 dask.array&amp;lt;shape=(365, 145, 288), chunksize=(31, 145, 288)&amp;gt;
    siconc     (time, latitude, longitude) float32 dask.array&amp;lt;shape=(365, 145, 288), chunksize=(31, 145, 288)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# seaon mean:
DS_season = DS_new.groupby(&#39;time.season&#39;).mean(&#39;time&#39;)
DS_season
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 145, longitude: 288, season: 4)
Coordinates:
  * longitude  (longitude) float32 0.0 1.25 2.5 3.75 ... 356.25 357.5 358.75
  * latitude   (latitude) float32 90.0 88.75 87.5 86.25 ... -87.5 -88.75 -90.0
  * season     (season) object &#39;DJF&#39; &#39;JJA&#39; &#39;MAM&#39; &#39;SON&#39;
Data variables:
    t2m        (season, latitude, longitude) float32 dask.array&amp;lt;shape=(4, 145, 288), chunksize=(1, 145, 288)&amp;gt;
    siconc     (season, latitude, longitude) float32 dask.array&amp;lt;shape=(4, 145, 288), chunksize=(1, 145, 288)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# year mean:
DS_year = DS_new.groupby(&#39;time.year&#39;).mean(&#39;time&#39;)
DS_year
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 145, longitude: 288, year: 1)
Coordinates:
  * longitude  (longitude) float32 0.0 1.25 2.5 3.75 ... 356.25 357.5 358.75
  * latitude   (latitude) float32 90.0 88.75 87.5 86.25 ... -87.5 -88.75 -90.0
  * year       (year) int64 1971
Data variables:
    t2m        (year, latitude, longitude) float32 dask.array&amp;lt;shape=(1, 145, 288), chunksize=(1, 145, 288)&amp;gt;
    siconc     (year, latitude, longitude) float32 dask.array&amp;lt;shape=(1, 145, 288), chunksize=(1, 145, 288)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;to select a specific season:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;DS_winter = DS_season.sel(season=&#39;DJF&#39;)
DS_winter
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;xarray.Dataset&gt;
Dimensions:    (latitude: 145, longitude: 288)
Coordinates:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;longitude  (longitude) float32 0.0 1.25 2.5 3.75 &amp;hellip; 356.25 357.5 358.75&lt;/li&gt;
&lt;li&gt;latitude   (latitude) float32 90.0 88.75 87.5 86.25 &amp;hellip; -87.5 -88.75 -90.0
season     &lt;U3 &#39;DJF&#39;
Data variables:
t2m        (latitude, longitude) float32 dask.array&lt;shape=(145, 288), chunksize=(145, 288)&gt;
siconc     (latitude, longitude) float32 dask.array&lt;shape=(145, 288), chunksize=(145, 288)&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the example below, we will group the xarray.DataArray data by season, calculate the average, apply a simple arrhythmic operation and plot the resulting fields for each season.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;DS_Season = DS_new.t2m.groupby(&#39;time.season&#39;).mean(&#39;time&#39;)- 273.15
fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(9,5))
j = 0
for i, season in enumerate((&#39;DJF&#39;, &#39;MAM&#39;, &#39;JJA&#39;, &#39;SON&#39;)):
    if season ==&#39;JJA&#39;:
        j += 1
        i = 0
    elif season ==&#39;SON&#39;:
        i = 1
        
    DS_Season.sel(season=season).plot.pcolormesh(
        ax=axes[i, j], vmin=-30, vmax=30, cmap=&#39;Spectral_r&#39;,
        add_colorbar=True, extend=&#39;both&#39;)

for ax in axes.flat:
    ax.axes.get_xaxis().set_ticklabels([])
    ax.axes.get_yaxis().set_ticklabels([])
    ax.axes.axis(&#39;tight&#39;)
   
plt.tight_layout()
fig.suptitle(&#39;Seasonal Surface Air Temperature&#39;, fontsize=16, y=1.02)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Text(0.5, 1.02, &#39;Seasonal Surface Air Temperature&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_45_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
lat_bnd = [80, 50]
lon_bnd = [250, 310]
DS_Season = DS_new.sel(longitude=slice(*lon_bnd), latitude=slice(*lat_bnd),).siconc.groupby(&#39;time.season&#39;).mean(&#39;time&#39;) *100

fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(16,10))
j = 0
for i, season in enumerate((&#39;DJF&#39;, &#39;MAM&#39;, &#39;JJA&#39;, &#39;SON&#39;)):
    if season ==&#39;JJA&#39;:
        j += 1
        i = 0
    elif season ==&#39;SON&#39;:
        i = 1
        
    DS_Season.sel(season=season).plot.pcolormesh(
        ax=axes[i, j], vmin=0, vmax=100, cmap=&#39;Spectral_r&#39;,
        add_colorbar=True, extend=&#39;both&#39;)
for ax in axes.flat:
    ax.axes.get_xaxis().set_ticklabels([])
    ax.axes.get_yaxis().set_ticklabels([])
    ax.axes.axis(&#39;tight&#39;)
   
plt.tight_layout()
fig.suptitle(&#39;Seasonal Sea Ice Concentration&#39;, fontsize=16, y=1.02)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Text(0.5, 1.02, &#39;Seasonal Sea Ice Concentration&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_46_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;To save our result into Netcdf:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;DS_season = DS_new.groupby(&#39;time.season&#39;).mean(&#39;time&#39;)
dataDIR = &#39;./DATA/CERA20C_season.nc&#39;
DS_Season.to_netcdf(dataDIR)

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-select-grid-points-from-netcdf-file-using-xarray&#34;&gt;4- Select grid points from Netcdf file using Xarray&lt;/h2&gt;

&lt;p&gt;In the previous section we applied the .sel () method to work on the time dimension. This method can be used on spatial dimensions to extract points or study areas from our netcdf file.&lt;/p&gt;

&lt;h3 id=&#34;gridpoint-to-extract-the-closest-grid-point-of-a-latitude-longitude&#34;&gt;Gridpoint:  to extract the closest grid point of a latitude / longitude:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lati = 45.5
loni = 269.2
data  = DS_new.sel(longitude=loni  , latitude=lati  , method=&#39;nearest&#39;) 
data
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (bnds: 2, time: 365)
Coordinates:
    longitude  float32 268.75
    latitude   float32 45.0
  * time       (time) datetime64[ns] 1971-01-01T10:30:00 ... 1971-12-31T10:30:00
Dimensions without coordinates: bnds
Data variables:
    time_bnds  (time, bnds) datetime64[ns] dask.array&amp;lt;shape=(365, 2), chunksize=(31, 2)&amp;gt;
    t2m        (time) float32 dask.array&amp;lt;shape=(365,), chunksize=(31,)&amp;gt;
    siconc     (time) float32 dask.array&amp;lt;shape=(365,), chunksize=(31,)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data[&#39;t2m&#39;] = data[&#39;t2m&#39;] - 273.15
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data.t2m
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray &#39;t2m&#39; (time: 365)&amp;gt;
dask.array&amp;lt;shape=(365,), dtype=float32, chunksize=(31,)&amp;gt;
Coordinates:
    longitude  float32 268.75
    latitude   float32 45.0
  * time       (time) datetime64[ns] 1971-01-01T10:30:00 ... 1971-12-31T10:30:00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can convert our selection into a DataFrame and then use Pandas to analyse our results.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df = data.t2m.to_dataframe()
fig = plt.figure(figsize=(16,8))
df[&#39;t2m&#39;].plot()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0x13660400&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_55_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;gridpoints-to-extract-a-list-of-points&#34;&gt;Gridpoints:  to extract a list of points&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lats =  [20.0,50.0,90.0]
lons =  [60.0,80.0,120.0]

data  = DS_new.sel(longitude=lons  , latitude=lats  , method=&#39;nearest&#39;)
data[&#39;t2m&#39;] = data[&#39;t2m&#39;]-273.15
data
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (bnds: 2, latitude: 3, longitude: 3, time: 365)
Coordinates:
  * longitude  (longitude) float32 60.0 80.0 120.0
  * latitude   (latitude) float32 20.0 50.0 90.0
  * time       (time) datetime64[ns] 1971-01-01T10:30:00 ... 1971-12-31T10:30:00
Dimensions without coordinates: bnds
Data variables:
    time_bnds  (time, bnds) datetime64[ns] dask.array&amp;lt;shape=(365, 2), chunksize=(31, 2)&amp;gt;
    t2m        (time, latitude, longitude) float32 dask.array&amp;lt;shape=(365, 3, 3), chunksize=(31, 3, 3)&amp;gt;
    siconc     (time, latitude, longitude) float32 dask.array&amp;lt;shape=(365, 3, 3), chunksize=(31, 3, 3)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(16,8))
data.t2m.sel(longitude=60.0, latitude=[20.0,50.0,90.0]).plot.line(x=&#39;time&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&amp;lt;matplotlib.lines.Line2D at 0xdf31ac8&amp;gt;,
 &amp;lt;matplotlib.lines.Line2D at 0xdd0bf28&amp;gt;,
 &amp;lt;matplotlib.lines.Line2D at 0xdd0b4a8&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_58_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;to-extract-an-area-or-subdomain-delimited-by-latitude-and-longitude-values-slicing&#34;&gt;To extract an area or subdomain delimited by latitude and longitude values: .slicing()&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lat_bnd = [80, 50]
lon_bnd = [250, 310]
area = DS_new.sel(longitude=slice(*lon_bnd), latitude=slice(*lat_bnd),)
area
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (bnds: 2, latitude: 25, longitude: 49, time: 365)
Coordinates:
  * longitude  (longitude) float32 250.0 251.25 252.5 ... 307.5 308.75 310.0
  * latitude   (latitude) float32 80.0 78.75 77.5 76.25 ... 52.5 51.25 50.0
  * time       (time) datetime64[ns] 1971-01-01T10:30:00 ... 1971-12-31T10:30:00
Dimensions without coordinates: bnds
Data variables:
    time_bnds  (time, bnds) datetime64[ns] dask.array&amp;lt;shape=(365, 2), chunksize=(31, 2)&amp;gt;
    t2m        (time, latitude, longitude) float32 dask.array&amp;lt;shape=(365, 25, 49), chunksize=(31, 25, 49)&amp;gt;
    siconc     (time, latitude, longitude) float32 dask.array&amp;lt;shape=(365, 25, 49), chunksize=(31, 25, 49)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;area.longitude.values
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;array([250.  , 251.25, 252.5 , 253.75, 255.  , 256.25, 257.5 , 258.75,
       260.  , 261.25, 262.5 , 263.75, 265.  , 266.25, 267.5 , 268.75,
       270.  , 271.25, 272.5 , 273.75, 275.  , 276.25, 277.5 , 278.75,
       280.  , 281.25, 282.5 , 283.75, 285.  , 286.25, 287.5 , 288.75,
       290.  , 291.25, 292.5 , 293.75, 295.  , 296.25, 297.5 , 298.75,
       300.  , 301.25, 302.5 , 303.75, 305.  , 306.25, 307.5 , 308.75,
       310.  ], dtype=float32)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To visualize our area::&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import cartopy.crs as ccrs
import cartopy.feature as cfeat
def make_figure():
    fig = plt.figure(figsize=(22, 12))
    ax = fig.add_subplot(1, 1, 1, projection=ccrs.PlateCarree())

    # generate a basemap with country borders, oceans and coastlines
    ax.add_feature(cfeat.LAND)
    ax.add_feature(cfeat.OCEAN)
    ax.add_feature(cfeat.COASTLINE)
    ax.add_feature(cfeat.BORDERS, linestyle=&#39;dotted&#39;)
    return fig, ax

make_figure();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_63_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;_, ax = make_figure()
# plot the temperature field
area.t2m[0].plot()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.collections.QuadMesh at 0xb2e9240&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_64_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;to-mask-an-area-delimited-by-a-shapefile&#34;&gt;To mask an area delimited by a Shapefile:&lt;/h3&gt;

&lt;p&gt;To do this, we need to import two more librairies:
- Geopandas: conda install -c conda-forge geopandas
- osgeo: conda install -c conda-forge gdal&lt;/p&gt;

&lt;p&gt;The next function will open a shapefile, read the polygons and make a mask from each grid points of our Netcdf inside the polygons.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from osgeo import ogr
import geopandas as gpd
import numpy as np
def get_mask(lons2d, lats2d, shp_path=&amp;quot;&amp;quot;, polygon_name=None):
    &amp;quot;&amp;quot;&amp;quot;
    Assumes that the shape file contains polygons in lat lon coordinates
    :param lons2d:
    :param lats2d:
    :param shp_path:
    :rtype : np.ndarray
    The mask is 1 for the points inside of the polygons
    &amp;quot;&amp;quot;&amp;quot;
    ds = ogr.Open(shp_path)
    &amp;quot;&amp;quot;&amp;quot;
    :type : ogr.DataSource
    &amp;quot;&amp;quot;&amp;quot;

    xx = lons2d.copy()
    yy = lats2d

    # set longitudes to be from -180 to 180
    xx[xx &amp;gt; 180] -= 360

    mask = np.zeros(lons2d.shape, dtype=int)
    nx, ny = mask.shape

    pt = ogr.Geometry(ogr.wkbPoint)

    for i in range(ds.GetLayerCount()):
        layer = ds.GetLayer(i)
        &amp;quot;&amp;quot;&amp;quot;
        :type : ogr.Layer
        &amp;quot;&amp;quot;&amp;quot;

        for j in range(layer.GetFeatureCount()):
            feat = layer.GetFeature(j)
            &amp;quot;&amp;quot;&amp;quot;
            :type : ogr.Feature
            &amp;quot;&amp;quot;&amp;quot;

            # Select polygons by the name property
            if polygon_name is not None:
                if not feat.GetFieldAsString(&amp;quot;NAME&amp;quot;) == polygon_name:
                    continue

            g = feat.GetGeometryRef()
            &amp;quot;&amp;quot;&amp;quot;
            :type : ogr.Geometry
            &amp;quot;&amp;quot;&amp;quot;

            assert isinstance(g, ogr.Geometry)

            for pi in range(nx):
                for pj in range(ny):
                    pt.SetPoint_2D(0, float(xx[pi, pj]), float(yy[pi, pj]))

                    mask[pi, pj] += int(g.Contains(pt))

    return mask

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We first read the Netcdf file and store informations in a Xarray.dataset.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ds = xr.open_dataset(&#39;./DATA/CERA20C/cera20c_member0_TAS_197101_day.nc&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We then need to extract latitudes and longitudes values and compute a 2D matrix.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Imp_Lats =  ds[&#39;latitude&#39;].values
Imp_Lons =  ds[&#39;longitude&#39;].values
lon2d, lat2d = np.meshgrid(Imp_Lons, Imp_Lats)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ds_mean = ds.mean(&#39;time&#39;) - 273.15
ds_mean
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 145, longitude: 288)
Coordinates:
  * latitude   (latitude) float32 90.0 88.75 87.5 86.25 ... -87.5 -88.75 -90.0
  * longitude  (longitude) float32 0.0 1.25 2.5 3.75 ... 356.25 357.5 358.75
Data variables:
    t2m        (latitude, longitude) float32 -34.067184 ... -25.249802
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We open the shape file with Geopandas library.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;shapes = gpd.read_file(&amp;quot;./DATA/Shapefiles/Countries_Final-polygon.shp&amp;quot;)
list(shapes.columns.values)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&#39;FIPS&#39;,
 &#39;ISO2&#39;,
 &#39;ISO3&#39;,
 &#39;UN&#39;,
 &#39;NAME&#39;,
 &#39;AREA&#39;,
 &#39;POP2005&#39;,
 &#39;REGION&#39;,
 &#39;SUBREGION&#39;,
 &#39;LON&#39;,
 &#39;LAT&#39;,
 &#39;layer&#39;,
 &#39;path&#39;,
 &#39;geometry&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;shapes.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;shapes.loc[27, &#39;geometry&#39;]
shapes.plot()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0xd8b4b70&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_75_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We want in our study to extract information inside Mexico shapefile.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mask=get_mask(lon2d,lat2d,shp_path=&amp;quot;./DATA/Shapefiles/Countries_Final-polygon.shp&amp;quot;, polygon_name=&#39;Mexico&#39;) 
np.max(mask)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will convert our mask into numpy 2D array. We&amp;rsquo;ll be later able to apply this matrix to mask our Netcdf file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;np.save(&#39;DATA/Mexico.npy&#39;,mask) # saving our mask in numpy.array
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will mask our area using .where() method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ds_mask = ds_mean.where(mask == 1) 
ds_mask.to_netcdf(&#39;DATA/Mexico.nc&#39;)  # we want to save our shapefile mask in Netcdf format
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ds_mask
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 145, longitude: 288)
Coordinates:
  * latitude   (latitude) float32 90.0 88.75 87.5 86.25 ... -87.5 -88.75 -90.0
  * longitude  (longitude) float32 0.0 1.25 2.5 3.75 ... 356.25 357.5 358.75
Data variables:
    t2m        (latitude, longitude) float32 nan nan nan nan ... nan nan nan nan
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;np.max(ds_mask.t2m)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray &#39;t2m&#39; ()&amp;gt;
array(24.010315)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;_, ax = make_figure()
# plot the temperature field
lat_bnd = [35, 0]
lon_bnd = [240, 280]
ds_mask.t2m.sel(longitude=slice(*lon_bnd), latitude=slice(*lat_bnd),).plot.pcolormesh(vmin=0, vmax=30, cmap=&#39;Spectral&#39;,add_colorbar=True, extend=&#39;both&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.collections.QuadMesh at 0xdc65400&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_84_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;5-last-example-using-xarray&#34;&gt;5- Last example using Xarray:&lt;/h2&gt;

&lt;p&gt;In this section, We will calculate the seasonal accumulation of the precipitation, extract a region, plot the domain and record our result in Netcdf:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Let&#39;s open cera20c_enda_ep_PR_*.nc netcdf files 
multi_dataDIR = &#39;./DATA/CERA20C/cera20c_enda_ep_PR_*.nc&#39;
array = xr.open_mfdataset(multi_dataDIR)
array.tp
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray &#39;tp&#39; (time: 365, latitude: 181, longitude: 360)&amp;gt;
dask.array&amp;lt;shape=(365, 181, 360), dtype=float32, chunksize=(31, 181, 360)&amp;gt;
Coordinates:
  * longitude  (longitude) float32 0.0 1.0 2.0 3.0 ... 356.0 357.0 358.0 359.0
  * latitude   (latitude) float32 90.0 89.0 88.0 87.0 ... -88.0 -89.0 -90.0
  * time       (time) datetime64[ns] 1971-01-02T18:00:00 ... 1972-01-01T18:00:00
Attributes:
    units:      m
    long_name:  Total precipitation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All Netcdf files are stored in DataArray container, we can now group our Datasets by season, apply a simple sum() method over time and then change units from meters to mm.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;array_season = array.groupby(&#39;time.season&#39;).sum(&#39;time&#39;)*1000
array_season
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 181, longitude: 360, season: 4)
Coordinates:
  * latitude   (latitude) float32 90.0 89.0 88.0 87.0 ... -88.0 -89.0 -90.0
  * season     (season) object &#39;DJF&#39; &#39;JJA&#39; &#39;MAM&#39; &#39;SON&#39;
  * longitude  (longitude) float32 0.0 1.0 2.0 3.0 ... 356.0 357.0 358.0 359.0
Data variables:
    tp         (season, latitude, longitude) float32 dask.array&amp;lt;shape=(4, 181, 360), chunksize=(1, 181, 360)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to extract a specific domain delimited:
    - latitude boundaries: 50N to 70N
    - longitude boudaries: 250E to 310E&lt;/p&gt;

&lt;p&gt;We finally want to extract winter season.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lat_bnd = [70, 50]
lon_bnd = [250, 310]
subset_season_DJF = array_season.sel(season = &#39;DJF&#39;, longitude=slice(*lon_bnd), latitude=slice(*lat_bnd),)
subset_season_DJF
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 21, longitude: 61)
Coordinates:
  * latitude   (latitude) float32 70.0 69.0 68.0 67.0 ... 53.0 52.0 51.0 50.0
    season     &amp;lt;U3 &#39;DJF&#39;
  * longitude  (longitude) float32 250.0 251.0 252.0 253.0 ... 308.0 309.0 310.0
Data variables:
    tp         (latitude, longitude) float32 dask.array&amp;lt;shape=(21, 61), chunksize=(21, 61)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s save the Dataset to Netcdf.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataDIR = &#39;./DATA/subset_season.nc&#39;
subset_season_DJF.to_netcdf(dataDIR)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can call our make_figure() function to quick plot our Dataset.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;_, ax = make_figure()
# plot the temperature field
subset_season_DJF.tp.plot.pcolormesh(vmin=0, vmax=200, cmap=&#39;Spectral&#39;,add_colorbar=True, extend=&#39;both&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.collections.QuadMesh at 0x130aedd8&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/img/netcdf/output_94_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;array_season
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 181, longitude: 360, season: 4)
Coordinates:
  * latitude   (latitude) float32 90.0 89.0 88.0 87.0 ... -88.0 -89.0 -90.0
  * season     (season) object &#39;DJF&#39; &#39;JJA&#39; &#39;MAM&#39; &#39;SON&#39;
  * longitude  (longitude) float32 0.0 1.0 2.0 3.0 ... 356.0 357.0 358.0 359.0
Data variables:
    tp         (season, latitude, longitude) float32 dask.array&amp;lt;shape=(4, 181, 360), chunksize=(1, 181, 360)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
