<!DOCTYPE html>
<html lang="en-us">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.6.2">

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Guillaume Dueymes">

  
  
  
    
  
  <meta name="description" content="﻿
- Netcdf: Select closest points using CKDTree In this post, we are going to define an algorithm to locate the closest points to a reference point, by using coordinate transformations, k-dimensional trees, and xarray pointwise indexing.
To select closest grid points, we will use here one approach using cKDTree class from scipy.spatial package.
Different method are considered here:
- nearest neighbour - nearest neighbours, weighting with the inverse of distance squared: - \begin{equation*} $T_t = \frac{\sum_{i=1}^{m}T_{s,i}w_i}{\sum_{i=1}^{m}w_i}$, $w_i = 1/d_i^2$) \end{equation*} - query ball point : Find all pairs of points whose distance is at most one distance  1- Let&rsquo;s import Python librairies #for Netcdf manipulation #import netCDF4 #from netCDF4 import Dataset import xarray as xr #for array manipulation import numpy as np import pandas as pd #for plotting import cartopy.">

  
  <link rel="alternate" hreflang="en-us" href="/post/ckdtree_netcdf/">

  


  
  
  
  <meta name="theme-color" content="#3f51b5">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/github.min.css" crossorigin="anonymous" title="hl-light">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" disabled>
        
      
    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.css" integrity="sha256-SHMGCYmST46SoyGgo4YR/9AlK1vf3ff84Aq9yK4hdqM=" crossorigin="anonymous">
    

    

  

  
  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700%7CRoboto:400,400italic,700%7CRoboto+Mono&display=swap">
  

  
  
  
  
  <link rel="stylesheet" href="/css/academic.css">

  




  


  

  <link rel="manifest" href="/index.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon-32.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="/post/ckdtree_netcdf/">

  
  
  
  
    
  
  
  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="og:site_name" content="GDueymes">
  <meta property="og:url" content="/post/ckdtree_netcdf/">
  <meta property="og:title" content="Netcdf select closest gridpoints | GDueymes">
  <meta property="og:description" content="﻿
- Netcdf: Select closest points using CKDTree In this post, we are going to define an algorithm to locate the closest points to a reference point, by using coordinate transformations, k-dimensional trees, and xarray pointwise indexing.
To select closest grid points, we will use here one approach using cKDTree class from scipy.spatial package.
Different method are considered here:
- nearest neighbour - nearest neighbours, weighting with the inverse of distance squared: - \begin{equation*} $T_t = \frac{\sum_{i=1}^{m}T_{s,i}w_i}{\sum_{i=1}^{m}w_i}$, $w_i = 1/d_i^2$) \end{equation*} - query ball point : Find all pairs of points whose distance is at most one distance  1- Let&rsquo;s import Python librairies #for Netcdf manipulation #import netCDF4 #from netCDF4 import Dataset import xarray as xr #for array manipulation import numpy as np import pandas as pd #for plotting import cartopy."><meta property="og:image" content="/post/ckdtree_netcdf/featured.png">
  <meta property="twitter:image" content="/post/ckdtree_netcdf/featured.png"><meta property="og:locale" content="en-us">
  
    
      <meta property="article:published_time" content="2020-02-26T13:10:29-08:00">
    
    <meta property="article:modified_time" content="2020-02-26T13:10:29-08:00">
  

  


    






  






<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/post/ckdtree_netcdf/"
  },
  "headline": "Netcdf select closest gridpoints",
  
  "image": [
    "/post/ckdtree_netcdf/featured.png"
  ],
  
  "datePublished": "2020-02-26T13:10:29-08:00",
  "dateModified": "2020-02-26T13:10:29-08:00",
  
  "author": {
    "@type": "Person",
    "name": "Guillaume Dueymes"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "GDueymes",
    "logo": {
      "@type": "ImageObject",
      "url": "/img/icon-512.png"
    }
  },
  "description": "﻿\n- Netcdf: Select closest points using CKDTree In this post, we are going to define an algorithm to locate the closest points to a reference point, by using coordinate transformations, k-dimensional trees, and xarray pointwise indexing.\nTo select closest grid points, we will use here one approach using cKDTree class from scipy.spatial package.\nDifferent method are considered here:\n- nearest neighbour - nearest neighbours, weighting with the inverse of distance squared: - \\begin{equation*} $T_t = \\frac{\\sum_{i=1}^{m}T_{s,i}w_i}{\\sum_{i=1}^{m}w_i}$, $w_i = 1/d_i^2$) \\end{equation*} - query ball point : Find all pairs of points whose distance is at most one distance  1- Let\u0026rsquo;s import Python librairies #for Netcdf manipulation #import netCDF4 #from netCDF4 import Dataset import xarray as xr #for array manipulation import numpy as np import pandas as pd #for plotting import cartopy."
}
</script>

  

  


  


  





  <title>Netcdf select closest gridpoints | GDueymes</title>

</head>

<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" >

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  
<nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
    
    
      <a class="navbar-brand" href="/">GDueymes</a>
    

    
    <button type="button" class="navbar-toggler" data-toggle="collapse"
            data-target="#navbar-content" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span><i class="fas fa-bars"></i></span>
    </button>
    

    
    
    <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

      
      <ul class="navbar-nav d-md-inline-flex">
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#posts"><span>Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#projects"><span>Projects</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#publications"><span>Publications</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/courses/"><span>Courses</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#contact"><span>Contact</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/files/Guillaume_Dueymes2019.pdf"><span>CV</span></a>
        </li>

        
        

      

        
      </ul>
    </div>

    <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">
      
      <li class="nav-item">
        <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
      </li>
      

      
      <li class="nav-item">
        <a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a>
      </li>
      

      

    </ul>

  </div>
</nav>


  <article class="article">

  




















  
  
    
  


<div class="article-container pt-3">
  <h1>Netcdf select closest gridpoints</h1>

  

  


<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
    
    Feb 26, 2020
  </span>
  

  

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    8 min read
  </span>
  

  
  
  

  
  

</div>

  














</div>


<div class="article-header article-container featured-image-wrapper mt-4 mb-4" style="max-width: 720px; max-height: 449px;">
  <div style="position: relative">
    <img src="/post/ckdtree_netcdf/featured_hu21f32ecfeba6778ad8835e33dfa782ed_110273_720x0_resize_lanczos_2.png" alt="" class="featured-image">
    
  </div>
</div>



  <div class="article-container">

    <div class="article-style">
      

<p>﻿</p>

<h2 id="netcdf-select-closest-points-using-ckdtree">- Netcdf: Select closest points using CKDTree</h2>

<p>In this post, we are going to define an algorithm to locate the closest points to a reference point, by using coordinate transformations, k-dimensional trees, and xarray pointwise indexing.</p>

<p>To select closest grid points, we will use here one approach using <a href="http://docs.scipy.org/doc/scipy-0.12.0/reference/generated/scipy.spatial.cKDTree.html" target="_blank">cKDTree</a> class from scipy.spatial package.</p>

<p>Different method are considered here:</p>

<pre><code>- nearest neighbour
- nearest neighbours, weighting with the inverse of distance squared: 
- 
\begin{equation*}
$T_t = \frac{\sum_{i=1}^{m}T_{s,i}w_i}{\sum_{i=1}^{m}w_i}$, $w_i = 1/d_i^2$)
\end{equation*}

- query ball point : Find all pairs of points whose distance is at most one distance
</code></pre>

<h3 id="1-let-s-import-python-librairies">1- Let&rsquo;s import Python librairies</h3>

<pre><code class="language-python">#for Netcdf manipulation
#import netCDF4
#from netCDF4 import Dataset
import xarray as xr

#for array manipulation
import numpy as np
import pandas as pd

#for plotting
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import matplotlib.pylab as plt

#for interpolation
from scipy.spatial import cKDTree
</code></pre>

<h3 id="2-loading-netcdf-files">2- Loading Netcdf files</h3>

<p>We are going to use daily ERA5 reanalysis data from April 1st to 31th of october 2018.</p>

<pre><code class="language-python">unique_dataDIR = 'K:/PROJETS/PROJET_FIRE_INDEX/ERA5_FWI_Netcdf/ERA5_FWI_QC_SNOW_New_2018_from_4_to_8.nc'
TAS = xr.open_dataset(unique_dataDIR)
TAS.lon.shape, TAS.lat.shape,
</code></pre>

<pre><code>((121,), (77,))
</code></pre>

<p>Regrid 1D latitude and longitude to 2D grid.</p>

<pre><code class="language-python">lon2d, lat2d = np.meshgrid(TAS.lon, TAS.lat)
lon2d.shape, lat2d.shape
</code></pre>

<pre><code>((77, 121), (77, 121))
</code></pre>

<p>Let’s have a quick look at our dataset, we will plot one day in our time range:</p>

<pre><code class="language-python">fig = plt.figure(figsize=(12,6))
ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-75,-60,50,52])
ax.coastlines(resolution='110m');
ax.add_feature(cfeature.OCEAN.with_scale('50m'))      
ax.add_feature(cfeature.LAND.with_scale('50m'))       
ax.add_feature(cfeature.LAKES.with_scale('50m'))     
ax.add_feature(cfeature.BORDERS.with_scale('50m'))    
ax.add_feature(cfeature.RIVERS.with_scale('50m'))    
coast = cfeature.NaturalEarthFeature(category='physical', scale='10m',    
                        facecolor='none', name='coastline')
ax.add_feature(coast, edgecolor='black')

states_provinces = cfeature.NaturalEarthFeature(
        category='cultural',
        name='admin_1_states_provinces_lines',
        scale='10m',
        facecolor='none')

ax.add_feature(states_provinces, edgecolor='gray')

cmap0=plt.cm.jet
cmap0.set_under('darkblue') 
cmap0.set_over('darkred') 

mm = ax.contourf(TAS.lon,\
                   TAS.lat,\
                   TAS.sel(time='2018-08-01').FWI,\
                   vmin=0,\
                   vmax=20, \
                   transform=ccrs.PlateCarree(),\
                   levels=np.arange(0, 20, 1.0),\
                   cmap=cmap0 )
ax.scatter(lon2d, lat2d, transform=ccrs.PlateCarree(), s=5)
</code></pre>

<pre><code>&lt;matplotlib.collections.PathCollection at 0xc7d6828&gt;
</code></pre>

<p><img src="output_8_1.png" alt="png" /></p>

<p>The blue dots in the plot identify the grid points.</p>

<p>What we want to achieve is to come up with a way to compare distances between a reference point (defined by latitude and longitude values), and all grid points, and pick the minimum value.</p>

<p>But first, we need to measure distances between two points on our planet, given their geodetic (latitude/longitude/altitude) coordinates.</p>

<p>In this post, we are going to use the cartesian or ECEF (“earth-centered, earth-fixed”) geographic coordinate system, which represents positions (in meters) as X, Y, and Z coordinates, approximating the earth surface as an ellipsoid of revolution (close enough for our purposes).</p>

<p>Once we convert our latitude/longitude coordinates to cartesian coordinates, measuring the distance between two points is as simple as computing the Euclidean distance between them.</p>

<p>The conversion between cartesian and geodetic coordinates latitude, longitude is done according to:</p>

<p><a href="https://www.codecogs.com/eqnedit.php?latex=\begin{bmatrix}&space;X\\&space;Y\\&space;Z&space;\end{bmatrix}&space;=&space;\begin{bmatrix}&space;r.\cos&space;\phi&space;.\cos&space;\lambda&space;\\&space;r.\cos&space;\phi&space;.\sin&space;\lambda&space;\\&space;(1-e^{2}))r.\sin&space;\phi&space;\end{bmatrix}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\begin{bmatrix}&space;X\\&space;Y\\&space;Z&space;\end{bmatrix}&space;=&space;\begin{bmatrix}&space;r.\cos&space;\phi&space;.\cos&space;\lambda&space;\\&space;r.\cos&space;\phi&space;.\sin&space;\lambda&space;\\&space;(1-e^{2}))r.\sin&space;\phi&space;\end{bmatrix}" title="\begin{bmatrix} X\\ Y\\ Z \end{bmatrix} = \begin{bmatrix} r.\cos \phi .\cos \lambda \\ r.\cos \phi .\sin \lambda \\ (1-e^{2}))r.\sin \phi \end{bmatrix}" /></a></p>

<p>Where <a href="https://www.codecogs.com/eqnedit.php?latex=r&space;=&space;\frac{a}{\sqrt{1-e^2&space;sin^2&space;\phi&space;}}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?r&space;=&space;\frac{a}{\sqrt{1-e^2&space;sin^2&space;\phi&space;}}" title="r = \frac{a}{\sqrt{1-e^2 sin^2 \phi }}" /></a>    is the local curvature of the ellipsoid along the first vertical, and where e, the first eccentricity, and a, the semi-major axis, are the parameters defining the ellipsoid.</p>

<ul>
<li>Finding the closest</li>
</ul>

<p>Our problem falls into the class of nearest neighbour searches. A common approach when it comes to finding the nearest neighbour in a number of points with k dimensions is to use a KD-tree, or k-dimensional tree.
SciPy library provides a very efficient KD-tree implementation . Once we have constructed our tree, all we have to do is to populate it with a (n,m) shaped array of points and then query it the nearest neighbor to a reference point.</p>

<p>We will have to make use of some NumPy acrobatics to reshape our data structures from a two-dimensional grid to a one-dimensional array, and to convert the returned one-dimensional index to a set of two indices on our original grid.</p>

<pre><code class="language-python">class KDTreeIndex():    
    &quot;&quot;&quot; A KD-tree implementation for fast point lookup on a 2D grid
    
    Keyword arguments: 
    dataset -- a xarray DataArray containing lat/lon coordinates
               (named 'lat' and 'lon' respectively)               
    &quot;&quot;&quot;    
    def transform_coordinates(self, coords):
        &quot;&quot;&quot; Transform coordinates from geodetic to cartesian
        
        Keyword arguments:
        coords - a set of lan/lon coordinates (e.g. a tuple or 
                 an array of tuples)
        &quot;&quot;&quot;
        # WGS 84 reference coordinate system parameters
        A = 6378.137 # major axis [km]   
        E2 = 6.69437999014e-3 # eccentricity squared    
        
        coords = np.asarray(coords).astype(np.float)
        
        # is coords a tuple? Convert it to an one-element array of tuples
        if coords.ndim == 1:
            coords = np.array([coords])
        
        # convert to radiants
        lat_rad = np.radians(coords[:,0])
        lon_rad = np.radians(coords[:,1]) 
        
        # convert to cartesian coordinates
        r_n = A / (np.sqrt(1 - E2 * (np.sin(lat_rad) ** 2)))
        x = r_n * np.cos(lat_rad) * np.cos(lon_rad)
        y = r_n * np.cos(lat_rad) * np.sin(lon_rad)
        z = r_n * (1 - E2) * np.sin(lat_rad)
        
        return np.column_stack((x, y, z))
    
    def __init__(self, dataset):
        # store original dataset shape
        self.shape = dataset.shape
        lon2d, lat2d = np.meshgrid(dataset.lon, dataset.lat)
        # reshape and stack coordinates
        coords = np.column_stack((lat2d.ravel(),
                                  lon2d.ravel()))
        
        # construct KD-tree
        self.tree = cKDTree(self.transform_coordinates(coords))
        
    def query(self, point, k):
        &quot;&quot;&quot; Query the kd-tree for nearest neighbour.
        Keyword arguments:
        point -- a (lat, lon) tuple or array of tuples
        &quot;&quot;&quot;
        d, inds  = self.tree.query(self.transform_coordinates(point),k=k)
        w = 1.0 / d**2
        # regrid to 2D grid
        indslatlon = np.unravel_index(inds, self.shape)
        return d, inds, w, indslatlon
    
    def query_ball_point(self, point, radius):
        &quot;&quot;&quot; Query the kd-tree for all point within distance 
        radius of point(s) x
        
        Keyword arguments:
        point -- a (lat, lon) tuple or array of tuples
        radius -- the search radius (km)
        &quot;&quot;&quot;
        
        index = self.tree.query_ball_point(self.transform_coordinates(point),
                                           radius)

        # regrid to 2D grid 
        index = np.unravel_index(index[0], self.shape)
        
        # return DataArray indexers
        return xr.DataArray(index[0], dims='lat'), \
               xr.DataArray(index[1], dims='lon')
    
</code></pre>

<p>We will construct our cKDTree object using one time step from our xarray.</p>

<pre><code class="language-python">latlon_tree = KDTreeIndex(TAS.sel(time='2018-08-01').FWI)
</code></pre>

<p>We can now query the tree the nearest grid point to one reference point:</p>

<h3 id="3-nearest-neighbour-k-1">3- Nearest neighbour k=1:</h3>

<p>Let&rsquo;s select reference point defined by:
    - latitude = 50 degN
    - longitude = -68.1461 degE</p>

<p>We can now query the tree the nearest point :</p>

<pre><code class="language-python">site = (50, -68.1461)
d, inds, w, indslatlon = latlon_tree.query(site, k=1)
print(inds)
print(indslatlon)
</code></pre>

<pre><code>[5871]
(array([48], dtype=int64), array([63], dtype=int64))
</code></pre>

<pre><code class="language-python">latpt = indslatlon[0][0]
lonpt = indslatlon[1][0]
print(latpt, lonpt)
</code></pre>

<pre><code>48 63
</code></pre>

<p>The query method actually  returns:
- two array objects a latitude and a longitude indexer
- one 1D indexer
- one distance value
- one corresponding weighting.</p>

<pre><code>*inds value (ie 5871) represents the index found for our one-dimensional array. 

*indslatlon are the corresponding longitude and latitude values for the closest point found.
</code></pre>

<p>To extract the xarray field value using our previous index, first we need to convert a two-dimensional grid to a one-dimensional array and then select index value.</p>

<pre><code class="language-python">TAS.sel(time='2018-08-01').FWI.values.flatten()[inds]
</code></pre>

<pre><code>array([10.517308])
</code></pre>

<pre><code class="language-python">TAS.sel(time='2018-08-01').FWI[latpt,lonpt]
</code></pre>

<pre><code>&lt;xarray.DataArray 'FWI' ()&gt;
array(10.517308)
Coordinates:
    lon      float64 -68.25
    lat      float32 50.0
    time     datetime64[ns] 2018-08-01
</code></pre>

<p>Let&rsquo;s make a quick look:</p>

<pre><code class="language-python">fig = plt.figure(figsize=(25,12))
ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-72,-65,49,51])
   # ax.coastlines(resolution='110m');
ax.add_feature(cfeature.OCEAN.with_scale('50m'))      # couche ocean
ax.add_feature(cfeature.LAND.with_scale('50m'))       # couche land
ax.add_feature(cfeature.LAKES.with_scale('50m'))      # couche lac    
ax.add_feature(cfeature.BORDERS.with_scale('50m'))    # couche frontieres
ax.add_feature(cfeature.RIVERS.with_scale('50m'))     # couche rivières 
coast = cfeature.NaturalEarthFeature(category='physical', scale='10m',     # ajout de la couche cotière 
                        facecolor='none', name='coastline')
ax.add_feature(coast, edgecolor='black')

  
states_provinces = cfeature.NaturalEarthFeature(
        category='cultural',
        name='admin_1_states_provinces_lines',
        scale='10m',
        facecolor='none')

ax.add_feature(states_provinces, edgecolor='gray')

## Choisissons une colormap
cmap0=plt.cm.jet
cmap0.set_under('darkblue') ## on met en blanc les valeurs inferieures au min de clev
cmap0.set_over('darkred') ## bleu fonce pour les valeurs extremes de pluie

mm = ax.contourf(TAS.lon,\
                   TAS.lat,\
                   TAS.sel(time='2018-08-01').FWI,\
                   vmin=0,\
                   vmax=20, \
                   transform=ccrs.PlateCarree(),\
                   levels=np.arange(0, 20, 1.0),\
                   cmap=cmap0 )
ax.scatter(lon2d, lat2d, transform=ccrs.PlateCarree(), s=5, label='ERA5 grid points')
ax.scatter(TAS.sel(time='2018-08-01').FWI[latpt,lonpt].lon, 
           TAS.sel(time='2018-08-01').FWI[latpt,lonpt].lat, 
           color='r', transform=ccrs.PlateCarree(), s=100, label='closest grid point')
ax.scatter(-68.1461, 50, transform=ccrs.PlateCarree(), marker='x', color='black', s=300, label='reference point')
plt.legend(loc='upper left', numpoints=1, ncol=3, fontsize=20)

</code></pre>

<pre><code>&lt;matplotlib.legend.Legend at 0xc7d6358&gt;
</code></pre>

<p><img src="output_22_1.png" alt="png" /></p>

<h3 id="4-nearest-neighbours-k-10">4- Nearest neighbours k=10</h3>

<p>We will now make the same exercice using k=10.</p>

<pre><code class="language-python">site = (50, -68.1461)
d, inds, w, indslatlon = ground_pixel_tree.query(site, k=10)
print(d)
print(w)
print(inds)
print(indslatlon)
</code></pre>

<pre><code>[[ 7.44918778 10.47474677 25.37308687 28.39863145 28.78330094 28.79213291
  29.70566615 29.72368634 37.59953757 37.68733316]]
[[0.01802114 0.00911408 0.00155329 0.00123995 0.00120703 0.00120629
  0.00113324 0.00113187 0.00070735 0.00070406]]
[[5871 5872 5870 5873 5750 5992 5751 5993 5749 5991]]
(array([[48, 48, 48, 48, 47, 49, 47, 49, 47, 49]], dtype=int64), array([[63, 64, 62, 65, 63, 63, 64, 64, 62, 62]], dtype=int64))
</code></pre>

<pre><code class="language-python">TAS.sel(time='2018-08-01').FWI.values.flatten()[inds]
</code></pre>

<pre><code>array([[10.517308  ,  9.87137321,  8.57146189, 11.99096501,  9.32552318,
        10.0954969 ,  9.84150618, 11.8046335 ,  9.26170112,  8.3454113 ]])
</code></pre>

<pre><code class="language-python">latpts = indslatlon[0][0]
lonpts = indslatlon[1][0]
print(latpts, lonpts)
</code></pre>

<pre><code>[48 48 48 48 47 49 47 49 47 49] [63 64 62 65 63 63 64 64 62 62]
</code></pre>

<p>We can know Interpolate our field using inverse distance weighting, using 10 nearest neighbours (k=10):</p>

<p>(i.e. Tt=∑mi=1Ts,iwi∑mi=1wi, wi=1/d2i).</p>

<pre><code class="language-python">np.sum(w * TAS.sel(time='2018-08-01').FWI.values.flatten()[inds], axis=1) / np.sum(w, axis=1)
</code></pre>

<pre><code>array([10.21868978])
</code></pre>

<p>Let&rsquo;s make a quick look:</p>

<pre><code class="language-python">latpts = indslatlon[0][0]
lonpts = indslatlon[1][0]
</code></pre>

<pre><code class="language-python">TAS.sel(time='2018-08-01').FWI[latpts,lonpts].lon
</code></pre>

<pre><code>&lt;xarray.DataArray 'lon' (lon: 10)&gt;
array([-68.25, -68.  , -68.5 , -67.75, -68.25, -68.25, -68.  , -68.  , -68.5 ,
       -68.5 ])
Coordinates:
  * lon      (lon) float64 -68.25 -68.0 -68.5 -67.75 ... -68.0 -68.0 -68.5 -68.5
    time     datetime64[ns] 2018-08-01
</code></pre>

<pre><code class="language-python">fig = plt.figure(figsize=(25,12))
ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-72,-65,49,51])
   # ax.coastlines(resolution='110m');
ax.add_feature(cfeature.OCEAN.with_scale('50m'))      # couche ocean
ax.add_feature(cfeature.LAND.with_scale('50m'))       # couche land
ax.add_feature(cfeature.LAKES.with_scale('50m'))      # couche lac    
ax.add_feature(cfeature.BORDERS.with_scale('50m'))    # couche frontieres
ax.add_feature(cfeature.RIVERS.with_scale('50m'))     # couche rivières 
coast = cfeature.NaturalEarthFeature(category='physical', scale='10m',     # ajout de la couche cotière 
                        facecolor='none', name='coastline')
ax.add_feature(coast, edgecolor='black')

  
states_provinces = cfeature.NaturalEarthFeature(
        category='cultural',
        name='admin_1_states_provinces_lines',
        scale='10m',
        facecolor='none')

ax.add_feature(states_provinces, edgecolor='gray')

## Choisissons une colormap
cmap0=plt.cm.jet
cmap0.set_under('darkblue') ## on met en blanc les valeurs inferieures au min de clev
cmap0.set_over('darkred') ## bleu fonce pour les valeurs extremes de pluie

mm = ax.contourf(TAS.lon,\
                   TAS.lat,\
                   TAS.sel(time='2018-08-01').FWI,\
                   vmin=0,\
                   vmax=20, \
                   transform=ccrs.PlateCarree(),\
                   levels=np.arange(0, 20, 1.0),\
                   cmap=cmap0 )
ax.scatter(lon2d, lat2d, transform=ccrs.PlateCarree(), s=5, label='ERA5 grid points')
ax.scatter(TAS.sel(time='2018-08-01').FWI[latpts,lonpts].lon, 
           TAS.sel(time='2018-08-01').FWI[latpts,lonpts].lat, 
           color='r', transform=ccrs.PlateCarree(), s=100, label='closest grid points')
ax.scatter(-68.1461, 50, transform=ccrs.PlateCarree(), marker='x', color='black', s=300, label='reference point')
plt.legend(loc='upper left', numpoints=1, ncol=3, fontsize=20)
</code></pre>

<pre><code>&lt;matplotlib.legend.Legend at 0xcb78ac8&gt;
</code></pre>

<p><img src="output_32_1.png" alt="png" /></p>

<p>Now we will find all grid points  within a given distance from a reference point, by using the query_ball_point method in SciPy’s KD-tree implementation.</p>

<p>Let’s find out which ground pixels fall into a 700km radius from our reference point:</p>

<pre><code class="language-python">ball_point_index = ground_pixel_tree.query_ball_point(site, 50)
lons = TAS.sel(time='2018-08-01').FWI[ball_point_index].lon
lats = TAS.sel(time='2018-08-01').FWI[ball_point_index].lat
</code></pre>

<pre><code class="language-python">fig = plt.figure(figsize=(25,12))
ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-72,-65,49,51])
   # ax.coastlines(resolution='110m');
ax.add_feature(cfeature.OCEAN.with_scale('50m'))      # couche ocean
ax.add_feature(cfeature.LAND.with_scale('50m'))       # couche land
ax.add_feature(cfeature.LAKES.with_scale('50m'))      # couche lac    
ax.add_feature(cfeature.BORDERS.with_scale('50m'))    # couche frontieres
ax.add_feature(cfeature.RIVERS.with_scale('50m'))     # couche rivières 
coast = cfeature.NaturalEarthFeature(category='physical', scale='10m',     # ajout de la couche cotière 
                        facecolor='none', name='coastline')
ax.add_feature(coast, edgecolor='black')

  
states_provinces = cfeature.NaturalEarthFeature(
        category='cultural',
        name='admin_1_states_provinces_lines',
        scale='10m',
        facecolor='none')

ax.add_feature(states_provinces, edgecolor='gray')

## Choisissons une colormap
cmap0=plt.cm.jet
cmap0.set_under('darkblue') ## on met en blanc les valeurs inferieures au min de clev
cmap0.set_over('darkred') ## bleu fonce pour les valeurs extremes de pluie

mm = ax.contourf(TAS.lon,\
                   TAS.lat,\
                   TAS.sel(time='2018-08-01').FWI,\
                   vmin=0,\
                   vmax=20, \
                   transform=ccrs.PlateCarree(),\
                   levels=np.arange(0, 20, 1.0),\
                   cmap=cmap0 )
ax.scatter(lon2d, lat2d, transform=ccrs.PlateCarree(), s=5, label='ERA5 grid points')
ax.scatter(lons, 
           lats, 
           color='r', transform=ccrs.PlateCarree(), s=100, label='grid points within 50 km from reference point')
ax.scatter(-68.1461, 50, transform=ccrs.PlateCarree(), marker='x', color='black', s=300, label='reference point')
plt.legend(loc='upper left', numpoints=1, ncol=3, fontsize=20)
</code></pre>

<pre><code>&lt;matplotlib.legend.Legend at 0xcb86b38&gt;
</code></pre>

<p><img src="output_35_1.png" alt="png" /></p>

<pre><code class="language-python">
</code></pre>

    </div>

    







<div class="share-box" aria-hidden="true">
  <ul class="share">
    
      
      
      
        
      
      
      
      <li>
        <a href="https://twitter.com/intent/tweet?url=/post/ckdtree_netcdf/&amp;text=Netcdf%20select%20closest%20gridpoints" target="_blank" rel="noopener" class="share-btn-twitter">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.facebook.com/sharer.php?u=/post/ckdtree_netcdf/&amp;t=Netcdf%20select%20closest%20gridpoints" target="_blank" rel="noopener" class="share-btn-facebook">
          <i class="fab fa-facebook"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="mailto:?subject=Netcdf%20select%20closest%20gridpoints&amp;body=/post/ckdtree_netcdf/" target="_blank" rel="noopener" class="share-btn-email">
          <i class="fas fa-envelope"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.linkedin.com/shareArticle?url=/post/ckdtree_netcdf/&amp;title=Netcdf%20select%20closest%20gridpoints" target="_blank" rel="noopener" class="share-btn-linkedin">
          <i class="fab fa-linkedin-in"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://web.whatsapp.com/send?text=Netcdf%20select%20closest%20gridpoints%20/post/ckdtree_netcdf/" target="_blank" rel="noopener" class="share-btn-whatsapp">
          <i class="fab fa-whatsapp"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://service.weibo.com/share/share.php?url=/post/ckdtree_netcdf/&amp;title=Netcdf%20select%20closest%20gridpoints" target="_blank" rel="noopener" class="share-btn-weibo">
          <i class="fab fa-weibo"></i>
        </a>
      </li>
    
  </ul>
</div>












  






  
  
  
    
  
  
  <div class="media author-card content-widget-hr">
    
      
      <img class="portrait mr-3" src="/authors/admin/avatar_hued2496a182fbb6fc8c711157078d29a6_5348924_250x250_fill_q90_lanczos_center.jpg" alt="Avatar">
    

    <div class="media-body">
      <h5 class="card-title"><a href="/">Guillaume Dueymes</a></h5>
      <h6 class="card-subtitle">Data Scientist and Research Assistant</h6>
      <p class="card-text">My research interests include data science, data management and climate science.</p>
      <ul class="network-icon" aria-hidden="true">
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="/#contact" >
        <i class="fas fa-envelope"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://www.researchgate.net/profile/Guillaume_Dueymes" target="_blank" rel="noopener">
        <i class="fab fa-researchgate"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://github.com/guimeto" target="_blank" rel="noopener">
        <i class="fab fa-github"></i>
      </a>
    </li>
  
</ul>

    </div>
  </div>









  
  



  </div>
</article>

      

    
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js" integrity="sha256-1zu+3BnLYV9LdiY85uXMzii3bdrkelyp37e0ZyTAQh0=" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/r.min.js"></script>
        
      

      
      
    

    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.js" integrity="sha256-EErZamuLefUnbMBQbsEqu1USa+btR2oIlCpBJbyD4/g=" crossorigin="anonymous"></script>
    

    
    
    <script>const code_highlighting = true;</script>
    

    
    
    
    
    
    
    <script>
      const search_config = {"indexURI":"/index.json","minLength":1,"threshold":0.3};
      const i18n = {"no_results":"No results found","placeholder":"Search...","results":"results found"};
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.bcfae8267aba63cc55af53a503896bd9.js"></script>

    






  
  
  <div class="container">
    <footer class="site-footer">
  

  <p class="powered-by">
    

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
    <span class="float-right" aria-hidden="true">
      <a href="#" class="back-to-top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

  </div>
  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
