<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts | GDueymes</title>
    <link>/post/</link>
      <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <description>Posts</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Fri, 24 Apr 2020 12:03:32 -0700</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>Posts</title>
      <link>/post/</link>
    </image>
    
    <item>
      <title>Spearman correlation between two Netcdf datasets</title>
      <link>/post/spearman/</link>
      <pubDate>Fri, 24 Apr 2020 12:03:32 -0700</pubDate>
      <guid>/post/spearman/</guid>
      <description>

&lt;h2 id=&#34;netcdf-interpolation-between-grids-using-ckdtree-from-scipy-library-and-correlation&#34;&gt;Netcdf: Interpolation between grids using cKDTree from Scipy library and correlation&lt;/h2&gt;

&lt;p&gt;In this post, we will interpolate a nectcdf file to another netcdf grid and then calculate timeseries spearman correlation between two datasets on same resolution grid.&lt;/p&gt;

&lt;p&gt;To interpolate, we will follow this &lt;a href=&#34;https://www.guillaumedueymes.com/post/netcdf_interpolation/&#34; target=&#34;_blank&#34;&gt;post&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In this example, we will interpolate &lt;a href=&#34;https://daymet.ornl.gov/&#34; target=&#34;_blank&#34;&gt;Daymet-1km dataset&lt;/a&gt; on &lt;a href=&#34;https://www.ecmwf.int/en/forecasts/datasets/reanalysis-datasets/era5&#34; target=&#34;_blank&#34;&gt;ERA5-grid&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We will compute monthly total precipipitation and then compare the two datasets using spearman correlation.&lt;/p&gt;

&lt;p&gt;The Daymet dataset provides gridded estimates of daily weather parameters. Seven surface weather parameters are available at a daily time step, 1 km x 1 km spatial resolution, with a North American spatial extent.&lt;/p&gt;

&lt;p&gt;ERA5 Reanalyses provide a numerical description, with horizontal resolution of 31 km, of the recent climate (1979-present) by combining models with observations.&lt;/p&gt;

&lt;h3 id=&#34;1-let-s-import-python-librairies&#34;&gt;1-  Let&amp;rsquo;s import Python librairies&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import warnings; warnings.filterwarnings(action=&#39;ignore&#39;)
%matplotlib inline
#for Netcdf manipulation
import xarray as xr
from netCDF4 import Dataset
import netCDF4 as nc

#for array manipulation
import numpy as np
import pandas as pd

#for plotting
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import matplotlib.pylab as plt

#for interpolation
from scipy.spatial import cKDTree
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;we-will-only-work-over-july-month-from-1980-to-2019&#34;&gt;We will only work over july month from 1980 to 2019:&lt;/h4&gt;

&lt;h3 id=&#34;2-interpolation-daymet-1km-to-daymet-32km-era5-grid&#34;&gt;2 - Interpolation : Daymet-1km to Daymet-32km (ERA5 grid)&lt;/h3&gt;

&lt;p&gt;We are going to use daily precipitation of Daymet-1km for july. In this analysis, we will use a subset of Daymet-1km and ERA5-32km. Indeed, we will only work over a specific watershed in Canada: Outaouais river&amp;rsquo;s watershed:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;attachment:image.png&#34; alt=&#34;watershed.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the script to interpolate:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;path_source = &#39;K:/PROJETS/PROJET_OUTAOUAIS/Daily/prcp/&#39; # path with daily precipitation
import gc
gc.collect()

variable = &#39;Prcp&#39;
yi = 1980
yf = 2019

# Load target grid to interpolate
target = xr.open_dataset(&#39;Outaouais_ERA5_Grid.nc&#39;)
lat_target=target.latitude
lon_target=target.longitude
lat_target.shape

lon_target2d, lat_target2d = np.meshgrid(lon_target, lat_target)

# Load source file to create cKDTree 
source = xr.open_dataset(path_source + &#39;Daymet_v3_prcp_1980_OUTAOUAIS.nc&#39;)
lat_source = source.variables[&#39;lat&#39;][:]
lon_source = source.variables[&#39;lon&#39;][:]

# function to convert latlon to xy coordinate system
def lon_lat_to_cartesian(lon, lat):
    # WGS 84 reference coordinate system parameters
    A = 6378.137 # major axis [km]   
    E2 = 6.69437999014e-3 # eccentricity squared 
    
    lon_rad = np.radians(lon)
    lat_rad = np.radians(lat)
    # convert to cartesian coordinates
    r_n = A / (np.sqrt(1 - E2 * (np.sin(lat_rad) ** 2)))
    x = r_n * np.cos(lat_rad) * np.cos(lon_rad)
    y = r_n * np.cos(lat_rad) * np.sin(lon_rad)
    z = r_n * (1 - E2) * np.sin(lat_rad)
    return x,y,z

xs, ys, zs = lon_lat_to_cartesian(lon_source.values.flatten(), lat_source.values.flatten())
xt, yt, zt = lon_lat_to_cartesian(lon_target2d.flatten(), lat_target2d.flatten())

tree = cKDTree(np.column_stack((xs, ys, zs)))

d, inds = tree.query(np.column_stack((xt, yt, zt)), k = 10)

# let&#39;s define a function to interpolate 
def interpolate(source, target, d, inds):    
    nt = source[&amp;quot;time&amp;quot;].shape[0]
    tmp = []
    for t in range(0, nt):        
        w = 1.0 / d**2
        air_idw = np.sum(w * source.prcp[t].values.flatten()[inds], axis=1) / np.sum(w, axis=1)
        air_idw.shape = target.shape
        tmp.append(air_idw)
    return tmp

# we will make a loop over years and save netcdf files by month
for year in range(yi,yf+1):
    source = xr.open_dataset(path_source + &#39;Daymet_v3_prcp_&#39;+str(year)+&#39;_OUTAOUAIS.nc&#39;)
    air_idw = interpolate(source,lon_target2d, d, inds)
    
    data_set = xr.Dataset( coords={&#39;lon&#39;: ([ &#39;lon&#39;], lon_target),
                                     &#39;lat&#39;: ([&#39;lat&#39;,], lat_target),
                                     &#39;time&#39;: source.time.values})
    data_set[&amp;quot;prcp&amp;quot;] = ([&#39;time&#39;,&#39;lat&#39;, &#39;lon&#39;],  air_idw)
    [data_set.sel(time=str(year)+&#39;-&#39;+&#39;{:02d}&#39;.format(i)).to_netcdf(path_source + &#39;Daymet_v3_&#39; + variable + &#39;_&#39;+str(year)+&#39;_&#39;+&#39;{:02d}&#39;.format(i)+&#39;_OUTAOUAIS_ERA5grid.nc&#39;) for i in range(1,13)]
    

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-compute-monthly-indices&#34;&gt;3 - Compute monthly indices&lt;/h3&gt;

&lt;p&gt;We can now open daily files to compute monthly indices.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;yi = 1990
yf = 2019
#########################################################
tmin_in = &#39;./Daily/prcp/&#39;
monthly_out = &#39;./Month_Indice/&#39; 

# Compute monthly indices
for year in range(yi,yf+1):   # loop over years  
    for i in range(7,8):      # we just want to work over july (i_month = 7)
        data_pcp = tmin_in + &#39;Daymet_v3_Prcp_&#39; + str(year) +&#39;_{:02d}&#39;.format(i) +&#39;_OUTAOUAIS_ERA5grid.nc&#39;
        ds_pcp = xr.open_mfdataset(data_pcp)         
        monthly_pcp = ds_pcp.sum(&#39;time&#39;)     # sum over days to calculate monthly accumulation
        # we can save our netcdf files
        monthly_pcp.to_netcdf(monthly_out + &#39;Daymet_v3_Monthly_PrecTOT_&#39;+str(year) +&#39;{:02d}&#39;.format(i)+&#39;_OUTAOUAIS_ERA5grid.nc&#39;,  format=&#39;NETCDF4&#39;)
            
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-apply-watershed-netcdf-mask&#34;&gt;4 - Apply watershed netcdf mask&lt;/h3&gt;

&lt;p&gt;We will mask a specific area using a netcdf file. To create a netcdf file using any shapefile, please follow this &lt;a href=&#34;https://www.guillaumedueymes.com/post/shapefile_netcdf/&#34; target=&#34;_blank&#34;&gt;post&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# this function will be use later to create a netcdf file using source attributs
def create_file_from_source(src_file, trg_file):
    src = nc.Dataset(src_file)
    trg = nc.Dataset(trg_file, mode=&#39;w&#39;)

    # Create the dimensions of the file
    for name, dim in src.dimensions.items():
        trg.createDimension(name, len(dim) if not dim.isunlimited() else None)

    # Copy the global attributes
   # trg.setncatts({a:src.getncattr(a) for a in src.ncattrs()})

    # Create the variables in the file
    for name, var in src.variables.items():
        trg.createVariable(name, var.dtype, var.dimensions)

        # Copy the variable attributes
        trg.variables[name].setncatts({a:var.getncattr(a) for a in var.ncattrs()})

        # Copy the variables values (as &#39;f4&#39; eventually)
        if name not in tomask:
            trg.variables[name][:] = src.variables[name][:]
            
        else:    
            trg.variables[name][:] = data

    # Save the file
    trg.close()

#create 2d grid mask http://meteo.unican.es/work/xarray_seminar/xArray_seminar.html
tomask = [&#39;prcp&#39;]

m_f=xr.open_dataset(&#39;Outaouais_ERA5_Grid.nc&#39;)
lat2d=m_f.variables[&#39;latitude&#39;][:]
lon2d=m_f.variables[&#39;longitude&#39;][:]
mask = m_f[&#39;tp&#39;].values

for year in range(1990,2020):
    for month in range(7,8):
        
        infile = &#39;./Month_Indice/Daymet_v3_Monthly_PrecTOT_&#39;+str(year) +&#39;{:02d}&#39;.format(int(month))+&#39;_OUTAOUAIS_ERA5grid.nc&#39;           
        outfile = &#39;./Month_Indice/Daymet_v3_Monthly_PrecTOT_&#39;+str(year)+&amp;quot;{:02d}&amp;quot;.format(month)+&#39;_OUTAOUAIS_ERA5grid_BV.nc&#39;
       
        nc_Modc=xr.open_dataset(infile)
        nc_Modc.lon.values
        nc_Modf=Dataset(infile,&#39;r&#39;)
        data = nc_Modc[&#39;prcp&#39;].where(mask &amp;gt;= 0)
        create_file_from_source(infile, outfile)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-compute-correlation&#34;&gt;5 - Compute correlation&lt;/h3&gt;

&lt;p&gt;To compute spearman correlation, we use stats module from &lt;a href=&#34;https://docs.scipy.org/doc/scipy-0.18.1/reference/generated/scipy.stats.mstats.spearmanr.html/&#34; target=&#34;_blank&#34;&gt;scipy library&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from scipy import stats
import numpy as np

variable = &#39;Monthly_PrecTOT&#39;
yi = 1990
yf = 2020
out = &#39;./Month_Indice/&#39;
for month in [&#39;07&#39;]:  
    # load ERA5 
    path_era5 = &#39;J:/REANALYSES/ERA5/Month_PrecTOT_Outaouais/&#39;
    file = path_era5 + &#39;ERA5_Outaouais_Monthly_PrecTOT_CAN_&#39;
    multi_file = [f&#39;{file}{year}{month}_BV.nc&#39; for year in range(yi,yf,1)]
    era5_all = xr.concat([xr.open_dataset(f) for f in multi_file], &#39;day&#39;)
    
    # load daymet
    path_daymet = &#39;K:/PROJETS/PROJET_OUTAOUAIS/Month_Indice/&#39;
    
    file = path_daymet + &#39;Daymet_v3_&#39;+variable + &#39;_&#39;
    multi_file = [f&#39;{file}{year}{month}_OUTAOUAIS_ERA5grid_BV.nc&#39; for year in range(yi,yf,1)]
    daymet_all = xr.concat([xr.open_dataset(f) for f in multi_file], &#39;time&#39;)
    
    # Spearman correlation between two datasets for each grid point
    corr_spearman_ERA5 = np.zeros((era5_all[&#39;tp&#39;].shape[1],era5_all[&#39;tp&#39;].shape[2]),dtype=float)    
    for ni in range(0,era5_all[&#39;tp&#39;].shape[2]):   # loop over longitudes
        for nj in range(0, era5_all[&#39;tp&#39;].shape[1]):  # loop over latitudes
            
             r, p = stats.spearmanr(era5_all.isel(latitude=[nj], longitude=[ni]).tp.values[:,0,0] ,
                                   daymet_all.isel(lat=[nj], lon=[ni]).prcp.values[:,0,0] ) 
             if p &amp;gt;= 0.1 :
                 corr_spearman_ERA5[nj,ni] = np.nan
             else:
                 corr_spearman_ERA5[nj,ni] = r
                 
    data_set = xr.Dataset( coords={&#39;lon&#39;: ([ &#39;lon&#39;], era5_all.longitude),
                                             &#39;lat&#39;: ([&#39;lat&#39;,], era5_all.latitude)})
    
    data_set[&amp;quot;spearmanr&amp;quot;] = ([&#39;lat&#39;, &#39;lon&#39;],  corr_spearman_ERA5)
        
    data_set.to_netcdf(out + &#39;Daymet_v3_spearmann_Correlation_ERA5grid&#39; + variable + &#39;_&#39;+str(yi)+&#39;_&#39;+str(yf)+&#39;_&#39;+month+&#39;_OUTAOUAIS_python.nc&#39;)             
             
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-plot-correlation&#34;&gt;6 - Plot correlation&lt;/h3&gt;

&lt;p&gt;We can now make a quick plot using matplotlib.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from netCDF4 import Dataset
import matplotlib.pylab as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import numpy as np
import matplotlib as mpl
import pandas as pd
import datetime
####https://uoftcoders.github.io/studyGroup/lessons/python/cartography/lesson/

## Date à utiliser 

path_in=&#39;./Month_Indice/&#39;
file = &#39;Daymet_v3_spearmann_Correlation_ERA5gridMonthly_PrecTOT&#39;
yi = 1990
yf = 2020
# lecture du contour du bassin versant 
BV_border = pd.read_csv(&#39;./points_contour_BV.csv&#39;, sep=&#39;,&#39;)
def plot_background(ax):
    ax.set_extent([-84,-70,45,48])
    ax.coastlines(resolution=&#39;110m&#39;);
    ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))      
    ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))       
    ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))     
    ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))    
    ax.add_feature(cfeature.RIVERS.with_scale(&#39;50m&#39;))    
    coast = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, scale=&#39;10m&#39;,    
                        facecolor=&#39;none&#39;, name=&#39;coastline&#39;)
    ax.add_feature(coast, edgecolor=&#39;black&#39;)
    
    states_provinces = cfeature.NaturalEarthFeature(
        category=&#39;cultural&#39;,
        name=&#39;admin_1_states_provinces_lines&#39;,
        scale=&#39;10m&#39;,
        facecolor=&#39;none&#39;)

    ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;)

   
    return ax

for month in [&#39;07&#39;]:
        
    monthstr = datetime.date(1900, int(month), 1).strftime(&#39;%B&#39;)   
    filename = path_in + file
    
    dset=Dataset(filename + &#39;_&#39; + str(yi) + &#39;_&#39; + str(yf) + &#39;_&#39; + month +&#39;_OUTAOUAIS_python.nc&#39;)
    ## Lecture du fichier 
    var=dset.variables[&#39;spearmanr&#39;][:].squeeze()
    lon=dset.variables[&#39;lon&#39;][:]
    lat=dset.variables[&#39;lat&#39;][:]

    
    fig = plt.figure(figsize=(28,16))
    crs=ccrs.LambertConformal()
    ax = plt.axes(projection=crs)
    plot_background(ax)
    
    ## Choisissons une colormap
    cmap0 = mpl.cm.get_cmap(&#39;jet&#39;, 11)
    #cmap0.set_under(&#39;w&#39;) ## on met en blanc les valeurs inferieures au min de clev
    #cmap0.set_over(&#39;black&#39;)
    levels = np.arange(0,1.1,0.1) 
    mm = ax.contourf(lon,\
                           lat,\
                           var,\
                           vmin=0.,\
                           vmax=1.1, \
                           transform=ccrs.PlateCarree(),\
                           cmap=cmap0,
                           levels=levels)
        
    # ajout du contour du basson versant 
    colors = [&#39;red&#39;]
    maskBV = [&#39;Outaouais Watershed&#39;]                      
    ax.plot(BV_border.X,BV_border.Y, transform=ccrs.PlateCarree(), color=colors[0], linewidth=2, label=maskBV[0])
    plt.legend(loc=&amp;quot;best&amp;quot;, markerscale=2., fontsize=20)
    xticks = np.arange(-150.0,-40.0,20)
    yticks =np.arange(10,80,10)    
    fig.canvas.draw()    

    cbar = plt.colorbar(mm, orientation=&#39;horizontal&#39;, shrink=0.75, drawedges=&#39;True&#39;, ticks=np.arange(0., 1.1, .1),extend=&#39;both&#39;)
    cbar.set_label(u&#39;\n DAYMET/ERA Correlation - Résolution: 32km&#39;, size=&#39;medium&#39;) # Affichage de la légende de la barre de couleur
    cbar.ax.tick_params(labelsize=17)  
    
    string_title=u&#39;Spearman Correlation Monthly total precipitation Daymet/ERA5 \n &#39; + monthstr + &#39; reference period 1990-2019\n&#39;
    plt.title(string_title, size=&#39;xx-large&#39;)
    plt.savefig(path_in + &#39;Spearman_DAYMET_ERA5_PrecTOT_1990-2019_&#39;+str(month)+&#39;_python.png&#39;, bbox_inches=&#39;tight&#39;, pad_inches=0.1)
    plt.show()  
    plt.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_13_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Netcdf Interpolation using Python</title>
      <link>/post/netcdf_interpolation/</link>
      <pubDate>Wed, 08 Apr 2020 06:48:49 -0700</pubDate>
      <guid>/post/netcdf_interpolation/</guid>
      <description>

&lt;h2 id=&#34;netcdf-interpolation-between-grids-using-ckdtree-from-scipy-library&#34;&gt;Netcdf: Interpolation between grids using cKDTree from Scipy library&lt;/h2&gt;

&lt;p&gt;In this post, we are going to define an algorithm to locate the closest points to a reference points, by using coordinate transformations, k-dimensional trees, and xarray pointwise indexing.&lt;/p&gt;

&lt;p&gt;To select closest grid points, we will use here one approach using &lt;a href=&#34;http://docs.scipy.org/doc/scipy-0.12.0/reference/generated/scipy.spatial.cKDTree.html&#34; target=&#34;_blank&#34;&gt;cKDTree&lt;/a&gt; class from scipy.spatial package.&lt;/p&gt;

&lt;p&gt;Different method are considered here:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- nearest neighbour
- nearest neighbours, weighting with the inverse of distance squared: 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$T&lt;em&gt;t = \frac{\sum&lt;/em&gt;{i=1}^{m}T_{s,i}w&lt;em&gt;i}{\sum&lt;/em&gt;{i=1}^{m}w_i}$, $w_i = 1/d_i^2$).&lt;/p&gt;

&lt;p&gt;In this example, we will interpolate &lt;a href=&#34;https://daymet.ornl.gov/&#34; target=&#34;_blank&#34;&gt;Daymet-1km dataset&lt;/a&gt; on &lt;a href=&#34;https://www.ecmwf.int/en/forecasts/datasets/reanalysis-datasets/era5&#34; target=&#34;_blank&#34;&gt;ERA5-grid&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The Daymet dataset provides gridded estimates of daily weather parameters. Seven surface weather parameters are available at a daily time step, 1 km x 1 km spatial resolution, with a North American spatial extent.&lt;/p&gt;

&lt;p&gt;ERA5 Reanalyses provide a numerical description, with horizontal resolution of 31 km, of the recent climate (1979-present) by combining models with observations.&lt;/p&gt;

&lt;h2 id=&#34;1-let-s-import-python-librairies&#34;&gt;1-  Let&amp;rsquo;s import Python librairies&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import warnings; warnings.filterwarnings(action=&#39;ignore&#39;)
%matplotlib inline
#for Netcdf manipulation
import xarray as xr

#for array manipulation
import numpy as np
import pandas as pd

#for plotting
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import matplotlib.pylab as plt

#for interpolation
from scipy.spatial import cKDTree
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-loading-source-file&#34;&gt;2 - Loading source file&lt;/h2&gt;

&lt;p&gt;We are going to use daily maximum temperature of Daymet-1km for january 2017. In this analysis, we will use a subset of Daymet-1km and ERA5-32km. Indeed, we will only work over a specific watershed in Canada: Outaouais river&amp;rsquo;s watershed:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;watershed.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;source = xr.open_dataset(&#39;DAYMET_1km_subset_BV_tmax_2017_01.nc4&#39;)
lat_source = source.variables[&#39;lat&#39;][:]
lon_source = source.variables[&#39;lon&#39;][:]
lat_source.shape
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(678, 702)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-loading-target-file&#34;&gt;3- Loading target file&lt;/h2&gt;

&lt;p&gt;We want to interpolate our source file on ERA5-grid. Let&amp;rsquo;s load ERA5 reanalysis as target grid.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;target = xr.open_dataset(&#39;ERA5_Outaouais_daily_tmax_201701.nc&#39;)
lat_target=target.latitude
lon_target=target.longitude
lat_target.shape
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(29,)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ERA5 latitude and longitude are 1D array dimension.  We must convert these 1-dimensional arrays into  2-dimensional arrays.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lon_target2d, lat_target2d = np.meshgrid(lon_target, lat_target)
lon_target2d.shape
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(29, 121)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This next function will be use for converting lat/lon to cartesian coordinates (x, y, z):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def lon_lat_to_cartesian(lon, lat):
    # WGS 84 reference coordinate system parameters
    A = 6378.137 # major axis [km]   
    E2 = 6.69437999014e-3 # eccentricity squared 
    
    lon_rad = np.radians(lon)
    lat_rad = np.radians(lat)
    # convert to cartesian coordinates
    r_n = A / (np.sqrt(1 - E2 * (np.sin(lat_rad) ** 2)))
    x = r_n * np.cos(lat_rad) * np.cos(lon_rad)
    y = r_n * np.cos(lat_rad) * np.sin(lon_rad)
    z = r_n * (1 - E2) * np.sin(lat_rad)
    return x,y,z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now all necessary inputs are read in memory, we can now convert lat/lon to the Cartesian coordinate reference system (CRS):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;xs, ys, zs = lon_lat_to_cartesian(lon_source.values.flatten(), lat_source.values.flatten())
xt, yt, zt = lon_lat_to_cartesian(lon_target2d.flatten(), lat_target2d.flatten())
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-step1-construct-the-ckdtree-object&#34;&gt;4- Step1:  construct the cKDTree object&lt;/h2&gt;

&lt;p&gt;We can then create a KD-tree with the set of points within which we want to search for a closest point in our source grid.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tree = cKDTree(np.column_stack((xs, ys, zs)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-step2-interpolation-on-target-grid&#34;&gt;5- Step2: Interpolation on target grid&lt;/h2&gt;

&lt;p&gt;The second step provides a query point and returns the closest point or points in the KD-tree to the query point, where how &amp;ldquo;closest&amp;rdquo; is defined can be varied.&lt;/p&gt;

&lt;p&gt;Here, we use 3D points on spherical Earth with unit radius.&lt;/p&gt;

&lt;p&gt;Two methods of interpolation are considered here: nearest neighbour and weighting with the inverse of distance squared.&lt;/p&gt;

&lt;h3 id=&#34;a-nearest-neighbour-interpolation&#34;&gt;a- Nearest neighbour interpolation&lt;/h3&gt;

&lt;p&gt;In this step, we find indices of the nearest neighbors in the flattened array using our &amp;lsquo;tree&amp;rsquo; from step1.  To do this, we will apply
&lt;a href=&#34;https://docs.scipy.org/doc/scipy-0.12.0/reference/generated/scipy.spatial.cKDTree.query.html#scipy.spatial.cKDTree.query&#34; target=&#34;_blank&#34;&gt;cKDTree.query method&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#find indices of the nearest neighbors in the flattened array
#d, inds = tree.query(zip(xt, yt, zt), k = 1)
d, inds = tree.query(np.column_stack((xt, yt, zt)), k = 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now interpolate our 2d field using our index tree. We will interpolate our first timestep for daymet source file (ie datetime64[ns] 2017-01-01T12:00:00)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#get interpolated 2d field
air_nearest = source.tmax[0].values.flatten()[inds].reshape(lon_target2d.shape)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;b-interpolation-using-inverse-distance-weighting-using-10-nearest-neighbours-k-10&#34;&gt;b- Interpolation using inverse distance weighting, using 10 nearest neighbours (k=10):&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;d, inds = tree.query(np.column_stack((xt, yt, zt)), k = 10)
w = 1.0 / d**2
air_idw = np.sum(w * source.tmax[0].values.flatten()[inds], axis=1) / np.sum(w, axis=1)
air_idw.shape = lon_target2d.shape
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-plot-the-results&#34;&gt;6- Plot the results:&lt;/h2&gt;

&lt;p&gt;Now let us plot the results from these two approaches. For ERA5-target grid, we will apply a mask to visualize the same watershed.
This mask was created using a shapefile.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;MASK = xr.open_dataset(&#39;Outaouais_ERA5_Grid.nc&#39;)
lat1d=MASK.variables[&#39;latitude&#39;][:]
lon1d=MASK.variables[&#39;longitude&#39;][:]
lon2d, lat2d = np.meshgrid(lon1d, lat1d)
mask = MASK[&#39;tp&#39;][ :, :]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(28,20))

subplot(221)
plt.pcolormesh(source.tmax[0,:,:].values.transpose())
plt.xlim([0, source.tmax[0,:,:].shape[0]])
plt.ylim([0, source.tmax[0,:,:].shape[1]])
plt.colorbar()
plt.title(&amp;quot;Daymet grid&amp;quot;, size=&#39;xx-large&#39;)

subplot(222)
plt.pcolormesh(target.t2m[0,:,:].where(mask.values&amp;gt;=0).values.transpose())
plt.xlim([0, target.t2m[0,:,:].shape[0]])
plt.ylim([0, target.t2m[0,:,:].shape[1]])
plt.colorbar()
plt.title(&amp;quot;ERA5 grid&amp;quot;, size=&#39;xx-large&#39;)

subplot(223)
plt.pcolormesh(air_nearest.transpose())
plt.xlim([0, air_nearest.shape[0]])
plt.ylim([0, air_nearest.shape[1]])
plt.colorbar()
plt.title(&amp;quot;Daymet on ERA5 grid Nearest neighbor&amp;quot;, size=&#39;xx-large&#39;)

subplot(224)
plt.pcolormesh(air_idw.transpose())
plt.colorbar()
plt.xlim([0, air_idw.shape[0]])
plt.ylim([0, air_idw.shape[1]])
plt.title(&amp;quot;Daymet on  ERA5 grid IDW of square distance \n using 10 neighbors&amp;quot;, size=&#39;xx-large&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_26_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This was a quick plot, let&amp;rsquo;s make better plots using Cartopy library.&lt;/p&gt;

&lt;p&gt;We first define a function to create the map subplots:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def plot_background(ax):
    ax.set_extent([-82,-73,45,49])
    ax.coastlines(resolution=&#39;110m&#39;);
    ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))      
    ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))       
    ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))     
    ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))    
    ax.add_feature(cfeature.RIVERS.with_scale(&#39;50m&#39;))    
    coast = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, scale=&#39;10m&#39;,    
                        facecolor=&#39;none&#39;, name=&#39;coastline&#39;)
    ax.add_feature(coast, edgecolor=&#39;black&#39;)
    
    states_provinces = cfeature.NaturalEarthFeature(
        category=&#39;cultural&#39;,
        name=&#39;admin_1_states_provinces_lines&#39;,
        scale=&#39;10m&#39;,
        facecolor=&#39;none&#39;)

    ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;)

   
    return ax
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will plot the two different interpolations (a) and (b):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(28,12))
from matplotlib.gridspec import GridSpec
cmap0=plt.cm.jet
cmap0.set_under(&#39;darkblue&#39;) 
cmap0.set_over(&#39;darkred&#39;)

gs = GridSpec(1,3, width_ratios=[1,1, 0.05], wspace = 0.05)
crs=ccrs.LambertConformal()
# Left plot - ERA5 grid Nearest neighbor
ax1 = plt.subplot(gs[0, 0], projection=crs)
plot_background(ax1)
ax1.contourf(lon_target2d,\
                   lat_target2d,\
                   air_nearest,\
                   vmin=-15,\
                   vmax=5, \
                   transform=ccrs.PlateCarree(),\
                   levels=np.arange(-15, 5, 1.0),\
                   cmap=cmap0 )
ax1.contour(lon_target2d, lat_target2d, air_nearest, 
                          levels = np.arange(-15, 5, 1.0), 
                          linewidths=2, 
                          colors=&#39;k&#39;,
                          transform = ccrs.PlateCarree())
ax1.scatter(lon_target2d, lat_target2d, transform=ccrs.PlateCarree(), s=0.5)
string_title=u&#39;Daymet on ERA5 grid Nearest neighbor: 2017-01-01&#39;
plt.title(string_title, size=&#39;xx-large&#39;)

# Right plot - ERA5 grid IDW of square distance 
ax2 = plt.subplot(gs[0, 1], projection=crs)

plot_background(ax2)
mm = ax2.contourf(lon_target2d,\
                   lat_target2d,\
                   air_idw,\
                   vmin=-15,\
                   vmax=5, \
                   transform=ccrs.PlateCarree(),\
                   levels=np.arange(-15, 5, 1.0),\
                   cmap=cmap0 )
ax2.contour(lon_target2d, lat_target2d, air_idw, 
                          levels = np.arange(-15, 5, 1.0), 
                          linewidths=2, 
                          colors=&#39;k&#39;,
                          transform = ccrs.PlateCarree())

ax2.scatter(lon_target2d, lat_target2d, transform=ccrs.PlateCarree(), s=0.5)
string_title=u&#39;Daymet on  ERA5 grid IDW of square distance \n using 10 neighbors: 2017-01-01 &#39;
plt.title(string_title, size=&#39;xx-large&#39;)
ax = fig.add_subplot(gs[0,2])
plt.colorbar(mm,  shrink=0.75, drawedges=&#39;True&#39;, ticks=np.arange(-15, 5.1, 1.), extend=&#39;both&#39;, cax = ax)
cbar.ax.tick_params(labelsize=20) 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_30_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We plot Daymet-1km and ERA5 datasets for the same date: 2017-01-01&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(28,12))
from matplotlib.gridspec import GridSpec
cmap0=plt.cm.jet
cmap0.set_under(&#39;darkblue&#39;) 
cmap0.set_over(&#39;darkred&#39;)

gs = GridSpec(1,3, width_ratios=[1,1, 0.05], wspace = 0.05)
crs=ccrs.LambertConformal()
# Left plot: Daymet: source grid
ax1 = plt.subplot(gs[0, 0], projection=crs)
plot_background(ax1)
ax1.contourf(lon_s,\
                   lat_s,\
                   source.tmax[0,:,:],\
                   vmin=-15,\
                   vmax=5, \
                   transform=ccrs.PlateCarree(),\
                   levels=np.arange(-15, 5, 1.0),\
                   cmap=cmap0 )
ax1.contour(lon_s, lat_s, source.tmax[0,:,:], 
                          levels = np.arange(-15, 5, 1.0), 
                          linewidths=2, 
                          colors=&#39;k&#39;,
                          transform = ccrs.PlateCarree())
string_title=u&#39;Daymet 1km: Tmax: 2017-01-01&#39;
plt.title(string_title, size=&#39;xx-large&#39;)

# Right plot: ERA5: target grid
ax2 = plt.subplot(gs[0, 1], projection=crs)

plot_background(ax2)
mm = ax2.contourf(lon_target2d,\
                   lat_target2d,\
                   target.t2m[0,:,:].where(mask.values&amp;gt;=0),\
                   vmin=-15,\
                   vmax=5, \
                   transform=ccrs.PlateCarree(),\
                   levels=np.arange(-15, 5, 1.0),\
                   cmap=cmap0 )
ax2.contour(lon_target2d, lat_target2d, target.t2m[0,:,:].where(mask.values&amp;gt;=0), 
                          levels = np.arange(-15, 5, 1.0), 
                          linewidths=2, 
                          colors=&#39;k&#39;,
                          transform = ccrs.PlateCarree())
string_title=u&#39;ERA5 grid: Tmax: 2017-01-01&#39;
plt.title(string_title, size=&#39;xx-large&#39;)
ax = fig.add_subplot(gs[0,2])
plt.colorbar(mm,  shrink=0.75, drawedges=&#39;True&#39;, ticks=np.arange(-15, 5.1, 1.), extend=&#39;both&#39;, cax = ax)
cbar.ax.tick_params(labelsize=50) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_32_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;7-saving-netcdf-files-with-every-daily-timesteps&#34;&gt;7- Saving Netcdf files with every daily timesteps:&lt;/h2&gt;

&lt;p&gt;We can work and interpolate for one timestep (ie 2017-01-01). We can now create a function to interpolate every timesteps of our source grid on target grid and then save the result array into netcdf file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;d, inds = tree.query(np.column_stack((xt, yt, zt)), k = 10)
w = 1.0 / d**2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def interpolate(source, target, d, inds):    
    nt = source[&amp;quot;time&amp;quot;].shape[0]
    tmp = []
    for t in range(0, nt):        
        result = np.zeros(target.shape)
        w = 1.0 / d**2
        air_idw = np.sum(w * source.tmax[t].values.flatten()[inds], axis=1) / np.sum(w, axis=1)
        air_idw.shape = target.shape
        tmp.append(air_idw)
    return tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;source = xr.open_dataset(&#39;DAYMET_1km_subset_BV_tmax_2017_01.nc4&#39;)
target = xr.open_dataset(&#39;ERA5_Outaouais_daily_tmax_201701.nc&#39;)
lon_target=target.longitude
lat_target=target.latitude
lon_target2d, lat_target2d = np.meshgrid(lon_target, lat_target)

air_idw = interpolate(source,lon_target2d, d, inds)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now save our numpy array to xarray and then into netcdf file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data_set = xr.Dataset( coords={&#39;lon&#39;: ([ &#39;lon&#39;], lon_target),
                                     &#39;lat&#39;: ([&#39;lat&#39;,], lat_target),
                                     &#39;time&#39;: source.time.values})
data_set[&amp;quot;tasmax&amp;quot;] = ([&#39;time&#39;,&#39;lat&#39;, &#39;lon&#39;],  air_idw)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data_set.to_netcdf(&#39;DAYMET_32km_subset_BV_tmax_2017_01.nc&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data_set
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:  (lat: 29, lon: 121, time: 31)
Coordinates:
  * lon      (lon) float32 270.0 270.25 270.5 270.75 ... 299.5 299.75 300.0
  * lat      (lat) float32 50.0 49.75 49.5 49.25 49.0 ... 43.75 43.5 43.25 43.0
  * time     (time) datetime64[ns] 2017-01-01T12:00:00 ... 2017-01-31T12:00:00
Data variables:
    tasmax   (time, lat, lon) float64 nan nan nan nan nan ... nan nan nan nan&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Working with ERA5 reanalysis</title>
      <link>/post/era5_analyse/</link>
      <pubDate>Sun, 05 Apr 2020 12:49:01 -0700</pubDate>
      <guid>/post/era5_analyse/</guid>
      <description>

&lt;p&gt;﻿&lt;/p&gt;

&lt;h3 id=&#34;exemples-using-era5-reanalysis&#34;&gt;Exemples using ERA5 reanalysis&lt;/h3&gt;

&lt;p&gt;In this post, we will work with ERA5 reanalysis and show how to extract a region using shapefile and compute standard deviation.&lt;/p&gt;

&lt;p&gt;We first import our librairies:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from netCDF4 import Dataset, num2date
import warnings
warnings.filterwarnings(&amp;quot;ignore&amp;quot;)
import datetime
import xarray as xr
import pandas as pd
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import xarray as xr 
import numpy as np
import regionmask
import geopandas as gpd
import pandas as pd
import matplotlib.pyplot as plt
import warnings; warnings.filterwarnings(action=&#39;ignore&#39;)
%matplotlib inline
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;working-over-canadian-provinces&#34;&gt;Working over canadian provinces&lt;/h3&gt;

&lt;p&gt;Canadian province shapefiles are available on this  &lt;a href=&#34;https://www.arcgis.com/home/item.html?id=5cf4f223c4a642eb9aa7ae1216a04372&#34; target=&#34;_blank&#34;&gt;website&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;After downloaded the shapefiles, we must load it using geopandas library:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;PATH_TO_SHAPEFILE = &#39;./Canadian_province/lpr_000b16a_e/lpr_000b16a_e.shp&#39;
province = gpd.read_file(PATH_TO_SHAPEFILE)
province.iloc[:,:-1]
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;PRUID&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;PRNAME&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;PRENAME&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;PRFNAME&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;PREABBR&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;PRFABBR&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Newfoundland and Labrador / Terre-Neuve-et-Labrador&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Newfoundland and Labrador&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Terre-Neuve-et-Labrador&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N.L.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;T.-N.-L.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Prince Edward Island / Île-du-Prince-Édouard&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Prince Edward Island&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Île-du-Prince-Édouard&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;P.E.I.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Î.-P.-É.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nova Scotia / Nouvelle-Écosse&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nova Scotia&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nouvelle-Écosse&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N.S.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N.-É.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;13&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;New Brunswick / Nouveau-Brunswick&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;New Brunswick&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nouveau-Brunswick&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N.B.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N.-B.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;24&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec / Québec&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Québec&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Que.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Qc&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;35&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ontario&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ontario&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ontario&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ont.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ont.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;46&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Manitoba&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Manitoba&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Manitoba&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Man.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Man.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Saskatchewan&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Saskatchewan&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Saskatchewan&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Sask.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Sask.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;48&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Alberta&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Alberta&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Alberta&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Alta.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Alb.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;59&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;British Columbia / Colombie-Britannique&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;British Columbia&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Colombie-Britannique&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;B.C.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;C.-B.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;60&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Yukon&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Yukon&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Yukon&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Y.T.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Yn&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;61&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Northwest Territories / Territoires du Nord-Ouest&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Northwest Territories&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Territoires du Nord-Ouest&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N.W.T.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;T.N.-O.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;62&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nunavut&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nunavut&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nunavut&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nvt.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nt&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tmpWGS84 = province.to_crs({&#39;proj&#39;:&#39;longlat&#39;, &#39;ellps&#39;:&#39;WGS84&#39;, &#39;datum&#39;:&#39;WGS84&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tmpWGS84.plot()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0x436e8908&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_5_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Shapes are here a GeoDataFrame containing all polygons illustrating the canadian province boundaries.&lt;/p&gt;

&lt;p&gt;Now we can load the ERA5 gridded data. The parameter chunks is very important, it defines how big are the “pieces” of data moved from the disk to the memory. With this value the entire computation on a workstation with 32 GB takes a couple of minutes.&lt;/p&gt;

&lt;p&gt;We will load all the temperature files for the year 2018 using Xarray library.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;model=&#39;ERA5_T2m_1h&#39;
t_in = &#39;J:/REANALYSES/ERA5/T2m_1h/&#39;        
data = t_in + model + &#39;_2018*_sfc.nc&#39;
ds = xr.open_mfdataset(data, chunks = {&#39;time&#39;: 10})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next function &lt;b&gt;assign_coords&lt;/b&gt; will convert the longitude from the 0-360 range to -180,180&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ds = ds.assign_coords(longitude=(((ds.longitude + 180) % 360) - 180)).sortby(&#39;longitude&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our xarray Dataset contains a single variable (t2m) which is stored as a dask.array. This is the result of loading files with open_mfdataset.&lt;/p&gt;

&lt;p&gt;Now we will use  regionmask module to create a gridded mask with the function regions_cls documented &lt;a href=&#34;https://regionmask.readthedocs.io/en/stable/generated/regionmask.Regions_cls.html#regionmask.Regions_cls&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With this function we will create an object able to mask ERA5 gridded data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;province_mask_poly = regionmask.Regions_cls(name = &#39;PRENAME&#39;, numbers = list(range(0,13)), names = list(tmpWGS84.PRENAME), abbrevs = list(tmpWGS84.PRENAME), outlines = list(tmpWGS84.geometry.values[i] for i in range(0,13)))
province_mask_poly
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;13 &#39;PRENAME&#39; Regions ()
Newfoundland and Labrador Prince Edward Island Nova Scotia New Brunswick Quebec Ontario Manitoba Saskatchewan Alberta British Columbia Yukon Northwest Territories Nunavut
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are ready to apply the mask on the gridded dataset xarray ERA5.&lt;/p&gt;

&lt;p&gt;We select only the first timestep to speed up the process.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mask = province_mask_poly.mask(ds.isel(time = 0), lat_name=&#39;latitude&#39;, lon_name=&#39;longitude&#39;)
mask.to_netcdf(&#39;ERA5_mask_Canadian_provinces.nc&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;masque = xr.open_mfdataset(&#39;ERA5_mask_Canadian_provinces.nc&#39;)
lat_bnd = [84, 40]
lon_bnd = [-148, -50]
masque = masque.sel(longitude=slice(*lon_bnd), latitude=slice(*lat_bnd),)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s a function to make maps in the future.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def make_figure():
    fig=plt.figure(figsize=(18,8), frameon=True) 
    ax = plt.axes(projection=ccrs.LambertConformal())
    ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))      # couche ocean
    ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))       # couche land
    ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))      # couche lac

    ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;), linestyle=&#39;dotted&#39;)    # couche frontieres
    ax.add_feature(cfeature.RIVERS.with_scale(&#39;50m&#39;))     # couche rivières 
    coast = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, scale=&#39;10m&#39;,     # ajout de la couche cotière 
                                facecolor=&#39;none&#39;, name=&#39;coastline&#39;)
    ax.add_feature(coast, edgecolor=&#39;black&#39;)   
    return fig, ax

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can make a quick visualisation of our netcdf mask:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;_, ax = make_figure()
ax.set_extent([-140,-50,32,82])
masque.region.plot.contourf(ax = ax, transform=ccrs.PlateCarree())
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.contour.QuadContourSet at 0x16563e48&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_18_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;compute-daily-and-monthly-2-meters-temperature-mean&#34;&gt;Compute daily and monthly 2 meters temperature  mean&lt;/h3&gt;

&lt;p&gt;We will now compute daily and monthly 2 meters temperature mean using hourly ERA5 datasets. To speed up our calcul, we will cut a subset over Canada only.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example code just for one month and one year:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;model=&#39;ERA5_T2m_1h&#39;

yi = 1990
yf = 1990
#########################################################
t_in = &#39;J:/REANALYSES/ERA5/T2m_1h/&#39;
daily_out = &#39;J:/REANALYSES/ERA5/T2m_daily/&#39; 
monthly_out = &#39;J:/REANALYSES/ERA5/T2m_monthly/&#39; 
for year in range(yi,yf+1):                    # loop over years
    for i in range (1,2,1):                   # loop over months
        
        data = t_in + model + &#39;_&#39;+str(year) +&#39;{:02d}&#39;.format(i)+&#39;_sfc.nc&#39;
        ds = xr.open_mfdataset(data)        
        ds = ds - 273.15  # convert from Kelvin to Celcius 
        ds = ds.assign_coords(longitude=(((ds.longitude + 180) % 360) - 180)).sortby(&#39;longitude&#39;)
        
        lat_bnd = [84, 40]
        lon_bnd = [-148, -50]
        ds = ds.sel(longitude=slice(*lon_bnd), latitude=slice(*lat_bnd),)
        
        daily_mean = ds.groupby(&#39;time.day&#39;).mean(&#39;time&#39;)
        daily_mean.to_netcdf(daily_out + &#39;Daily_Mean_T2m_CAN_&#39;+str(year) +&#39;{:02d}&#39;.format(i)+&#39;.nc&#39;)
        
        monthly_mean = daily_mean.mean(&#39;day&#39;)
        monthly_mean.to_netcdf(monthly_out + &#39;Monthly_Mean_T2m_CAN_&#39;+str(year) +&#39;{:02d}&#39;.format(i)+&#39;.nc&#39;)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;monthly-climatologies-and-standardized-anomalies&#34;&gt;Monthly climatologies and standardized anomalies&lt;/h3&gt;

&lt;p&gt;Once we have monthly mean values, we can now compute climatology and standard anomaly for monthly temperature from 1979 to 2019. Our reference climatology to compute standardized anomalies is 1990-2019 period.&lt;/p&gt;

&lt;p&gt;We will first work with one month (ie january), we will make a loop over all months after.&lt;/p&gt;

&lt;p&gt;First we open and load datasets:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import xarray as xr 

#### First we open and load datasets
#for month in range (1,2,1):
m = 1
file = &#39;J:/REANALYSES/ERA5/T2m_monthly/Monthly_Mean_T2m_CAN_&#39;
month = &#39;{:02d}&#39;.format(m)
multi_file = [f&#39;{file}{year}{month}.nc&#39; for year in range(1990,2020,1)]
ds_all = xr.concat([xr.open_dataset(f) for f in multi_file], &#39;time&#39;)
ds_all.time
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&amp;lt;xarray.DataArray &amp;#x27;time&amp;#x27; (time: 30)&amp;gt;
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
       18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29], dtype=int64)
Dimensions without coordinates: time&lt;/pre&gt;

&lt;p&gt;Our time is without dimension, it&amp;rsquo;s just an integer. To easly handle our fields, we can define a DatetimeIndex to change &amp;lsquo;time&amp;rsquo; dimension in our Xarray. For more &lt;a href=&#34;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-offset-aliases&#34; target=&#34;_blank&#34;&gt;information&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ds_all[&#39;time&#39;] = pd.date_range(&#39;1990-&#39;+month+&#39;-01&#39;, freq=&#39;YS&#39;, periods=ds_all.time.shape[0])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ds_all.time.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&amp;lt;xarray.DataArray &amp;#x27;time&amp;#x27; (time: 5)&amp;gt;
array([&amp;#x27;1990-01-01T00:00:00.000000000&amp;#x27;, &amp;#x27;1991-01-01T00:00:00.000000000&amp;#x27;,
       &amp;#x27;1992-01-01T00:00:00.000000000&amp;#x27;, &amp;#x27;1993-01-01T00:00:00.000000000&amp;#x27;,
       &amp;#x27;1994-01-01T00:00:00.000000000&amp;#x27;], dtype=&amp;#x27;datetime64[ns]&amp;#x27;)
Coordinates:
  * time     (time) datetime64[ns] 1990-01-01 1991-01-01 ... 1994-01-01&lt;/pre&gt;

&lt;p&gt;We can compute our climatology and standard deviation over 30 years: 1990-2019&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;clim_yi = 1990
clim_yf = 2019
ds_clim =  ds_all.sel(time=slice(str(clim_yi)+&#39;-&#39;+month+&#39;-01&#39;, str(clim_yf)+&#39;-&#39;+month+&#39;-01&#39;))
data_clim = ds_clim.variables[&#39;t2m&#39;][:].mean(&amp;quot;time&amp;quot;)
data_std  = ds_clim.variables[&#39;t2m&#39;][:].std(&amp;quot;time&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can apply a function with .apply_unfunc and groupby methods to compute a standardized anomaly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;stand_anomalies = xr.apply_ufunc(
    lambda x, m, s: (x - m) / s,
    ds_all.groupby(&amp;quot;time&amp;quot;),
    data_clim,
    data_std,
)

stand_anomalies.to_netcdf(&#39;J:/REANALYSES/ERA5/T2m_Month_Anomaly/Std_Anomaly_Monthly_Mean_T2m_CAN_&#39;+
                          str(yi)+&#39;-&#39;+str(yf)+&#39;_vs_&#39;+str(clim_yi)+&#39;-&#39;+str(clim_yf)+&#39;_&#39;+str(month)+&#39;.nc&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will mask all Canadian provinces with applying our mask region created at the begining of this post:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data_clim_can = data_clim.where(masque.region &amp;gt;= 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now display january monthly mean temperature climatology:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;_, ax = make_figure()
ax.set_extent([-140,-50,32,82])
import matplotlib as mpl
import datetime
monthstr = datetime.date(1900, int(month), 1).strftime(&#39;%B&#39;)
data_levels = np.arange(-35, 30, 5.1)
Y=np.array([[77,0,111],[115,14,181],[160,17,222],[195,14,240],\
               [0,0,93],[21,38,177],[33,95,227],[32,162,247],[59,224,248],[202,255,250],\
               [4,255,179],[37,181,139],[32,132,81],[72,162,60],[157,240,96],[213,255,166],\
               [241,247,132],[248,185,68],[255,124,4],[235,78,14],[215,32,24],[189,24,40],[162,16,56],[135,16,65],[107,15,73]])/255.

colbar=mpl.colors.ListedColormap(Y)
mm = ax.contourf(data_clim_can.longitude,\
                   data_clim_can.latitude,\
                   data_clim_can,\
                   vmin=-35,\
                   vmax= 30, \
                   transform=ccrs.PlateCarree(),\
                   levels=data_levels,\
                   cmap=colbar )

data_contour = ax.contour(data_clim_can.longitude, data_clim_can.latitude, data_clim_can, 
                          levels = data_levels, 
                          linewidths=2, 
                          colors=&#39;k&#39;,
                          transform = ccrs.PlateCarree())
#Plot contour labels for the heights, leaving a break in the contours for the text (inline=True)
plt.clabel(data_contour,  data_levels, inline=True, fmt=&#39;%1i&#39;, fontsize=12)
# Define gridline locations and draw the lines using cartopy&#39;s built-in gridliner:
xticks = np.arange(-150.0,-40.0,20)
yticks =np.arange(10,80,10)

cbar = plt.colorbar(mm,  shrink=0.75, drawedges=&#39;True&#39;, ticks=np.arange(-35, 30.1, 5.), extend=&#39;both&#39;) # 2018

cbar.ax.tick_params(labelsize=20) 

string_title=u&#39;Climatology of monthly mean 2meters temperature: &#39; + monthstr
plt.title(string_title, size=&#39;xx-large&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Text(0.5, 1.0, &#39;Climatology of monthly mean 2meters temperature: January&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_34_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If we just want to display over one province, we can adjust our mask.  Let&amp;rsquo;s plot climatology over Quebec:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data_clim_qc = data_clim.where(masque.region == 4  )
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;_, ax = make_figure()
ax.set_extent([-80,-60,45,65])
monthstr = datetime.date(1900, int(month), 1).strftime(&#39;%B&#39;)
data_levels = np.arange(-35, 30, 5.1)
Y=np.array([[77,0,111],[115,14,181],[160,17,222],[195,14,240],\
               [0,0,93],[21,38,177],[33,95,227],[32,162,247],[59,224,248],[202,255,250],\
               [4,255,179],[37,181,139],[32,132,81],[72,162,60],[157,240,96],[213,255,166],\
               [241,247,132],[248,185,68],[255,124,4],[235,78,14],[215,32,24],[189,24,40],[162,16,56],[135,16,65],[107,15,73]])/255.

colbar=mpl.colors.ListedColormap(Y)

data_levels = np.arange(-35, 30, 5.1)

mm = ax.contourf(data_clim_qc.longitude,\
                   data_clim_qc.latitude,\
                   data_clim_qc,\
                   vmin=-35,\
                   vmax= 30, \
                   transform=ccrs.PlateCarree(),\
                   levels=data_levels,\
                   cmap=colbar )

data_contour = ax.contour(data_clim_qc.longitude, data_clim_qc.latitude, data_clim_qc, 
                          levels = data_levels, 
                          linewidths=2, 
                          colors=&#39;k&#39;,
                          transform = ccrs.PlateCarree())
#Plot contour labels for the heights, leaving a break in the contours for the text (inline=True)
plt.clabel(data_contour,  data_levels, inline=True, fmt=&#39;%1i&#39;, fontsize=12)
# Define gridline locations and draw the lines using cartopy&#39;s built-in gridliner:
xticks = np.arange(-150.0,-40.0,20)
yticks =np.arange(10,80,10)

cbar = plt.colorbar(mm,  shrink=0.75, drawedges=&#39;True&#39;, ticks=np.arange(-35, 30.1, 5.), extend=&#39;both&#39;) # 2018

cbar.ax.tick_params(labelsize=20) 

string_title=u&#39;ERA5 T2m Climatology (1990-2019) over Quebec &#39; + monthstr
plt.title(string_title, size=&#39;xx-large&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Text(0.5, 1.0, &#39;ERA5 T2m Climatology (1990-2019) over Quebec January&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_37_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;inter-annual-standardised-anomaly&#34;&gt;Inter-annual standardised anomaly&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s compute and draw inter-annual standardised anomaly over Quebec:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;stand_anomalies_qc  = stand_anomalies.where(masque.region == 4)
stand_anomalie_serie = stand_anomalies_qc.mean([&#39;latitude&#39;,&#39;longitude&#39;])
stand_anomalie_serie.time.values[-1]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;numpy.datetime64(&#39;2019-01-01T00:00:00.000000000&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;color = [&#39;black&#39;,&#39;blue&#39;, &#39;red&#39;]
fig = plt.figure(figsize=(18, 12)) 


plt.rcParams[&amp;quot;figure.figsize&amp;quot;]=[16,9]       #  
plt.plot(stand_anomalie_serie.time.values, stand_anomalie_serie.t2m.values, 
         label=&#39;ERA5 2m temperature&#39;, linewidth=2, c=color[2])
plt.legend(loc=&amp;quot;upper left&amp;quot;, markerscale=1., scatterpoints=1, fontsize=20)

plt.yticks( fontsize=14)

ax.grid(axis = &amp;quot;x&amp;quot;, linestyle = &amp;quot;--&amp;quot;, color=&#39;black&#39;, linewidth=0.25, alpha=0.5)
ax.grid(axis = &amp;quot;y&amp;quot;, linestyle = &amp;quot;--&amp;quot;, color=&#39;black&#39;, linewidth=0.25, alpha=0.5)

plt.setp(plt.gca().get_xticklabels(), rotation=45, ha=&amp;quot;right&amp;quot;)

plt.xlabel(&#39;Date&#39;, fontsize=20, color=&#39;black&#39;, weight=&#39;semibold&#39;)
plt.ylabel(&#39;°C&#39;, fontsize=20, color=&#39;black&#39;, weight=&#39;semibold&#39;)
plt.title(&#39;Inter annual standardised anomaly of monthly mean temperature over Quevec in January: (1990-2019) compared with normal (1990-2019)&#39;, fontsize=20, color=&#39;black&#39;, weight=&#39;semibold&#39;)
 
ax.set_facecolor(&#39;white&#39;)
plt.yticks( fontsize=14)
plt.show()  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_40_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Working with XML climate data</title>
      <link>/post/working_with_xml_climate_data/</link>
      <pubDate>Tue, 10 Mar 2020 11:16:07 -0700</pubDate>
      <guid>/post/working_with_xml_climate_data/</guid>
      <description>

&lt;p&gt;﻿
In this tutorial, we will extract Hourly Observation from ECCC and display hourly temperature using plotly library.&lt;/p&gt;

&lt;p&gt;We are going to work here with the hourly weather observations data found on the ECCC Datamart.&lt;/p&gt;

&lt;p&gt;These observations data are subject to quality control.
Any value that does not pass quality control is deleted.
This includes values that are categorized as questionable.&lt;/p&gt;

&lt;p&gt;For each province or territory, one file for one specific hour contains:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The coldest place and temperature in Canada for this hour&lt;/li&gt;
&lt;li&gt;The hottest location and temperature in Canada for this hour&lt;/li&gt;
&lt;li&gt;The coldest place and temperature in the province or territory for this hour&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The hottest location and temperature in the province for territory for this hour&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The observations and the records of the stations available in this province:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Present condition (expression)&lt;/li&gt;
&lt;li&gt;Sea level pressure (kPa)&lt;/li&gt;
&lt;li&gt;Value of the pressure trend (kPa)&lt;/li&gt;
&lt;li&gt;Pressure trend (upward, downward, or stable)&lt;/li&gt;
&lt;li&gt;Visibility (km)&lt;/li&gt;
&lt;li&gt;Air temperature (° C)&lt;/li&gt;
&lt;li&gt;Dew point (° C)&lt;/li&gt;
&lt;li&gt;Relative humidity (%)&lt;/li&gt;
&lt;li&gt;Wind speed (km / h)&lt;/li&gt;
&lt;li&gt;Wind direction (code)&lt;/li&gt;
&lt;li&gt;Burst speed (km / h)&lt;/li&gt;
&lt;li&gt;Cloud cover&lt;/li&gt;
&lt;li&gt;Wind Chill&lt;/li&gt;
&lt;li&gt;Humidex&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;stations-information&#34;&gt;Stations information:&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;For each station, the following information is available:
* Station name
* Latitude (decimal degree)
* Longitude (decimal degree)
* Transport Canada identification number
* Observation times are in UTC time and local time
* Climate station ID
* WMO station number&lt;/p&gt;

&lt;p&gt;There are over 500 observation stations in Canada. However, this number is constantly evolving. The stations are present in the files only if observation data are available.&lt;/p&gt;

&lt;p&gt;&amp;lsquo;swob-xml_station_list.csv&amp;rsquo; document on this &lt;a href=&#34;https://dd.weather.gc.ca/observations/doc/&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt; is a list of XML observations available.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://dd.weather.gc.ca/observations/doc/Met-ML-SchemaDescriptionV2_e.pdf&#34; target=&#34;_blank&#34;&gt;Here&lt;/a&gt; is a full documentation for XML description of observation point meteorological:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.opengeospatial.org/standards/om&#34; target=&#34;_blank&#34;&gt;OpenGIS&lt;/a&gt; : Standards for observations and measurement.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.weatheroffice.gc.ca/mainmenu/faq_f.html&#34; target=&#34;_blank&#34;&gt;Frequently Asked Questions from Environment and Change Weather Service Climate Canada&lt;/a&gt; Frequently Asked Questions from Environment and Change Weather Service Climate Canada. Miscellaneous information about meteorology and climatology.&lt;/p&gt;

&lt;p&gt;Historical climatic data are available on this &lt;a href=&#34;http://climate.weatheroffice.gc.ca&#34; target=&#34;_blank&#34;&gt;site&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Synoptic and METAR bulletins can also be found on the &lt;a href=&#34;http://dd.weather.gc.ca/bulletins/doc/README_bulletins.txt&#34; target=&#34;_blank&#34;&gt;MSC HTTP data server&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First, we import python librairies and define the date we want to extract:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from datetime import datetime, timedelta
import pandas as pd 
import xml.etree.ElementTree as ET
import wget
import warnings
warnings.filterwarnings(&amp;quot;ignore&amp;quot;)
import os 
from os.path import exists
import requests
import numpy as np
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will work first with all the stations over Quebec (ie file with prefix hourly&lt;em&gt;qc&lt;/em&gt;):&lt;/p&gt;

&lt;p&gt;We will work on this &lt;a href=&#34;https://dd.weather.gc.ca/observations/xml/&#34; target=&#34;_blank&#34;&gt;directory&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We want to extreact the latest value recorded.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;now = datetime.utcnow() - timedelta(hours=1)
tmp_file = &#39;http://dd.weather.ec.gc.ca/observations/xml/QC/hourly/hourly_qc_&#39;+now.strftime(&amp;quot;%Y%m%d%H&amp;quot;)+&#39;_e.xml&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;wget.download(tmp_file)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&#39;hourly_qc_2020031017_e (1).xml&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tree = ET.parse(&#39;hourly_qc_&#39;+now.strftime(&amp;quot;%Y%m%d%H&amp;quot;)+&#39;_e.xml&#39;)
root=tree.getroot()
children = root.getchildren()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Number of elements in our file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# total amount of items
print(len(root))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;122
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;to-scan-the-elements-of-our-set-ie-the-children-of-our-root&#34;&gt;To scan the elements of our set, ie the children of our &amp;lsquo;root&amp;rsquo;:&lt;/h3&gt;

&lt;p&gt;for child in root.iter(&amp;rsquo;*&amp;lsquo;):&lt;br /&gt;
    #print(child)
    #print(child.attrib)
    #print(child.attrib.get(&amp;lsquo;value&amp;rsquo;))
    print(child.attrib.get(&amp;lsquo;name&amp;rsquo;))&lt;/p&gt;

&lt;h3 id=&#34;example-of-station-detection&#34;&gt;Example of station detection:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for child in root.iter(&#39;*&#39;): 
    if child.attrib.get(&#39;value&#39;) == &#39;7110600&#39;:
        print(child.tag)
        print(&#39;station trouvee&#39;)
        print(child.attrib.get(&#39;name&#39;) + &#39;: 7110600&#39; )
        print(child.items())
        print(child.get(&#39;value&#39;))
        test = tree.find(&#39;.//%s/&#39; % child.tag)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{http://dms.ec.gc.ca/schema/point-observation/2.1}element
station trouvee
climate_station_number: 7110600
[(&#39;name&#39;, &#39;climate_station_number&#39;), (&#39;uom&#39;, &#39;unitless&#39;), (&#39;value&#39;, &#39;7110600&#39;)]
7110600
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The list of variables is available on this &lt;a href=&#34;https://dd.weather.gc.ca/observations/doc/Met-ML-SchemaDescriptionV2_f.pdf&#34; target=&#34;_blank&#34;&gt;document&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;1-observations-extraction&#34;&gt;1- Observations extraction:&lt;/h2&gt;

&lt;p&gt;We will loop over all stations in Quebec and extract some meteorological values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mslp=[]
air=[]  
dew=[]
rel=[]
winds=[]
windd=[]
windc=[]
humidex=[]
stid=[]
present_weather = []
horizontal_visibility = []
station_name = []
latitude = []
longitude = []
for child in root.iter(&#39;*&#39;):      
    if child.attrib.get(&#39;name&#39;) == &#39;present_weather&#39;:
        present_weather.append(child.get(&#39;value&#39;))        
    if child.attrib.get(&#39;name&#39;) == &#39;mean_sea_level&#39;:
        mslp.append(child.get(&#39;value&#39;))
    if child.attrib.get(&#39;name&#39;) == &#39;air_temperature&#39;:
        air.append(child.get(&#39;value&#39;))
    if child.attrib.get(&#39;name&#39;) == &#39;dew_point&#39;:
        dew.append(child.get(&#39;value&#39;))
    if child.attrib.get(&#39;name&#39;) == &#39;relative_humidity&#39;:
        rel.append(child.get(&#39;value&#39;))
    if child.attrib.get(&#39;name&#39;) == &#39;wind_speed&#39;:
        winds.append(child.get(&#39;value&#39;))
    if child.attrib.get(&#39;name&#39;) == &#39;wind_direction&#39;:
        windd.append(child.get(&#39;value&#39;))
    if child.attrib.get(&#39;name&#39;) == &#39;wind_chill&#39;:
        windc.append(child.get(&#39;value&#39;))
    if child.attrib.get(&#39;name&#39;) == &#39;humidex&#39;:
        humidex.append(child.get(&#39;value&#39;))
    if child.attrib.get(&#39;name&#39;) == &#39;horizontal_visibility&#39;:
        horizontal_visibility.append(child.get(&#39;value&#39;)) 
        
    if child.attrib.get(&#39;name&#39;) == &#39;climate_station_number&#39;:
        stid.append(child.get(&#39;value&#39;)) 
    if child.attrib.get(&#39;name&#39;) == &#39;station_name&#39;:
        station_name.append(child.get(&#39;value&#39;))    
    if child.attrib.get(&#39;name&#39;) == &#39;latitude&#39;:
        latitude.append(child.get(&#39;value&#39;))
    if child.attrib.get(&#39;name&#39;) == &#39;longitude&#39;:
        longitude.append(child.get(&#39;value&#39;))        
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;date = now.strftime(&amp;quot;%Y-%m-%d %H:00&amp;quot;)
month =  now.strftime(&amp;quot;%Y%m&amp;quot;)
os.makedirs(month, exist_ok=True)  

data = {&#39;climate_station_number&#39;:stid,
        &#39;station_name&#39;: station_name,
        &#39;latitude&#39;: latitude,
        &#39;longitude&#39;: longitude,
        &#39;date&#39;:date, 
        &#39;mean_sea_level&#39;:mslp,
        &#39;air_temperature&#39;:air,
        &#39;dew_point&#39;:dew,
        &#39;relative_humidity&#39;: rel,
        &#39;wind_speed&#39;:winds,
        &#39;wind_direction&#39;:windd,
        &#39;wind_chill&#39;:windc,
        &#39;humidex&#39;:humidex,
        &#39;horizontal_visibility&#39;:horizontal_visibility } 

data= pd.DataFrame(data).set_index(&amp;quot;climate_station_number&amp;quot;)   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to select a specific station:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data[data[&#39;station_name&#39;]== &#39;Montréal&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;| climate_station_number   | station_name   |   latitude |   longitude | date             |   mean_sea_level |   air_temperature |   dew_point |   relative_humidity |   wind_speed | wind_direction   | wind_chill   | humidex   | horizontal_visibility   |
|:-------------------------|:---------------|-----------:|------------:|:-----------------|-----------------:|------------------:|------------:|--------------------:|-------------:|:-----------------|:-------------|:----------|:------------------------|
| 702S006                  | Montréal       |    45.4678 |    -73.7417 | 2020-03-10 17:00 |            100.7 |               2.1 |         1.5 |                  96 |           10 | NNE              |              |           |                         |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To save our data by stations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for index, row in data.iterrows(): 
    file = &#39;D:/Utilisateurs/guillaume/Documents/GitHub/Python_XML/&#39;+month+&#39;/&#39;+index+&#39;_&#39;+month+&#39;.csv&#39;
    if exists(file):
        #print (&amp;quot;File exist&amp;quot;)
        pd.DataFrame(row).T.to_csv(r&#39;D:/Utilisateurs/guillaume/Documents/GitHub/Python_XML/&#39;+month+&#39;/&#39;+index+&#39;_&#39;+month+&#39;.csv&#39;,mode=&#39;a&#39;,index=False,header=False) 
    else:
        #print (&amp;quot;File not exist&amp;quot;)
        pd.DataFrame(row).T.to_csv(r&#39;D:/Utilisateurs/guillaume/Documents/GitHub/Python_XML/&#39;+month+&#39;/&#39;+index+&#39;_&#39;+month+&#39;.csv&#39;,index=False) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now have everything we need to use Plotly library in order to have interactive scatter plots on maps.&lt;/p&gt;

&lt;p&gt;We use the Plotly Express function px.scatter_mapbox to display current temperature observations over Canada.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;list_province =  [&#39;AB&#39;,&#39;BC&#39;,&#39;MB&#39;,&#39;NB&#39;,&#39;NL&#39;,&#39;NS&#39;,&#39;NT&#39;,&#39;NU&#39;,&#39;ON&#39;,&#39;PE&#39;,&#39;QC&#39;,&#39;SK&#39;,&#39;YT&#39;]

dataset = []
for province in list_province:    
    tmp_file = &#39;http://dd.weather.ec.gc.ca/observations/xml/&#39;+province+&#39;/hourly/hourly_&#39;+province.lower()+&#39;_&#39;+now.strftime(&amp;quot;%Y%m%d%H&amp;quot;)+&#39;_e.xml&#39;
    r = requests.get(tmp_file)
    root = ET.fromstring(r.content)
    latitude = []
    longitude = []
    air=[]  
    stid=[]
    station_name = []
    latitude = []
    longitude = []
    data = []
    
    for child in root.iter(&#39;*&#39;):      
        if child.attrib.get(&#39;name&#39;) == &#39;air_temperature&#39;:
            air.append(child.get(&#39;value&#39;))       
        if child.attrib.get(&#39;name&#39;) == &#39;climate_station_number&#39;:
            stid.append(child.get(&#39;value&#39;)) 
        if child.attrib.get(&#39;name&#39;) == &#39;station_name&#39;:
            station_name.append(child.get(&#39;value&#39;))    
        if child.attrib.get(&#39;name&#39;) == &#39;latitude&#39;:
            latitude.append(child.get(&#39;value&#39;))
        if child.attrib.get(&#39;name&#39;) == &#39;longitude&#39;:
            longitude.append(child.get(&#39;value&#39;))    
    data = {&#39;climate_station_number&#39;:stid,
            &#39;station_name&#39;: station_name,
            &#39;latitude&#39;: latitude,
            &#39;longitude&#39;: longitude,
            &#39;date&#39;:date, 
            &#39;air_temperature&#39;:air } 

    data = pd.DataFrame(data)
    dataset.append(data)

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataset = pd.concat(dataset)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataset[[&#39;latitude&#39;, &#39;longitude&#39;]] = dataset[[&#39;latitude&#39;, &#39;longitude&#39;]].astype(float)
dataset[[&#39;air_temperature&#39;]] = pd.to_numeric(dataset[&#39;air_temperature&#39;].str.replace(&#39; &#39;, &#39;&#39;)).astype(float)
dataset[&#39;Size&#39;]=([0.5] * len(dataset))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now create our scatter plot using plotly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import plotly.express as px
# Create a token in mapbox
token = &#39;**** &#39;

fig = px.scatter_mapbox(dataset,
        lat = &#39;latitude&#39;,
        lon = &#39;longitude&#39;,
        zoom=2.5,
        hover_name=&#39;date&#39;,
        range_color=(-30, 5),
        size=&#39;Size&#39;,
        color=&#39;air_temperature&#39;,
        color_continuous_scale=px.colors.sequential.Jet,
        width = 1000,
        height = 1000
        )
# Configure the style of the map
fig.update_layout(
        mapbox_style=&amp;quot;light&amp;quot;, 
        mapbox_accesstoken=token
    )

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;scatter.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can push our visualization to our plotly account using the following lines of code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import chart_studio

username = &#39;username&#39;
api_key = &#39;******&#39;

chart_studio.tools.set_credentials_file(username = username, api_key = api_key)
import chart_studio.plotly as py 
py.plot(fig, filename = &#39;scatter_plot&#39;, auto_open = True)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If done correctly, this code should open a new window with your visualization on your account and return the link in your notebook.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;https://plot.ly/~guimeteo/19/&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have the &lt;a href=&#34;https://plot.ly/~guimeteo/19/&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt;  to our plotly visualization (either hosted on plotly or github pages).&lt;/p&gt;

&lt;h2 id=&#34;2-plot-timeserie-for-one-station&#34;&gt;2- Plot timeserie for one station:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from datetime import datetime
end_date = datetime.utcnow() - timedelta(hours=1) 
start_date = datetime.utcnow() - timedelta(days=14)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mydate = start_date
while mydate &amp;lt; end_date:    
    #print((mydate).strftime(&amp;quot;%Y-%m-%d %H:00&amp;quot;))
    mydate += timedelta(hours=1)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from datetime import datetime
end_date = datetime.utcnow() - timedelta(hours=1) 
start_date = datetime.utcnow() - timedelta(days=14)
mydate = start_date
dataset = []
while mydate &amp;lt; end_date:    
    #print((mydate).strftime(&amp;quot;%Y-%m-%d %H:00&amp;quot;))  
    tmp_file = &#39;http://dd.weather.ec.gc.ca/observations/xml/QC/hourly/hourly_qc_&#39;+mydate.strftime(&amp;quot;%Y%m%d%H&amp;quot;)+&#39;_e.xml&#39;
    r = requests.get(tmp_file)
    root = ET.fromstring(r.content)
    air=[]  
    stid=[]
    latitude = []
    longitude = []
    data  = []
    station = [] 
    for child in root.iter(&#39;*&#39;):      
        if child.attrib.get(&#39;name&#39;) == &#39;air_temperature&#39;:
            air.append(child.get(&#39;value&#39;))
        if child.attrib.get(&#39;name&#39;) == &#39;climate_station_number&#39;:
            stid.append(child.get(&#39;value&#39;))       
        if child.attrib.get(&#39;name&#39;) == &#39;latitude&#39;:
            latitude.append(child.get(&#39;value&#39;))
        if child.attrib.get(&#39;name&#39;) == &#39;longitude&#39;:
            longitude.append(child.get(&#39;value&#39;))
        if child.attrib.get(&#39;name&#39;) == &#39;station_name&#39;:
            station.append(child.get(&#39;value&#39;))    

    date = now.strftime(&amp;quot;%Y-%m-%d %H:00&amp;quot;)
    month =  now.strftime(&amp;quot;%Y%m&amp;quot;)

    data = {&#39;climate_station_number&#39;:stid,
            &#39;latitude&#39;: latitude,
            &#39;longitude&#39;: longitude,
            &#39;date&#39;:mydate.strftime(&amp;quot;%Y-%m-%d:%H&amp;quot;), 
            &#39;air_temperature&#39;:air,
            &#39;name station&#39;: station} 
    
    mydate += timedelta(hours=1) 
    
    data = pd.DataFrame(data)
    dataset.append(data)   
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataset = pd.concat(dataset)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataset.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;|    | climate_station_number   |   latitude |   longitude | date          |   air_temperature | name station        |
|---:|:-------------------------|-----------:|------------:|:--------------|------------------:|:--------------------|
|  0 | 7100071                  |    60.8186 |    -78.1486 | 2020-02-25:18 |             -29.9 | Akulivik Airport    |
|  1 | 7110600                  |    59.2967 |    -69.5997 | 2020-02-25:18 |             -26.6 | Aupaluk Airport     |
|  2 | 704S001                  |    49.2592 |    -68.1458 | 2020-02-25:18 |               0.6 | Baie-Comeau         |
|  3 | 7040444                  |    49.1325 |    -68.2044 | 2020-02-25:18 |               2.1 | Baie-Comeau Airport |
|  4 | 7040442                  |    49.1333 |    -68.2    | 2020-02-25:18 |               1.7 | Baie-Comeau Climate |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will plot daily timeserie for station with climate_station_number = &amp;lsquo;702S006&amp;rsquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataset1 =  dataset[dataset[&#39;climate_station_number&#39;]==&#39;702S006&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataset1.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;|    | climate_station_number   |   latitude |   longitude | date          |   air_temperature | name station   |
|---:|:-------------------------|-----------:|------------:|:--------------|------------------:|:---------------|
| 64 | 702S006                  |    45.4678 |    -73.7417 | 2020-02-25:18 |               4.2 | Montréal       |
| 66 | 702S006                  |    45.4678 |    -73.7417 | 2020-02-25:19 |               3.5 | Montréal       |
| 65 | 702S006                  |    45.4678 |    -73.7417 | 2020-02-25:20 |               4.5 | Montréal       |
| 65 | 702S006                  |    45.4678 |    -73.7417 | 2020-02-25:21 |               5   | Montréal       |
| 65 | 702S006                  |    45.4678 |    -73.7417 | 2020-02-25:22 |               5   | Montréal       |
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import datetime
fig = px.line(dataset1, x=&#39;date&#39;, y=&#39;air_temperature&#39;)
fig.update_layout(title_text=&#39;Hourly mean temperature in Montreal&#39;,
                  xaxis_rangeslider_visible=True)
fig.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import plotly.io as pio
pio.write_html(fig, file = &#39;timeserie.html&#39;, auto_open = True)
fig.write_image(&amp;quot;timeserie.png&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;timeserie.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Follow this &lt;a href=&#34;https://plot.ly/~guimeteo/22/&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt; for interactive plot.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ECCC climate data</title>
      <link>/post/working_with_eccc_climate_data/</link>
      <pubDate>Tue, 10 Mar 2020 09:38:17 -0700</pubDate>
      <guid>/post/working_with_eccc_climate_data/</guid>
      <description>

&lt;p&gt;﻿&lt;/p&gt;

&lt;h2 id=&#34;extract-hourly-daily-and-monthly-climate-data-from-eccc-datamart&#34;&gt;- Extract hourly, daily and monthly climate data from ECCC datamart&lt;/h2&gt;

&lt;p&gt;In this post, we will see how to automatically download all weather data for one station from environment and climate change canada using Python librairies.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the  &lt;a href=&#34;https://climate.weather.gc.ca/&#34; target=&#34;_blank&#34;&gt;URL&lt;/a&gt; to get historical data.&lt;/p&gt;

&lt;p&gt;We will use a daily updated list of Climate stations in the National Archive available on this &lt;a href=&#34;https://drive.google.com/drive/folders/1WJCDEU34c60IfOnG4rv5EPZ4IhhW9vZH&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As usual, we import our python librairies:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
import wget
import numpy as np
import shutil
import xml.etree.ElementTree as ET
import pandas as pd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, we can open and read the list of Climate stations using Pandas:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df = pd.read_csv(&#39;J:/Donnees_Stations/Donnees_EC/Codes/Station_Inventory_EN.csv&#39;, sep=&#39;,&#39;, skiprows=3)
df.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;|    | Name                   | Province         |   Climate ID |   Station ID |   WMO ID |   TC ID |   Latitude (Decimal Degrees) |   Longitude (Decimal Degrees) |   Latitude |   Longitude |   Elevation (m) |   First Year |   Last Year |   HLY First Year |   HLY Last Year |   DLY First Year |   DLY Last Year |   MLY First Year |   MLY Last Year |
|---:|:-----------------------|:-----------------|-------------:|-------------:|---------:|--------:|-----------------------------:|------------------------------:|-----------:|------------:|----------------:|-------------:|------------:|-----------------:|----------------:|-----------------:|----------------:|-----------------:|----------------:|
|  0 | ACTIVE PASS            | BRITISH COLUMBIA |      1010066 |           14 |      nan |     nan |                        48.87 |                       -123.28 |  485200000 | -1231700000 |             4   |         1984 |        1996 |              nan |             nan |             1984 |            1996 |             1984 |            1996 |
|  1 | ALBERT HEAD            | BRITISH COLUMBIA |      1010235 |           15 |      nan |     nan |                        48.4  |                       -123.48 |  482400000 | -1232900000 |            17   |         1971 |        1995 |              nan |             nan |             1971 |            1995 |             1971 |            1995 |
|  2 | BAMBERTON OCEAN CEMENT | BRITISH COLUMBIA |      1010595 |           16 |      nan |     nan |                        48.58 |                       -123.52 |  483500000 | -1233100000 |            85.3 |         1961 |        1980 |              nan |             nan |             1961 |            1980 |             1961 |            1980 |
|  3 | BEAR CREEK             | BRITISH COLUMBIA |      1010720 |           17 |      nan |     nan |                        48.5  |                       -124    |  483000000 | -1240000000 |           350.5 |         1910 |        1971 |              nan |             nan |             1910 |            1971 |             1910 |            1971 |
|  4 | BEAVER LAKE            | BRITISH COLUMBIA |      1010774 |           18 |      nan |     nan |                        48.5  |                       -123.35 |  483000000 | -1232100000 |            61   |         1894 |        1952 |              nan |             nan |             1894 |            1952 |             1894 |            1952 |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this Dataframe, we have all informations to select and work with climate stations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Name : name of the station&lt;/li&gt;
&lt;li&gt;Province:  province of the station&lt;/li&gt;
&lt;li&gt;Climate ID: Climate ID number&lt;/li&gt;
&lt;li&gt;Station ID: Station ID number&lt;/li&gt;
&lt;li&gt;Latitude: latitude of the station in decimal degrees&lt;/li&gt;
&lt;li&gt;Longitude: longitude of the station in decimal degrees&lt;/li&gt;
&lt;li&gt;First Year: first year of record&lt;/li&gt;
&lt;li&gt;Last Year: last year of record&lt;/li&gt;
&lt;li&gt;HLY First Year: first year of hourly record&lt;/li&gt;
&lt;li&gt;HLY Last Year: last year of hourly record&lt;/li&gt;
&lt;li&gt;DLY First Year: first year of daily record&lt;/li&gt;
&lt;li&gt;DLY Last Year: last year of daily record&lt;/li&gt;
&lt;li&gt;MLY First Year: first year of monthly record&lt;/li&gt;
&lt;li&gt;MLY Last Year: last year of monthly record&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can easily create 3 dataframes to distinguish hourly, daily and monthly datasets:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df_hourly = df[[&#39;Name&#39;, &#39;Province&#39;,&#39;Climate ID&#39;,&#39;Station ID&#39;,&#39;Latitude (Decimal Degrees)&#39;,
              &#39;Longitude (Decimal Degrees)&#39;,&#39;HLY First Year&#39;,&#39;HLY Last Year&#39;]].dropna()

df_daily = df[[&#39;Name&#39;, &#39;Province&#39;,&#39;Climate ID&#39;,&#39;Station ID&#39;,&#39;Latitude (Decimal Degrees)&#39;,
              &#39;Longitude (Decimal Degrees)&#39;,&#39;DLY First Year&#39;,&#39;DLY Last Year&#39;]].dropna()

df_monthly = df[[&#39;Name&#39;, &#39;Province&#39;,&#39;Climate ID&#39;,&#39;Station ID&#39;,&#39;Latitude (Decimal Degrees)&#39;,
              &#39;Longitude (Decimal Degrees)&#39;,&#39;MLY First Year&#39;,&#39;MLY Last Year&#39;]].dropna()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will use wget python command to download data using a specific path:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;wget.download(&#39;http://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=csv&amp;amp;stationID=&#39;+str(int(id_stat))+&#39;&amp;amp;Year=&#39;+str(year)+&#39;&amp;amp;Month=01&amp;amp;Day=14&amp;amp;timeframe=1&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;year&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;year of the record&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;month&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;month of the record&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;format&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;[csv&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;timeframe = 1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;for hourly data&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;timeframe = 2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;for daily data&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;timeframe = 3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;for monthly data&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;- Day: the value of the &amp;quot;day&amp;quot; variable is not used and can be an arbitrary value
- For another station, change the value of the variable stationID
- For the data in XML format, change the value of the variable format to xml in the URL.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-working-with-hourly-data&#34;&gt;1- Working with hourly data:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df_hourly.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;|    | Name              | Province         |   Climate ID |   Station ID |   Latitude (Decimal Degrees) |   Longitude (Decimal Degrees) |   HLY First Year |   HLY Last Year |
|---:|:------------------|:-----------------|-------------:|-------------:|-----------------------------:|------------------------------:|-----------------:|----------------:|
| 28 | DISCOVERY ISLAND  | BRITISH COLUMBIA |      1012475 |        27226 |                        48.42 |                       -123.23 |             1997 |            2020 |
| 39 | ESQUIMALT HARBOUR | BRITISH COLUMBIA |      1012710 |           52 |                        48.43 |                       -123.44 |             1994 |            2020 |
| 49 | KELP REEFS        | BRITISH COLUMBIA |      1013998 |        10853 |                        48.55 |                       -123.24 |             1997 |            2020 |
| 53 | MALAHAT           | BRITISH COLUMBIA |      1014818 |        10730 |                        48.58 |                       -123.58 |             1991 |            1992 |
| 54 | MALAHAT           | BRITISH COLUMBIA |      1014820 |           65 |                        48.57 |                       -123.53 |             1994 |            2020 |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to extract hourly observations from DISCOVERY ISLAND in 2019. So we will select id_stat = 27226, year = 2019 and timeframe = 1 .&lt;/p&gt;

&lt;h3 id=&#34;we-want-to-work-in-csv-format&#34;&gt;- We want to work in csv format.&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;id_stat = 27226
year = 2019
wget.download(&#39;http://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=csv&amp;amp;stationID=&#39;+str(int(id_stat))+&#39;&amp;amp;Year=&#39;+str(year)+&#39;&amp;amp;Month=01&amp;amp;Day=14&amp;amp;timeframe=1&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&#39;en_climate_hourly_BC_1012475_001-2019_P1H.csv&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df = pd.read_csv(&#39;en_climate_hourly_BC_1012475_001-2019_P1H.csv&#39;, sep=&#39;,&#39;, skiprows=0)
df.head(2)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;|    |   Longitude (x) |   Latitude (y) | Station Name     |   Climate ID | Date/Time        |   Year |   Month |   Day | Time   |   Temp (°C) |   Temp Flag |   Dew Point Temp (°C) |   Dew Point Temp Flag |   Rel Hum (%) |   Rel Hum Flag |   Wind Dir (10s deg) |   Wind Dir Flag |   Wind Spd (km/h) |   Wind Spd Flag |   Visibility (km) |   Visibility Flag |   Stn Press (kPa) |   Stn Press Flag |   Hmdx |   Hmdx Flag |   Wind Chill |   Wind Chill Flag |   Weather |
|---:|----------------:|---------------:|:-----------------|-------------:|:-----------------|-------:|--------:|------:|:-------|------------:|------------:|----------------------:|----------------------:|--------------:|---------------:|---------------------:|----------------:|------------------:|----------------:|------------------:|------------------:|------------------:|-----------------:|-------:|------------:|-------------:|------------------:|----------:|
|  0 |         -123.23 |          48.42 | DISCOVERY ISLAND |      1012475 | 2019-01-01 00:00 |   2019 |       1 |     1 | 00:00  |         5.2 |         nan |                   0.7 |                   nan |            73 |            nan |                   17 |             nan |                 5 |             nan |               nan |               nan |            102.87 |              nan |    nan |         nan |          nan |               nan |       nan |
|  1 |         -123.23 |          48.42 | DISCOVERY ISLAND |      1012475 | 2019-01-01 01:00 |   2019 |       1 |     1 | 01:00  |         5.2 |         nan |                   0.7 |                   nan |            72 |            nan |                   17 |             nan |                 5 |             nan |               nan |               nan |            102.87 |              nan |    nan |         nan |          nan |               nan |       nan |
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;url_template = &amp;quot;http://climate.weather.gc.ca/climateData/bulkdata_e.html?format=csv&amp;amp;stationID=5415&amp;amp;Year={year}&amp;amp;Month={month}&amp;amp;timeframe=1&amp;amp;submit=Download+Data&amp;quot;
url_template
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&#39;http://climate.weather.gc.ca/climateData/bulkdata_e.html?format=csv&amp;amp;stationID=5415&amp;amp;Year={year}&amp;amp;Month={month}&amp;amp;timeframe=1&amp;amp;submit=Download+Data&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;if-we-work-in-xml-format&#34;&gt;- If we work in xml format:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tmp_file = wget.download(&#39;http://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=xml&amp;amp;stationID=&#39;+str(int(id_stat))+&#39;&amp;amp;Year=&#39;+str(year)+&#39;&amp;amp;Month=01&amp;amp;Day=14&amp;amp;timeframe=1&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tree=ET.parse(tmp_file)
os.remove(tmp_file)
root=tree.getroot()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the structure of xml file and informations we could find in &amp;lsquo;stationinformation&amp;rsquo; child:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;stationsinfo=root.find(&#39;stationinformation&#39;)

stationsinfo[0].text, &#39;latitude&#39;, stationsinfo[3].text, &#39;longitude&#39;, stationsinfo[4].text
###############################################################
######### stationsinfo[0].text : station name
######### stationsinfo[1].text : province
######### stationsinfo[2].text : provider
######### stationsinfo[3].text : latitude  
######### stationsinfo[4].text : longitude
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(&#39;DISCOVERY ISLAND&#39;, &#39;latitude&#39;, &#39;48.42&#39;, &#39;longitude&#39;, &#39;-123.23&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Climate records are available in &amp;lsquo;station data&amp;rsquo; child:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image2.png&#34; alt=&#34;png&#34; /&gt;
Let&amp;rsquo;s extract Temperature data for one year:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;stationsdata = root.findall(&#39;.//stationdata&#39;)
result = []
for  stationdata in stationsdata    :# loop over hourly values or child 
    champs=stationdata.find(&#39;temp&#39;) 
    tmp=np.array(result,&amp;quot;float&amp;quot;)  
    result.append(champs.text)   
    tmp=np.array(result,&amp;quot;float&amp;quot;)   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To loop over years available for this station:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;id_stat = 27226
yi = 2015
yf =2020
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataset = []
for year in range(yi,yf+1):    ### loop over years
    for month in range(1,13):
        tmp_file = wget.download(&#39;http://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=xml&amp;amp;stationID=&#39;+str(int(id_stat))+&#39;&amp;amp;Year=&#39;+str(year)+&#39;&amp;amp;Month=&#39;+str(month)+&#39;&amp;amp;Day=14&amp;amp;timeframe=1&#39;)
        tree=ET.parse(tmp_file)
        os.remove(tmp_file)
        root=tree.getroot()       
        stationsdata = root.findall(&#39;.//stationdata&#39;)
        temperature = []  
        date  = []
        data  = []
        for  stationdata in stationsdata: 
            date.append(stationdata.attrib[&#39;year&#39;]+
                        &#39;-&#39;+stationdata.attrib[&#39;month&#39;]+
                        &#39;-&#39;+stationdata.attrib[&#39;day&#39;]+ 
                        &#39; &#39;+stationdata.attrib[&#39;hour&#39;]+&#39;:00&#39;)                  
            champs=stationdata.find(&#39;temp&#39;)
            tmp = np.array(champs.text,&amp;quot;float&amp;quot;)
            if  tmp == &#39;nan&#39;:
                temperature.append(np.nan)
            else:   
                temperature.append(tmp)   #  loop over days in one year

        data = {&#39;date&#39;:date, 
                &#39;air_temperature&#39;:temperature} 
        data = pd.DataFrame(data)
        dataset.append(data)
dataset = pd.concat(dataset)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from tabulate import tabulate
print(tabulate(dataset.head(), headers=&#39;keys&#39;, tablefmt=&#39;pipe&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;|    | date          |   air_temperature |
|---:|:--------------|------------------:|
|  0 | 2015-1-1 0:00 |               3   |
|  1 | 2015-1-1 1:00 |               2.9 |
|  2 | 2015-1-1 2:00 |               3   |
|  3 | 2015-1-1 3:00 |               3.1 |
|  4 | 2015-1-1 4:00 |               3.1 |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To save our dataframe into csv format:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataset.to_csv(&amp;quot;./Hourly_dataset.csv&amp;quot;, index = False, header = True, sep = &#39;,&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We Can make  quick plot using  plotly.express:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import plotly.express as px
import plotly
fig = px.line(dataset, x=&#39;date&#39;, y=&#39;air_temperature&#39;)
fig.update_layout(title_text=&#39;Hourly temperature record&#39;,
                  xaxis_rangeslider_visible=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;file1.png&#34; alt=&#34;png&#34; /&gt;
Follow this &lt;a href=&#34;http://www.guillaumedueymes.com/Plotly_plots/file1.html&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt; for interactive plot:&lt;/p&gt;

&lt;p&gt;To save our file in html:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import plotly.io as pio
pio.write_html(fig, file = &#39;file1.html&#39;, auto_open = True)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To save our file in png:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig.write_image(&amp;quot;file1.png&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-working-with-daily-data&#34;&gt;2- Working with daily data:&lt;/h3&gt;

&lt;p&gt;We will do the same job with daily mean temperature for one Climate station:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df_daily.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;|    | Name                   | Province         |   Climate ID |   Station ID |   Latitude (Decimal Degrees) |   Longitude (Decimal Degrees) |   DLY First Year |   DLY Last Year |
|---:|:-----------------------|:-----------------|-------------:|-------------:|-----------------------------:|------------------------------:|-----------------:|----------------:|
|  0 | ACTIVE PASS            | BRITISH COLUMBIA |      1010066 |           14 |                        48.87 |                       -123.28 |             1984 |            1996 |
|  1 | ALBERT HEAD            | BRITISH COLUMBIA |      1010235 |           15 |                        48.4  |                       -123.48 |             1971 |            1995 |
|  2 | BAMBERTON OCEAN CEMENT | BRITISH COLUMBIA |      1010595 |           16 |                        48.58 |                       -123.52 |             1961 |            1980 |
|  3 | BEAR CREEK             | BRITISH COLUMBIA |      1010720 |           17 |                        48.5  |                       -124    |             1910 |            1971 |
|  4 | BEAVER LAKE            | BRITISH COLUMBIA |      1010774 |           18 |                        48.5  |                       -123.35 |             1894 |            1952 |
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tmp_file = wget.download(&#39;http://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=xml&amp;amp;stationID=&#39;+str(int(id_stat))+&#39;&amp;amp;Year=&#39;+str(year)+&#39;&amp;amp;Month=01&amp;amp;Day=14&amp;amp;timeframe=2&#39;)
tree=ET.parse(tmp_file)
os.remove(tmp_file)
root=tree.getroot()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the structure of xml file and informations we could find in &amp;lsquo;stationinformation&amp;rsquo; child:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Climate records are available in &amp;lsquo;station data&amp;rsquo; child:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image3.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;url_template = &#39;http://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=xml&amp;amp;stationID=&#39;+str(int(id_stat))+&#39;&amp;amp;Year=&#39;+str(year)+&#39;&amp;amp;Month=01&amp;amp;Day=14&amp;amp;timeframe=2&#39;
url_template
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&#39;http://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=xml&amp;amp;stationID=5415&amp;amp;Year=2020&amp;amp;Month=01&amp;amp;Day=14&amp;amp;timeframe=2&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to extract 4 specific years for Climate station with ID=27226:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;id_stat = 27226
df_daily[df_daily[&#39;Station ID&#39;] == id_stat][&#39;DLY First Year&#39;]
yi = 2015
yf = 2020
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataset = []
for year in range(yi,yf+1):    ### loop over years
        tmp_file = wget.download(&#39;http://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=xml&amp;amp;stationID=&#39;+str(int(id_stat))+&#39;&amp;amp;Year=&#39;+str(year)+&#39;&amp;amp;Month=1&amp;amp;Day=14&amp;amp;timeframe=2&#39;)
        tree=ET.parse(tmp_file)
        os.remove(tmp_file)
        root=tree.getroot()       
        stationsdata = root.findall(&#39;.//stationdata&#39;)
        temperature = []  
        date  = []
        data  = []
        for  stationdata in stationsdata: 
            date.append(stationdata.attrib[&#39;year&#39;]+
                        &#39;-&#39;+stationdata.attrib[&#39;month&#39;]+
                        &#39;-&#39;+stationdata.attrib[&#39;day&#39;])                  
            champs=stationdata.find(&#39;meantemp&#39;)
            tmp = np.array(champs.text,&amp;quot;float&amp;quot;)
            if  tmp == &#39;nan&#39;:
                temperature.append(np.nan)
            else:   
                temperature.append(tmp)   #  loop over days in one year

        data = {&#39;date&#39;:date, 
                &#39;temperature&#39;:temperature} 
        data = pd.DataFrame(data)
        dataset.append(data)
dataset = pd.concat(dataset)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataset.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;|    | date     |   temperature |
|---:|:---------|--------------:|
|  0 | 2015-1-1 |           nan |
|  1 | 2015-1-2 |           nan |
|  2 | 2015-1-3 |           nan |
|  3 | 2015-1-4 |           nan |
|  4 | 2015-1-5 |           nan |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We Can make  quick plot using  plotly.express:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import plotly.express as px
fig = px.line(dataset, x=&#39;date&#39;, y=&#39;temperature&#39;)
fig.update_layout(title_text=&#39;Time Series with Rangeslider&#39;,
                  xaxis_rangeslider_visible=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;file2.png&#34; alt=&#34;png&#34; /&gt;
Follow this &lt;a href=&#34;http://www.guillaumedueymes.com/Plotly_plots/file2.html&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt; for interactive plot:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataset.to_csv(&amp;quot;./Daily_dataset.csv&amp;quot;, index = False, header = True, sep = &#39;,&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import plotly.io as pio
pio.write_html(fig, file = &#39;file2.html&#39;, auto_open = True)
fig.write_image(&amp;quot;file2.png&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-working-with-monthly-data&#34;&gt;3- Working with monthly data:&lt;/h3&gt;

&lt;p&gt;We will do the same job with monthly total precipitation for one Climate station:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df_monthly.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;|    | Name                   | Province         |   Climate ID |   Station ID |   Latitude (Decimal Degrees) |   Longitude (Decimal Degrees) |   MLY First Year |   MLY Last Year |
|---:|:-----------------------|:-----------------|-------------:|-------------:|-----------------------------:|------------------------------:|-----------------:|----------------:|
|  0 | ACTIVE PASS            | BRITISH COLUMBIA |      1010066 |           14 |                        48.87 |                       -123.28 |             1984 |            1996 |
|  1 | ALBERT HEAD            | BRITISH COLUMBIA |      1010235 |           15 |                        48.4  |                       -123.48 |             1971 |            1995 |
|  2 | BAMBERTON OCEAN CEMENT | BRITISH COLUMBIA |      1010595 |           16 |                        48.58 |                       -123.52 |             1961 |            1980 |
|  3 | BEAR CREEK             | BRITISH COLUMBIA |      1010720 |           17 |                        48.5  |                       -124    |             1910 |            1971 |
|  4 | BEAVER LAKE            | BRITISH COLUMBIA |      1010774 |           18 |                        48.5  |                       -123.35 |             1894 |            1952 |
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tmp_file = wget.download(&#39;http://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=xml&amp;amp;stationID=&#39;+str(int(id_stat))+&#39;&amp;amp;Year=&#39;+str(year)+&#39;&amp;amp;Month=01&amp;amp;Day=14&amp;amp;timeframe=3&#39;)
url_template = &#39;http://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=xml&amp;amp;stationID=&#39;+str(int(id_stat))+&#39;&amp;amp;Year=&#39;+str(year)+&#39;&amp;amp;Month=01&amp;amp;Day=14&amp;amp;timeframe=3&#39;
url_template
tree=ET.parse(tmp_file)
os.remove(tmp_file)
root=tree.getroot()
url_template
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&#39;http://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=xml&amp;amp;stationID=27226&amp;amp;Year=2020&amp;amp;Month=01&amp;amp;Day=14&amp;amp;timeframe=3&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Climate records are available in &amp;lsquo;station data&amp;rsquo; child:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image4.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We want to dowload monthly total precipitation for Climate station with ID=5415.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;id_stat = 5415
df_monthly[df_monthly[&#39;Station ID&#39;] == id_stat][&#39;MLY First Year&#39;]
yi = int(df_monthly[df_monthly[&#39;Station ID&#39;] == id_stat][&#39;MLY First Year&#39;].values)
yf = int(df_monthly[df_monthly[&#39;Station ID&#39;] == id_stat][&#39;MLY Last Year&#39;].values)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataset = []

tmp_file = wget.download(&#39;http://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=xml&amp;amp;stationID=&#39;+str(int(id_stat))+&#39;&amp;amp;Year=2020&amp;amp;Month=1&amp;amp;Day=14&amp;amp;timeframe=3&#39;)
tree=ET.parse(tmp_file)
os.remove(tmp_file)
root=tree.getroot()       
stationsdata = root.findall(&#39;.//stationdata&#39;)
totprecip = []  
date  = []
data  = []
for  stationdata in stationsdata: 
    date.append(stationdata.attrib[&#39;year&#39;]+
                        &#39;-&#39;+stationdata.attrib[&#39;month&#39;])                  
    champs=stationdata.find(&#39;totprecip&#39;)
    tmp = np.array(champs.text,&amp;quot;float&amp;quot;)
    if  tmp == &#39;nan&#39;:
        totprecip.append(np.nan)
    else:   
        totprecip.append(tmp)   #  loop over days in one year

    data = {&#39;date&#39;:date, 
                &#39;totprecip&#39;:totprecip} 
    data = pd.DataFrame(data)
    dataset.append(data)
dataset = pd.concat(dataset)
dataset = dataset.drop_duplicates(&#39;date&#39;,keep=&#39;last&#39;)
dataset[&#39;date&#39;]  = pd.to_datetime(dataset[&#39;date&#39;], format=&#39;%Y-%m&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import plotly.graph_objects as go
fig = go.Figure(data=[
    go.Bar(name=&#39;totprecip1&#39;, 
           x=dataset[dataset[&#39;date&#39;].dt.month == 7][&#39;date&#39;], 
           y=dataset[dataset[&#39;date&#39;].dt.month == 7][&#39;totprecip&#39;])    
])
fig.update_layout(
    title=&#39;July monthly precipitation&#39;,
    xaxis_tickfont_size=14,
    yaxis=dict(
        title=&#39;Total precipitation (mm)&#39;,
        titlefont_size=16,
        tickfont_size=14,
    ),
    barmode=&#39;group&#39;,
    bargap=0.15, # gap between bars of adjacent location coordinates.
    bargroupgap=0.1 # gap between bars of the same location coordinate.
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;file3.png&#34; alt=&#34;png&#34; /&gt;
Follow this &lt;a href=&#34;http://www.guillaumedueymes.com/Plotly_plots/file3.html&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt; for interactive plot.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataset[dataset[&#39;date&#39;].dt.month == 7].to_csv(&amp;quot;./Monthly_dataset.csv&amp;quot;, index = False, header = True, sep = &#39;,&#39;)
import plotly.io as pio
pio.write_html(fig, file = &#39;file2.html&#39;, auto_open = True)
fig.write_image(&amp;quot;file2.png&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Netcdf select closest gridpoints</title>
      <link>/post/ckdtree_netcdf/</link>
      <pubDate>Wed, 26 Feb 2020 13:10:29 -0800</pubDate>
      <guid>/post/ckdtree_netcdf/</guid>
      <description>

&lt;p&gt;﻿&lt;/p&gt;

&lt;h2 id=&#34;netcdf-select-closest-points-using-ckdtree&#34;&gt;- Netcdf: Select closest points using CKDTree&lt;/h2&gt;

&lt;p&gt;In this post, we are going to define an algorithm to locate the closest points to a reference point, by using coordinate transformations, k-dimensional trees, and xarray pointwise indexing.&lt;/p&gt;

&lt;p&gt;To select closest grid points, we will use here one approach using &lt;a href=&#34;http://docs.scipy.org/doc/scipy-0.12.0/reference/generated/scipy.spatial.cKDTree.html&#34; target=&#34;_blank&#34;&gt;cKDTree&lt;/a&gt; class from scipy.spatial package.&lt;/p&gt;

&lt;p&gt;Different method are considered here:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- nearest neighbour
- nearest neighbours, weighting with the inverse of distance squared: 
- 
\begin{equation*}
$T_t = \frac{\sum_{i=1}^{m}T_{s,i}w_i}{\sum_{i=1}^{m}w_i}$, $w_i = 1/d_i^2$)
\end{equation*}

- query ball point : Find all pairs of points whose distance is at most one distance
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-let-s-import-python-librairies&#34;&gt;1- Let&amp;rsquo;s import Python librairies&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#for Netcdf manipulation
#import netCDF4
#from netCDF4 import Dataset
import xarray as xr

#for array manipulation
import numpy as np
import pandas as pd

#for plotting
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import matplotlib.pylab as plt

#for interpolation
from scipy.spatial import cKDTree
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-loading-netcdf-files&#34;&gt;2- Loading Netcdf files&lt;/h3&gt;

&lt;p&gt;We are going to use daily ERA5 reanalysis data from April 1st to 31th of october 2018.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;unique_dataDIR = &#39;K:/PROJETS/PROJET_FIRE_INDEX/ERA5_FWI_Netcdf/ERA5_FWI_QC_SNOW_New_2018_from_4_to_8.nc&#39;
TAS = xr.open_dataset(unique_dataDIR)
TAS.lon.shape, TAS.lat.shape,
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;((121,), (77,))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Regrid 1D latitude and longitude to 2D grid.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lon2d, lat2d = np.meshgrid(TAS.lon, TAS.lat)
lon2d.shape, lat2d.shape
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;((77, 121), (77, 121))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s have a quick look at our dataset, we will plot one day in our time range:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(12,6))
ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-75,-60,50,52])
ax.coastlines(resolution=&#39;110m&#39;);
ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))      
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))       
ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))     
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))    
ax.add_feature(cfeature.RIVERS.with_scale(&#39;50m&#39;))    
coast = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, scale=&#39;10m&#39;,    
                        facecolor=&#39;none&#39;, name=&#39;coastline&#39;)
ax.add_feature(coast, edgecolor=&#39;black&#39;)

states_provinces = cfeature.NaturalEarthFeature(
        category=&#39;cultural&#39;,
        name=&#39;admin_1_states_provinces_lines&#39;,
        scale=&#39;10m&#39;,
        facecolor=&#39;none&#39;)

ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;)

cmap0=plt.cm.jet
cmap0.set_under(&#39;darkblue&#39;) 
cmap0.set_over(&#39;darkred&#39;) 

mm = ax.contourf(TAS.lon,\
                   TAS.lat,\
                   TAS.sel(time=&#39;2018-08-01&#39;).FWI,\
                   vmin=0,\
                   vmax=20, \
                   transform=ccrs.PlateCarree(),\
                   levels=np.arange(0, 20, 1.0),\
                   cmap=cmap0 )
ax.scatter(lon2d, lat2d, transform=ccrs.PlateCarree(), s=5)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.collections.PathCollection at 0xc7d6828&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_8_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The blue dots in the plot identify the grid points.&lt;/p&gt;

&lt;p&gt;What we want to achieve is to come up with a way to compare distances between a reference point (defined by latitude and longitude values), and all grid points, and pick the minimum value.&lt;/p&gt;

&lt;p&gt;But first, we need to measure distances between two points on our planet, given their geodetic (latitude/longitude/altitude) coordinates.&lt;/p&gt;

&lt;p&gt;In this post, we are going to use the cartesian or ECEF (“earth-centered, earth-fixed”) geographic coordinate system, which represents positions (in meters) as X, Y, and Z coordinates, approximating the earth surface as an ellipsoid of revolution (close enough for our purposes).&lt;/p&gt;

&lt;p&gt;Once we convert our latitude/longitude coordinates to cartesian coordinates, measuring the distance between two points is as simple as computing the Euclidean distance between them.&lt;/p&gt;

&lt;p&gt;The conversion between cartesian and geodetic coordinates latitude, longitude is done according to:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.codecogs.com/eqnedit.php?latex=\begin{bmatrix}&amp;space;X\\&amp;space;Y\\&amp;space;Z&amp;space;\end{bmatrix}&amp;space;=&amp;space;\begin{bmatrix}&amp;space;r.\cos&amp;space;\phi&amp;space;.\cos&amp;space;\lambda&amp;space;\\&amp;space;r.\cos&amp;space;\phi&amp;space;.\sin&amp;space;\lambda&amp;space;\\&amp;space;(1-e^{2}))r.\sin&amp;space;\phi&amp;space;\end{bmatrix}&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://latex.codecogs.com/gif.latex?\begin{bmatrix}&amp;space;X\\&amp;space;Y\\&amp;space;Z&amp;space;\end{bmatrix}&amp;space;=&amp;space;\begin{bmatrix}&amp;space;r.\cos&amp;space;\phi&amp;space;.\cos&amp;space;\lambda&amp;space;\\&amp;space;r.\cos&amp;space;\phi&amp;space;.\sin&amp;space;\lambda&amp;space;\\&amp;space;(1-e^{2}))r.\sin&amp;space;\phi&amp;space;\end{bmatrix}&#34; title=&#34;\begin{bmatrix} X\\ Y\\ Z \end{bmatrix} = \begin{bmatrix} r.\cos \phi .\cos \lambda \\ r.\cos \phi .\sin \lambda \\ (1-e^{2}))r.\sin \phi \end{bmatrix}&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Where &lt;a href=&#34;https://www.codecogs.com/eqnedit.php?latex=r&amp;space;=&amp;space;\frac{a}{\sqrt{1-e^2&amp;space;sin^2&amp;space;\phi&amp;space;}}&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://latex.codecogs.com/gif.latex?r&amp;space;=&amp;space;\frac{a}{\sqrt{1-e^2&amp;space;sin^2&amp;space;\phi&amp;space;}}&#34; title=&#34;r = \frac{a}{\sqrt{1-e^2 sin^2 \phi }}&#34; /&gt;&lt;/a&gt;    is the local curvature of the ellipsoid along the first vertical, and where e, the first eccentricity, and a, the semi-major axis, are the parameters defining the ellipsoid.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Finding the closest&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Our problem falls into the class of nearest neighbour searches. A common approach when it comes to finding the nearest neighbour in a number of points with k dimensions is to use a KD-tree, or k-dimensional tree.
SciPy library provides a very efficient KD-tree implementation . Once we have constructed our tree, all we have to do is to populate it with a (n,m) shaped array of points and then query it the nearest neighbor to a reference point.&lt;/p&gt;

&lt;p&gt;We will have to make use of some NumPy acrobatics to reshape our data structures from a two-dimensional grid to a one-dimensional array, and to convert the returned one-dimensional index to a set of two indices on our original grid.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class KDTreeIndex():    
    &amp;quot;&amp;quot;&amp;quot; A KD-tree implementation for fast point lookup on a 2D grid
    
    Keyword arguments: 
    dataset -- a xarray DataArray containing lat/lon coordinates
               (named &#39;lat&#39; and &#39;lon&#39; respectively)               
    &amp;quot;&amp;quot;&amp;quot;    
    def transform_coordinates(self, coords):
        &amp;quot;&amp;quot;&amp;quot; Transform coordinates from geodetic to cartesian
        
        Keyword arguments:
        coords - a set of lan/lon coordinates (e.g. a tuple or 
                 an array of tuples)
        &amp;quot;&amp;quot;&amp;quot;
        # WGS 84 reference coordinate system parameters
        A = 6378.137 # major axis [km]   
        E2 = 6.69437999014e-3 # eccentricity squared    
        
        coords = np.asarray(coords).astype(np.float)
        
        # is coords a tuple? Convert it to an one-element array of tuples
        if coords.ndim == 1:
            coords = np.array([coords])
        
        # convert to radiants
        lat_rad = np.radians(coords[:,0])
        lon_rad = np.radians(coords[:,1]) 
        
        # convert to cartesian coordinates
        r_n = A / (np.sqrt(1 - E2 * (np.sin(lat_rad) ** 2)))
        x = r_n * np.cos(lat_rad) * np.cos(lon_rad)
        y = r_n * np.cos(lat_rad) * np.sin(lon_rad)
        z = r_n * (1 - E2) * np.sin(lat_rad)
        
        return np.column_stack((x, y, z))
    
    def __init__(self, dataset):
        # store original dataset shape
        self.shape = dataset.shape
        lon2d, lat2d = np.meshgrid(dataset.lon, dataset.lat)
        # reshape and stack coordinates
        coords = np.column_stack((lat2d.ravel(),
                                  lon2d.ravel()))
        
        # construct KD-tree
        self.tree = cKDTree(self.transform_coordinates(coords))
        
    def query(self, point, k):
        &amp;quot;&amp;quot;&amp;quot; Query the kd-tree for nearest neighbour.
        Keyword arguments:
        point -- a (lat, lon) tuple or array of tuples
        &amp;quot;&amp;quot;&amp;quot;
        d, inds  = self.tree.query(self.transform_coordinates(point),k=k)
        w = 1.0 / d**2
        # regrid to 2D grid
        indslatlon = np.unravel_index(inds, self.shape)
        return d, inds, w, indslatlon
    
    def query_ball_point(self, point, radius):
        &amp;quot;&amp;quot;&amp;quot; Query the kd-tree for all point within distance 
        radius of point(s) x
        
        Keyword arguments:
        point -- a (lat, lon) tuple or array of tuples
        radius -- the search radius (km)
        &amp;quot;&amp;quot;&amp;quot;
        
        index = self.tree.query_ball_point(self.transform_coordinates(point),
                                           radius)

        # regrid to 2D grid 
        index = np.unravel_index(index[0], self.shape)
        
        # return DataArray indexers
        return xr.DataArray(index[0], dims=&#39;lat&#39;), \
               xr.DataArray(index[1], dims=&#39;lon&#39;)
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will construct our cKDTree object using one time step from our xarray.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;latlon_tree = KDTreeIndex(TAS.sel(time=&#39;2018-08-01&#39;).FWI)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now query the tree the nearest grid point to one reference point:&lt;/p&gt;

&lt;h3 id=&#34;3-nearest-neighbour-k-1&#34;&gt;3- Nearest neighbour k=1:&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s select reference point defined by:
    - latitude = 50 degN
    - longitude = -68.1461 degE&lt;/p&gt;

&lt;p&gt;We can now query the tree the nearest point :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;site = (50, -68.1461)
d, inds, w, indslatlon = latlon_tree.query(site, k=1)
print(inds)
print(indslatlon)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[5871]
(array([48], dtype=int64), array([63], dtype=int64))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;latpt = indslatlon[0][0]
lonpt = indslatlon[1][0]
print(latpt, lonpt)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;48 63
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The query method actually  returns:
- two array objects a latitude and a longitude indexer
- one 1D indexer
- one distance value
- one corresponding weighting.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*inds value (ie 5871) represents the index found for our one-dimensional array. 

*indslatlon are the corresponding longitude and latitude values for the closest point found.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To extract the xarray field value using our previous index, first we need to convert a two-dimensional grid to a one-dimensional array and then select index value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;TAS.sel(time=&#39;2018-08-01&#39;).FWI.values.flatten()[inds]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;array([10.517308])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;TAS.sel(time=&#39;2018-08-01&#39;).FWI[latpt,lonpt]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray &#39;FWI&#39; ()&amp;gt;
array(10.517308)
Coordinates:
    lon      float64 -68.25
    lat      float32 50.0
    time     datetime64[ns] 2018-08-01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s make a quick look:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(25,12))
ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-72,-65,49,51])
   # ax.coastlines(resolution=&#39;110m&#39;);
ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))      # couche ocean
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))       # couche land
ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))      # couche lac    
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))    # couche frontieres
ax.add_feature(cfeature.RIVERS.with_scale(&#39;50m&#39;))     # couche rivières 
coast = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, scale=&#39;10m&#39;,     # ajout de la couche cotière 
                        facecolor=&#39;none&#39;, name=&#39;coastline&#39;)
ax.add_feature(coast, edgecolor=&#39;black&#39;)

  
states_provinces = cfeature.NaturalEarthFeature(
        category=&#39;cultural&#39;,
        name=&#39;admin_1_states_provinces_lines&#39;,
        scale=&#39;10m&#39;,
        facecolor=&#39;none&#39;)

ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;)

## Choisissons une colormap
cmap0=plt.cm.jet
cmap0.set_under(&#39;darkblue&#39;) ## on met en blanc les valeurs inferieures au min de clev
cmap0.set_over(&#39;darkred&#39;) ## bleu fonce pour les valeurs extremes de pluie

mm = ax.contourf(TAS.lon,\
                   TAS.lat,\
                   TAS.sel(time=&#39;2018-08-01&#39;).FWI,\
                   vmin=0,\
                   vmax=20, \
                   transform=ccrs.PlateCarree(),\
                   levels=np.arange(0, 20, 1.0),\
                   cmap=cmap0 )
ax.scatter(lon2d, lat2d, transform=ccrs.PlateCarree(), s=5, label=&#39;ERA5 grid points&#39;)
ax.scatter(TAS.sel(time=&#39;2018-08-01&#39;).FWI[latpt,lonpt].lon, 
           TAS.sel(time=&#39;2018-08-01&#39;).FWI[latpt,lonpt].lat, 
           color=&#39;r&#39;, transform=ccrs.PlateCarree(), s=100, label=&#39;closest grid point&#39;)
ax.scatter(-68.1461, 50, transform=ccrs.PlateCarree(), marker=&#39;x&#39;, color=&#39;black&#39;, s=300, label=&#39;reference point&#39;)
plt.legend(loc=&#39;upper left&#39;, numpoints=1, ncol=3, fontsize=20)

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.legend.Legend at 0xc7d6358&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_22_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-nearest-neighbours-k-10&#34;&gt;4- Nearest neighbours k=10&lt;/h3&gt;

&lt;p&gt;We will now make the same exercice using k=10.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;site = (50, -68.1461)
d, inds, w, indslatlon = ground_pixel_tree.query(site, k=10)
print(d)
print(w)
print(inds)
print(indslatlon)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[[ 7.44918778 10.47474677 25.37308687 28.39863145 28.78330094 28.79213291
  29.70566615 29.72368634 37.59953757 37.68733316]]
[[0.01802114 0.00911408 0.00155329 0.00123995 0.00120703 0.00120629
  0.00113324 0.00113187 0.00070735 0.00070406]]
[[5871 5872 5870 5873 5750 5992 5751 5993 5749 5991]]
(array([[48, 48, 48, 48, 47, 49, 47, 49, 47, 49]], dtype=int64), array([[63, 64, 62, 65, 63, 63, 64, 64, 62, 62]], dtype=int64))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;TAS.sel(time=&#39;2018-08-01&#39;).FWI.values.flatten()[inds]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;array([[10.517308  ,  9.87137321,  8.57146189, 11.99096501,  9.32552318,
        10.0954969 ,  9.84150618, 11.8046335 ,  9.26170112,  8.3454113 ]])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;latpts = indslatlon[0][0]
lonpts = indslatlon[1][0]
print(latpts, lonpts)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[48 48 48 48 47 49 47 49 47 49] [63 64 62 65 63 63 64 64 62 62]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can know Interpolate our field using inverse distance weighting, using 10 nearest neighbours (k=10):&lt;/p&gt;

&lt;p&gt;(i.e. Tt=∑mi=1Ts,iwi∑mi=1wi, wi=1/d2i).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;np.sum(w * TAS.sel(time=&#39;2018-08-01&#39;).FWI.values.flatten()[inds], axis=1) / np.sum(w, axis=1)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;array([10.21868978])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s make a quick look:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;latpts = indslatlon[0][0]
lonpts = indslatlon[1][0]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;TAS.sel(time=&#39;2018-08-01&#39;).FWI[latpts,lonpts].lon
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray &#39;lon&#39; (lon: 10)&amp;gt;
array([-68.25, -68.  , -68.5 , -67.75, -68.25, -68.25, -68.  , -68.  , -68.5 ,
       -68.5 ])
Coordinates:
  * lon      (lon) float64 -68.25 -68.0 -68.5 -67.75 ... -68.0 -68.0 -68.5 -68.5
    time     datetime64[ns] 2018-08-01
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(25,12))
ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-72,-65,49,51])
   # ax.coastlines(resolution=&#39;110m&#39;);
ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))      # couche ocean
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))       # couche land
ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))      # couche lac    
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))    # couche frontieres
ax.add_feature(cfeature.RIVERS.with_scale(&#39;50m&#39;))     # couche rivières 
coast = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, scale=&#39;10m&#39;,     # ajout de la couche cotière 
                        facecolor=&#39;none&#39;, name=&#39;coastline&#39;)
ax.add_feature(coast, edgecolor=&#39;black&#39;)

  
states_provinces = cfeature.NaturalEarthFeature(
        category=&#39;cultural&#39;,
        name=&#39;admin_1_states_provinces_lines&#39;,
        scale=&#39;10m&#39;,
        facecolor=&#39;none&#39;)

ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;)

## Choisissons une colormap
cmap0=plt.cm.jet
cmap0.set_under(&#39;darkblue&#39;) ## on met en blanc les valeurs inferieures au min de clev
cmap0.set_over(&#39;darkred&#39;) ## bleu fonce pour les valeurs extremes de pluie

mm = ax.contourf(TAS.lon,\
                   TAS.lat,\
                   TAS.sel(time=&#39;2018-08-01&#39;).FWI,\
                   vmin=0,\
                   vmax=20, \
                   transform=ccrs.PlateCarree(),\
                   levels=np.arange(0, 20, 1.0),\
                   cmap=cmap0 )
ax.scatter(lon2d, lat2d, transform=ccrs.PlateCarree(), s=5, label=&#39;ERA5 grid points&#39;)
ax.scatter(TAS.sel(time=&#39;2018-08-01&#39;).FWI[latpts,lonpts].lon, 
           TAS.sel(time=&#39;2018-08-01&#39;).FWI[latpts,lonpts].lat, 
           color=&#39;r&#39;, transform=ccrs.PlateCarree(), s=100, label=&#39;closest grid points&#39;)
ax.scatter(-68.1461, 50, transform=ccrs.PlateCarree(), marker=&#39;x&#39;, color=&#39;black&#39;, s=300, label=&#39;reference point&#39;)
plt.legend(loc=&#39;upper left&#39;, numpoints=1, ncol=3, fontsize=20)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.legend.Legend at 0xcb78ac8&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_32_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now we will find all grid points  within a given distance from a reference point, by using the query_ball_point method in SciPy’s KD-tree implementation.&lt;/p&gt;

&lt;p&gt;Let’s find out which ground pixels fall into a 700km radius from our reference point:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ball_point_index = ground_pixel_tree.query_ball_point(site, 50)
lons = TAS.sel(time=&#39;2018-08-01&#39;).FWI[ball_point_index].lon
lats = TAS.sel(time=&#39;2018-08-01&#39;).FWI[ball_point_index].lat
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(25,12))
ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-72,-65,49,51])
   # ax.coastlines(resolution=&#39;110m&#39;);
ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))      # couche ocean
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))       # couche land
ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))      # couche lac    
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))    # couche frontieres
ax.add_feature(cfeature.RIVERS.with_scale(&#39;50m&#39;))     # couche rivières 
coast = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, scale=&#39;10m&#39;,     # ajout de la couche cotière 
                        facecolor=&#39;none&#39;, name=&#39;coastline&#39;)
ax.add_feature(coast, edgecolor=&#39;black&#39;)

  
states_provinces = cfeature.NaturalEarthFeature(
        category=&#39;cultural&#39;,
        name=&#39;admin_1_states_provinces_lines&#39;,
        scale=&#39;10m&#39;,
        facecolor=&#39;none&#39;)

ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;)

## Choisissons une colormap
cmap0=plt.cm.jet
cmap0.set_under(&#39;darkblue&#39;) ## on met en blanc les valeurs inferieures au min de clev
cmap0.set_over(&#39;darkred&#39;) ## bleu fonce pour les valeurs extremes de pluie

mm = ax.contourf(TAS.lon,\
                   TAS.lat,\
                   TAS.sel(time=&#39;2018-08-01&#39;).FWI,\
                   vmin=0,\
                   vmax=20, \
                   transform=ccrs.PlateCarree(),\
                   levels=np.arange(0, 20, 1.0),\
                   cmap=cmap0 )
ax.scatter(lon2d, lat2d, transform=ccrs.PlateCarree(), s=5, label=&#39;ERA5 grid points&#39;)
ax.scatter(lons, 
           lats, 
           color=&#39;r&#39;, transform=ccrs.PlateCarree(), s=100, label=&#39;grid points within 50 km from reference point&#39;)
ax.scatter(-68.1461, 50, transform=ccrs.PlateCarree(), marker=&#39;x&#39;, color=&#39;black&#39;, s=300, label=&#39;reference point&#39;)
plt.legend(loc=&#39;upper left&#39;, numpoints=1, ncol=3, fontsize=20)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.legend.Legend at 0xcb86b38&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_35_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ECCC SWOB Stations</title>
      <link>/post/ecc_swob_stations/</link>
      <pubDate>Tue, 18 Feb 2020 13:06:38 -0800</pubDate>
      <guid>/post/ecc_swob_stations/</guid>
      <description>

&lt;p&gt;﻿In this post, we will show how to work with Surface Weather Observation from ECCC in XML language (Extensible Markup Language)&lt;/p&gt;

&lt;h3 id=&#34;sw-ob-xml&#34;&gt;SW-OB-XML&lt;/h3&gt;

&lt;p&gt;For xml files, we will use a package called xml which will allow us to decrypt the xml file.&lt;/p&gt;

&lt;p&gt;Pandas does not directly have tools to transform xml into DataFrame because the semi-structured aspect of xml forces us to perform a few steps before filling out a DataFrame.&lt;/p&gt;

&lt;p&gt;We will first download &lt;a href=&#34;https://dd.weather.gc.ca/observations/doc/&#34; target=&#34;_blank&#34;&gt;an xml file&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We are going to work here with the meteorological ground (SWOB-ML) and marine observations data found on the ECCC Datamart.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Data are available at the following links:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Earth observations:
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://dd.meteo.gc.ca/observations/swob-ml/AAAAMMJJ/XXXX/&#34; target=&#34;_blank&#34;&gt;https://dd.meteo.gc.ca/observations/swob-ml/AAAAMMJJ/XXXX/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Where:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AAAAMMJJ: observations date, UTC&lt;/li&gt;

&lt;li&gt;&lt;p&gt;XXXX: station ID (OMM ID)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;h2 id=&#34;marine-observations&#34;&gt;Marine observations:&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://dd.meteo.gc.ca/observations/swob-ml/marine/moored-buoys/YYYMMDD/XXXXXXX&#34; target=&#34;_blank&#34;&gt;https://dd.meteo.gc.ca/observations/swob-ml/marine/moored-buoys/YYYMMDD/XXXXXXX&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Where:
* AAAAMMJJ: observations date, UTC
* XXXXXXX: station ID (OMM ID), can be 5 or 7 digits&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Partner observations:
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://dd.meteo.gc.ca/observations/swob-ml/partners/NETWORK/YYYMMDD/MSC-ID&#34; target=&#34;_blank&#34;&gt;https://dd.meteo.gc.ca/observations/swob-ml/partners/NETWORK/YYYMMDD/MSC-ID&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Where:
 - NETWORK: acronym of the partner network
 - YYYYMMDD: observations date, UTC
 - MSC-ID: ID&lt;/p&gt;

&lt;p&gt;################################################&lt;/p&gt;

&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;

&lt;p&gt;################################################&lt;/p&gt;

&lt;p&gt;The markup language for ground weather (SWOB Met-ML) and marine observations is an XML format for the distribution of weather data observed by Environment and Climate Change Canada and its partners.&lt;/p&gt;

&lt;p&gt;The list of observation stations is available here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dd.meteo.gc.ca/observations/doc/swob-xml_station_list.csv&#34; target=&#34;_blank&#34;&gt;https://dd.meteo.gc.ca/observations/doc/swob-xml_station_list.csv&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The list of marine observation stations is available here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dd.meteo.gc.ca/observations/doc/swob-xml_marine_station_list.csv&#34; target=&#34;_blank&#34;&gt;https://dd.meteo.gc.ca/observations/doc/swob-xml_marine_station_list.csv&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The list of partner stations is available here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dd.meteo.gc.ca/observations/doc/swob-xml_partner_station_list.csv&#34; target=&#34;_blank&#34;&gt;https://dd.meteo.gc.ca/observations/doc/swob-xml_partner_station_list.csv&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The format specification is available in the following directory:
&lt;a href=&#34;https://dd.meteo.gc.ca/observations/doc/&#34; target=&#34;_blank&#34;&gt;https://dd.meteo.gc.ca/observations/doc/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here is the structure of a SWOB file:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./struc_swob.png&#34; alt=&#34;Indentation&#34; width=&#34;100%&#34; height=&#34;100%&#34;&gt;&lt;/p&gt;

&lt;p&gt;First, we import python librairies and define the date we want to extract:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# importations des librairies 
from datetime import datetime, timedelta
import pandas as pd 
import xml.etree.ElementTree as ET
import wget
import warnings
warnings.filterwarnings(&amp;quot;ignore&amp;quot;)
import os 
from os.path import exists
now = datetime.utcnow() - timedelta(hours=1)

year = str(now.year)
month = str(now.month)
day = str(now.day)
hour = f&#39;{now.hour:02d}&#39;
day = f&#39;{now.day:02d}&#39;
month = f&#39;{now.month:02d}&#39;
date = year+month+day
date
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&#39;20200212&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will list the stations we want to extract: example for the province of Quebec and Ontario.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;stations = pd.read_table(&amp;quot;swob-xml_station_list.csv&amp;quot;, sep=&amp;quot;,&amp;quot;)
stations_quebec = stations.loc[(stations[&amp;quot;Province/Territory&amp;quot;]==&#39;Quebec&#39;)  ,:]
stations_ontario = stations.loc[(stations[&amp;quot;Province/Territory&amp;quot;]==&#39;Ontario&#39;)  ,:]
stations_mask=pd.concat([stations_quebec,stations_ontario],axis=0)
stations_mask_sans_NaN = stations_mask.dropna() 
#stations_mask_sans_NaN_AUTO = stations_mask_sans_NaN.loc[stations_mask_sans_NaN[&amp;quot;AUTO/MAN&amp;quot;]==&#39;AUTO&#39;,:]
stations_mask_sans_NaN.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;IATA_ID&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;WMO_ID&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;MSC_ID&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Latitude&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Longitude&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Elevation(m)&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Data_Provider&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Dataset/Network&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;AUTO/MAN&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Province/Territory&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;48&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGAH&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;LA GRANDE IV&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;71823&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7093GJ5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;53.75&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-73.6828&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;306.3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;49&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGBC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;BAIE-COMEAU&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;71890&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7040442&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49.1351&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-68.2024&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;22.6&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;50&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGCH&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CHIBOUGAMAU-CHAPAIS&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;73011&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7091410&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49.7773&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-74.5304&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;389.3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;51&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGCL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CAUSAPSCAL AIRPORT&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;73005&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7051201&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;48.3088&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-67.2528&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;123&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;52&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGGA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;GASPE AIRPORT&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;73116&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7052603&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;48.7833&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-64.4833&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;40&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;1-working-with-one-station&#34;&gt;1- Working with one station&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s work with  CWTQ station ID:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import requests
stid = &#39;CWTQ&#39;
tmp_file = &#39;https://dd.weather.gc.ca/observations/swob-ml/&#39;+date+&#39;/&#39;+stid+&#39;/&#39;+year+&#39;-&#39;+month+&#39;-&#39;+day+&#39;-&#39;+hour+&#39;00-&#39;+stid+&#39;-AUTO-swob.xml&#39;
tmp_file
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&#39;https://dd.weather.gc.ca/observations/swob-ml/20200212/CWTQ/2020-02-12-1900-CWTQ-AUTO-swob.xml&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;wget.download(tmp_file)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;100% [............................................................] 9408 / 9408




&#39;2020-02-12-1900-CWTQ-AUTO-swob.xml&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tree = ET.parse(year+&#39;-&#39;+month+&#39;-&#39;+day+&#39;-&#39;+hour+&#39;00-&#39;+stid+&#39;-AUTO-swob.xml&#39;)
root=tree.getroot()
children = root.getchildren()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the root of our data to extract:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;root
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Element &#39;{http://www.opengis.net/om/1.0}ObservationCollection&#39; at 0x000000000950ED18&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;children
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&amp;lt;Element &#39;{http://www.opengis.net/om/1.0}member&#39; at 0x000000000950EE08&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Number of elements in our file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# total amount of items
print(len(root))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for child in root.iter(&amp;rsquo;*&amp;lsquo;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(child.items())

#print(child.keys())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for child in root.iter(&amp;rsquo;*&amp;lsquo;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(child)

print(child.attrib)

print(child.attrib.get(&#39;value&#39;))

print(child.attrib.get(&#39;name&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The list of variables is available on page 40 of the document:
&amp;mdash; SWOB-ML_Product_User_Guide_v8.2_f.pdf&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data=[]
date_tm=[] 
avg_air_temp_pst1hr=[]
max_air_temp_pst1hr=[]
min_air_temp_pst1hr=[]
max_rel_hum_pst1hr=[]
min_rel_hum_pst1hr=[]
stn_pres=[]
mslp=[]
pcpn_amt_pst1hr=[]
wnd_dir_10m_pst1hr_max_spd=[]
max_wnd_spd_10m_pst1hr=[]
avg_wnd_spd_10m_pst10mts=[]
avg_snw_dpth_pst5mts_1=[]
avg_snw_dpth_pst5mts_2=[]
avg_snw_dpth_pst5mts_3=[]


for child in root.iter(&#39;*&#39;):  
    if child.attrib.get(&#39;name&#39;) == &#39;date_tm&#39;:           # date of actual observation
        date_tm.append(child.get(&#39;value&#39;))
    if child.attrib.get(&#39;name&#39;) == &#39;avg_air_temp_pst1hr&#39;:  # average air temperature in the last hour 
        avg_air_temp_pst1hr.append(child.get(&#39;value&#39;))    
    if child.attrib.get(&#39;name&#39;) == &#39;min_air_temp_pst1hr&#39;: # minimum air temperature in the last hour
        min_air_temp_pst1hr.append(child.get(&#39;value&#39;))    
    if child.attrib.get(&#39;name&#39;) == &#39;max_air_temp_pst1hr&#39;: # maximum air temperature in the last hour 
        max_air_temp_pst1hr.append(child.get(&#39;value&#39;))    
    if child.attrib.get(&#39;name&#39;) == &#39;max_rel_hum_pst1hr&#39;: # maximum relative humidity in the past hour
        max_rel_hum_pst1hr.append(child.get(&#39;value&#39;))    
    if child.attrib.get(&#39;name&#39;) == &#39;min_rel_hum_pst1hr&#39;: # minimum relative humidity in the past hour
        min_rel_hum_pst1hr.append(child.get(&#39;value&#39;)) 
    if child.attrib.get(&#39;name&#39;) == &#39;stn_pres&#39;:         # pressure at the station (start of the hour)
        stn_pres.append(child.get(&#39;value&#39;))
    if child.attrib.get(&#39;name&#39;) == &#39;pcpn_amt_pst1hr&#39;:   # amount of precipitation in the past hour
        pcpn_amt_pst1hr.append(child.get(&#39;value&#39;))  
    if child.attrib.get(&#39;name&#39;) == &#39;avg_wnd_spd_10m_pst10mts&#39;: # average wind speed at 10 m for 10 min
        avg_wnd_spd_10m_pst10mts.append(child.get(&#39;value&#39;))      
    if child.attrib.get(&#39;name&#39;) == &#39;max_wnd_spd_10m_pst1hr&#39;: #  maximum wind speed at 10 m for one hour
        max_wnd_spd_10m_pst1hr.append(child.get(&#39;value&#39;))      
    if child.attrib.get(&#39;name&#39;) == &#39;wnd_dir_10m_pst1hr_max_spd&#39;: # Instant wind direction at 10 m for maximum hourly wind speed, min 0 to 60
        wnd_dir_10m_pst1hr_max_spd.append(child.get(&#39;value&#39;))          
    if child.attrib.get(&#39;name&#39;) == &#39;mslp&#39;:   # average sea level pressure
        mslp.append(child.get(&#39;value&#39;))      
    if child.attrib.get(&#39;name&#39;) == &#39;avg_snw_dpth_pst5mts_1&#39;:
            avg_snw_dpth_pst5mts_1.append(child.get(&#39;value&#39;))
    if child.attrib.get(&#39;name&#39;) == &#39;avg_snw_dpth_pst5mts_2&#39;:
            avg_snw_dpth_pst5mts_2.append(child.get(&#39;value&#39;))
    if child.attrib.get(&#39;name&#39;) == &#39;avg_snw_dpth_pst5mts_3&#39;:
            avg_snw_dpth_pst5mts_3.append(child.get(&#39;value&#39;))
            
            
data_dict = {&#39;date_tm&#39;:date_tm, 
        &#39;avg_air_temp_pst1hr&#39;:avg_air_temp_pst1hr, 
        &#39;min_air_temp_pst1hr&#39;:min_air_temp_pst1hr,
        &#39;max_air_temp_pst1hr&#39;: max_air_temp_pst1hr, 
        &#39;max_rel_hum_pst1hr&#39;:max_rel_hum_pst1hr,
        &#39;min_rel_hum_pst1hr&#39;:min_rel_hum_pst1hr,
        &#39;stn_pres&#39;:stn_pres,
         &#39;mslp&#39;:mslp,
        &#39;pcpn_amt_pst1hr&#39;:pcpn_amt_pst1hr,
        &#39;avg_wnd_spd_10m_pst10mts&#39;:avg_wnd_spd_10m_pst10mts,
        &#39;wnd_dir_10m_pst1hr_max_spd&#39;:wnd_dir_10m_pst1hr_max_spd,
        &#39;max_wnd_spd_10m_pst1hr&#39;:max_wnd_spd_10m_pst1hr,
        &#39;avg_snw_dpth_pst5mts_1&#39;:avg_snw_dpth_pst5mts_1,
        &#39;avg_snw_dpth_pst5mts_2&#39;:avg_snw_dpth_pst5mts_2,
        &#39;avg_snw_dpth_pst5mts_3&#39;:avg_snw_dpth_pst5mts_3
        
       } 

data= pd.DataFrame(data_dict)           
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;date_tm&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;avg_air_temp_pst1hr&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;min_air_temp_pst1hr&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;max_air_temp_pst1hr&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;max_rel_hum_pst1hr&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;min_rel_hum_pst1hr&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;stn_pres&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;mslp&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;pcpn_amt_pst1hr&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;avg_wnd_spd_10m_pst10mts&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;wnd_dir_10m_pst1hr_max_spd&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;max_wnd_spd_10m_pst1hr&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;avg_snw_dpth_pst5mts_1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;avg_snw_dpth_pst5mts_2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;avg_snw_dpth_pst5mts_3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2020-02-18T20:00:00.000Z&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;86&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;83&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1006.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1010.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;40.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;151&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;56.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;37&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;33&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;37&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;2-reading-the-station-list&#34;&gt;2- Reading the station list&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;stations = pd.read_table(&amp;quot;swob-xml_station_list.csv&amp;quot;, sep=&amp;quot;,&amp;quot;)
stations.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;IATA_ID&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;WMO_ID&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;MSC_ID&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Latitude&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Longitude&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Elevation(m)&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Data_Provider&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Dataset/Network&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;AUTO/MAN&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Province/Territory&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4400488&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;East Chedabucto Bay&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;44488&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9302000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;45.445&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-60.9538&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4400489&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;West Chedabucto Bay&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;44489&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9302001&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;45.4869&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-61.141&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4400490&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;West Bay of Fundy&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;44490&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9300300&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;44.6606&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-66.3686&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4600303&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Southern Georgia Strait&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;46303&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9102000&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49.025&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-123.43&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4600304&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Entrance to English Bay&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;46304&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9102001&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49.3017&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-123.357&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;3-filter-stations-over-a-specific-province&#34;&gt;3- Filter stations over  a specific province&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;stations_mask = stations.loc[stations[&amp;quot;Province/Territory&amp;quot;]==&#39;Quebec&#39;,:]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;stations_mask.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;IATA_ID&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;WMO_ID&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;MSC_ID&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Latitude&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Longitude&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Elevation(m)&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Data_Provider&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Dataset/Network&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;AUTO/MAN&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Province/Territory&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;48&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGAH&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;LA GRANDE IV&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;71823&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7093GJ5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;53.75&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-73.6828&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;306.3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;49&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGBC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;BAIE-COMEAU&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;71890&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7040442&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49.1351&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-68.2024&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;22.6&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;50&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGCH&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CHIBOUGAMAU-CHAPAIS&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;73011&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7091410&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49.7773&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-74.5304&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;389.3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;51&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGCL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CAUSAPSCAL AIRPORT&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;73005&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7051201&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;48.3088&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-67.2528&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;123&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;52&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGGA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;GASPE AIRPORT&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;73116&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7052603&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;48.7833&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-64.4833&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;40&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#stations_mask_sans_NaN = stations_mask.dropna() 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#stations_mask_sans_NaN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to work with only stations with automatic recording:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;stations_mask_AUTO = stations_mask.loc[stations_mask[&amp;quot;AUTO/MAN&amp;quot;]==&#39;AUTO&#39;,:]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;stations_mask_AUTO.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;IATA_ID&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;WMO_ID&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;MSC_ID&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Latitude&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Longitude&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Elevation(m)&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Data_Provider&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Dataset/Network&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;AUTO/MAN&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Province/Territory&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;48&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGAH&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;LA GRANDE IV&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;71823&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7093GJ5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;53.75&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-73.6828&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;306.3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;49&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGBC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;BAIE-COMEAU&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;71890&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7040442&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49.1351&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-68.2024&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;22.6&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;50&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGCH&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CHIBOUGAMAU-CHAPAIS&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;73011&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7091410&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49.7773&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-74.5304&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;389.3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;51&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGCL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CAUSAPSCAL AIRPORT&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;73005&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7051201&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;48.3088&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-67.2528&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;123&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;52&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGGA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;GASPE AIRPORT&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;73116&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7052603&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;48.7833&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-64.4833&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;40&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Example of a loop on all stations in Quebec:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for index, row in stations_mask_AUTO.iterrows():
    stid = row[&#39;IATA_ID&#39;]
    tmp_file = &#39;https://dd.weather.gc.ca/observations/swob-ml/&#39;+date+&#39;/&#39;+stid+&#39;/&#39;+year+&#39;-&#39;+month+&#39;-&#39;+day+&#39;-&#39;+hour+&#39;00-&#39;+stid+&#39;-AUTO-swob.xml&#39;
    r = requests.get(tmp_file)
   
    if r.status_code != 200:
        continue
    
    root = ET.fromstring(r.content)
    data=[]
    date_tm=[] 
    avg_air_temp_pst1hr=[]
    max_air_temp_pst1hr=[]
    min_air_temp_pst1hr=[]
    max_rel_hum_pst1hr=[]
    min_rel_hum_pst1hr=[]
    stn_pres=[]
    mslp=[]
    pcpn_amt_pst1hr=[]
    wnd_dir_10m_pst1hr_max_spd=[]
    max_wnd_spd_10m_pst1hr=[]
    avg_wnd_spd_10m_pst10mts=[]
    avg_snw_dpth_pst5mts_1=[]
    avg_snw_dpth_pst5mts_2=[]
    avg_snw_dpth_pst5mts_3=[]

    for child in root.iter(&#39;*&#39;):  
        if child.attrib.get(&#39;name&#39;) == &#39;date_tm&#39;:                   # date-heure d’observation réelle
            date_tm.append(child.get(&#39;value&#39;))
        if child.attrib.get(&#39;name&#39;) == &#39;avg_air_temp_pst1hr&#39;:  # température de l&#39;air moyenne au cours de la dernière heure (minutes 00 à 60)
            avg_air_temp_pst1hr.append(child.get(&#39;value&#39;))    
        if child.attrib.get(&#39;name&#39;) == &#39;min_air_temp_pst1hr&#39;: # température de l&#39;air minimale au cours de la dernière heure (minutes 00 à 60)
            min_air_temp_pst1hr.append(child.get(&#39;value&#39;))    
        if child.attrib.get(&#39;name&#39;) == &#39;max_air_temp_pst1hr&#39;: # température de l&#39;air maximale au cours de la dernière heure (minutes 00 à 60) 
            max_air_temp_pst1hr.append(child.get(&#39;value&#39;))    
        if child.attrib.get(&#39;name&#39;) == &#39;max_rel_hum_pst1hr&#39;: # humidité relative maximale au cours de la dernière heure 
            max_rel_hum_pst1hr.append(child.get(&#39;value&#39;))    
        if child.attrib.get(&#39;name&#39;) == &#39;min_rel_hum_pst1hr&#39;:# humidité relative minimale au cours de la dernière heure
            min_rel_hum_pst1hr.append(child.get(&#39;value&#39;)) 
        if child.attrib.get(&#39;name&#39;) == &#39;stn_pres&#39;:         # pression à la station (début de l’heure)
            stn_pres.append(child.get(&#39;value&#39;))
        if child.attrib.get(&#39;name&#39;) == &#39;pcpn_amt_pst1hr&#39;:   # quantité de précipitation au cours de la dernière heure
            pcpn_amt_pst1hr.append(child.get(&#39;value&#39;))  
        if child.attrib.get(&#39;name&#39;) == &#39;avg_wnd_spd_10m_pst10mts&#39;: # vitesse moyenne du vent à 10 m pendant 10 min
            avg_wnd_spd_10m_pst10mts.append(child.get(&#39;value&#39;))      
        if child.attrib.get(&#39;name&#39;) == &#39;max_wnd_spd_10m_pst1hr&#39;: #  vitesse maximale du vent à 10 m pendant une heure
            max_wnd_spd_10m_pst1hr.append(child.get(&#39;value&#39;))      
        if child.attrib.get(&#39;name&#39;) == &#39;wnd_dir_10m_pst1hr_max_spd&#39;: #Direction instantanée du vent à 10 m pour une vitesse horaire maximale du vent, min 0 à 60
            wnd_dir_10m_pst1hr_max_spd.append(child.get(&#39;value&#39;))          
        if child.attrib.get(&#39;name&#39;) == &#39;mslp&#39;:   # pression moyenne au niveau de la mer
            mslp.append(child.get(&#39;value&#39;))      
        if child.attrib.get(&#39;name&#39;) == &#39;avg_snw_dpth_pst5mts_1&#39;:
                avg_snw_dpth_pst5mts_1.append(child.get(&#39;value&#39;))
        if child.attrib.get(&#39;name&#39;) == &#39;avg_snw_dpth_pst5mts_2&#39;:
                avg_snw_dpth_pst5mts_2.append(child.get(&#39;value&#39;))
        if child.attrib.get(&#39;name&#39;) == &#39;avg_snw_dpth_pst5mts_3&#39;:
                avg_snw_dpth_pst5mts_3.append(child.get(&#39;value&#39;))


    data_dict = {&#39;date_tm&#39;:date_tm, 
            &#39;avg_air_temp_pst1hr&#39;:avg_air_temp_pst1hr, 
            &#39;min_air_temp_pst1hr&#39;:min_air_temp_pst1hr,
            &#39;max_air_temp_pst1hr&#39;: max_air_temp_pst1hr, 
            &#39;max_rel_hum_pst1hr&#39;:max_rel_hum_pst1hr,
            &#39;min_rel_hum_pst1hr&#39;:min_rel_hum_pst1hr,
            &#39;stn_pres&#39;:stn_pres,
             &#39;mslp&#39;:mslp,
            &#39;pcpn_amt_pst1hr&#39;:pcpn_amt_pst1hr,
            &#39;avg_wnd_spd_10m_pst10mts&#39;:avg_wnd_spd_10m_pst10mts,
            &#39;wnd_dir_10m_pst1hr_max_spd&#39;:wnd_dir_10m_pst1hr_max_spd,
            &#39;max_wnd_spd_10m_pst1hr&#39;:max_wnd_spd_10m_pst1hr,
            &#39;avg_snw_dpth_pst5mts_1&#39;:avg_snw_dpth_pst5mts_1,
            &#39;avg_snw_dpth_pst5mts_2&#39;:avg_snw_dpth_pst5mts_2,
            &#39;avg_snw_dpth_pst5mts_3&#39;:avg_snw_dpth_pst5mts_3

           } 

    
    for key,value in data_dict.items(): 
        if not value:
            data_dict[key] = &#39;NaN&#39;
            
    data= pd.DataFrame(data_dict)
    os.makedirs(&#39;D:/Utilisateurs/guillaume/Documents/GitHub/Python_XML/SWOB/&#39;+now.strftime(&amp;quot;%Y%m&amp;quot;)+&#39;/&#39;, exist_ok=True)  

       # file = &#39;D:/Utilisateurs/guillaume/Documents/GitHub/Python_XML/SWOB/&#39;+now.strftime(&amp;quot;%Y%m&amp;quot;)+&#39;/&#39;+str(int(row[&#39;WMO_ID&#39;]))+&#39;_&#39;+now.strftime(&amp;quot;%Y%m&amp;quot;)+&#39;.csv&#39;
    file = &#39;D:/Utilisateurs/guillaume/Documents/GitHub/Python_XML/SWOB/&#39;+now.strftime(&amp;quot;%Y%m&amp;quot;)+&#39;/&#39;+str(row[&#39;MSC_ID&#39;])+&#39;_&#39;+now.strftime(&amp;quot;%Y%m&amp;quot;)+&#39;.csv&#39;
    if exists(file):
        #print (&amp;quot;File exist&amp;quot;)
        data.to_csv(r&#39;D:/Utilisateurs/guillaume/Documents/GitHub/Python_XML/SWOB/&#39;+now.strftime(&amp;quot;%Y%m&amp;quot;)+&#39;/&#39;+str(row[&#39;MSC_ID&#39;])+&#39;_&#39;+now.strftime(&amp;quot;%Y%m&amp;quot;)+&#39;.csv&#39;,mode=&#39;a&#39;,index=False,header=False) 
    else:
        #print (&amp;quot;File not exist&amp;quot;)
        pd.DataFrame(row).T.to_csv(r&#39;D:/Utilisateurs/guillaume/Documents/GitHub/Python_XML/SWOB/&#39;+now.strftime(&amp;quot;%Y%m&amp;quot;)+&#39;/&#39;+str(row[&#39;MSC_ID&#39;])+&#39;_&#39;+now.strftime(&amp;quot;%Y%m&amp;quot;)+&#39;.csv&#39;,index=False)  
        data.to_csv(r&#39;D:/Utilisateurs/guillaume/Documents/GitHub/Python_XML/SWOB/&#39;+now.strftime(&amp;quot;%Y%m&amp;quot;)+&#39;/&#39;+str(row[&#39;MSC_ID&#39;])+&#39;_&#39;+now.strftime(&amp;quot;%Y%m&amp;quot;)+&#39;.csv&#39;,mode=&#39;a&#39;,index=False)  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-we-will-trace-the-location-of-the-stations&#34;&gt;4- We will trace the location of the stations:&lt;/h3&gt;

&lt;p&gt;We will start by extracting the latitudes and longitudes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;list_lat = stations.loc[stations[&amp;quot;AUTO/MAN&amp;quot;]==&#39;AUTO&#39;,:][&#39;Latitude&#39;].values
list_lon = stations.loc[stations[&amp;quot;AUTO/MAN&amp;quot;]==&#39;AUTO&#39;,:][&#39;Longitude&#39;].values
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import cartopy.crs as ccrs
import cartopy.feature as cfeature
import matplotlib.pylab as plt
import numpy as np

fig = plt.figure(figsize=(28,16))   
ax = plt.axes(projection=ccrs.PlateCarree())
ax.set_extent((-150.0, -50, 40, 90))

ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))      # couche ocean
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))       # couche land
ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))      # couche lac

ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))    # couche frontieres
ax.add_feature(cfeature.RIVERS.with_scale(&#39;50m&#39;))     # couche rivières      
coast = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, scale=&#39;10m&#39;,     # ajout de la couche cotière 
                    facecolor=&#39;none&#39;, name=&#39;coastline&#39;)
ax.add_feature(coast, edgecolor=&#39;black&#39;)
states_provinces = cfeature.NaturalEarthFeature(
    category=&#39;cultural&#39;,
    name=&#39;admin_1_states_provinces_lines&#39;,
    scale=&#39;10m&#39;,
    facecolor=&#39;none&#39;)

ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;)  

ax.gridlines()           
mm = ax.scatter(list_lon, list_lat, c=&#39;red&#39;, s=100, label=&#39;SWOB Met-ML MSC&#39;)
#mm = ax.scatter(dfstat[&#39;lon&#39;].values, dfstat[&#39;lat&#39;].values, c=&#39;green&#39;, s=400, label=&#39;Site&#39;)

plt.legend(loc=&amp;quot;best&amp;quot;, markerscale=1., scatterpoints=1, fontsize=40)
          
# Define gridline locations and draw the lines using cartopy&#39;s built-in gridliner:
xticks = np.arange(-150.0,-40.0,20)
yticks =np.arange(10,80,10)     
fig.canvas.draw()
 
plt.savefig(&#39;Localisation_SWOB_CANADA.png&#39;, bbox_inches=&#39;tight&#39;, pad_inches=0.1)
plt.show()  
plt.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_32_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-just-over-quebec&#34;&gt;5-  Just over Quebec:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;list_lat = stations.loc[(stations[&amp;quot;AUTO/MAN&amp;quot;]==&#39;AUTO&#39;) &amp;amp; (stations[&amp;quot;Province/Territory&amp;quot;]==&#39;Quebec&#39;),:][&#39;Latitude&#39;].values
list_lon = stations.loc[(stations[&amp;quot;AUTO/MAN&amp;quot;]==&#39;AUTO&#39;) &amp;amp; (stations[&amp;quot;Province/Territory&amp;quot;]==&#39;Quebec&#39;),:][&#39;Longitude&#39;].values
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import cartopy.crs as ccrs
import cartopy.feature as cfeature
import matplotlib.pylab as plt
import numpy as np

fig = plt.figure(figsize=(28,16))   
ax = plt.axes(projection=ccrs.PlateCarree())
ax.set_extent((-80.0, -50, 40, 70))

ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))      # couche ocean
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))       # couche land
ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))      # couche lac

ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))    # couche frontieres
ax.add_feature(cfeature.RIVERS.with_scale(&#39;50m&#39;))     # couche rivières      
coast = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, scale=&#39;10m&#39;,     # ajout de la couche cotière 
                    facecolor=&#39;none&#39;, name=&#39;coastline&#39;)
ax.add_feature(coast, edgecolor=&#39;black&#39;)
states_provinces = cfeature.NaturalEarthFeature(
    category=&#39;cultural&#39;,
    name=&#39;admin_1_states_provinces_lines&#39;,
    scale=&#39;10m&#39;,
    facecolor=&#39;none&#39;)

ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;)  

ax.gridlines()           
mm = ax.scatter(list_lon, list_lat, c=&#39;red&#39;, s=100, label=&#39;SWOB Met-ML MSC&#39;)
#mm = ax.scatter(dfstat[&#39;lon&#39;].values, dfstat[&#39;lat&#39;].values, c=&#39;green&#39;, s=400, label=&#39;Site&#39;)

plt.legend(loc=&amp;quot;best&amp;quot;, markerscale=1., scatterpoints=1, fontsize=40)
          
# Define gridline locations and draw the lines using cartopy&#39;s built-in gridliner:
xticks = np.arange(-150.0,-40.0,20)
yticks =np.arange(10,80,10)     
fig.canvas.draw()
 
plt.savefig(&#39;Localisation_SWOB_Quebec.png&#39;, bbox_inches=&#39;tight&#39;, pad_inches=0.1)
plt.show()  
plt.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_35_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;6-if-we-want-to-plot-by-grouping-by-province&#34;&gt;6-  If we want to plot by grouping by province:&lt;/h3&gt;

&lt;p&gt;We only want the &amp;ldquo;Automatic&amp;rdquo; stations and group them by province.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;grouped_dataframe = stations.loc[stations[&amp;quot;AUTO/MAN&amp;quot;]==&#39;AUTO&#39;,:].groupby(&#39;Province/Territory&#39;)
grouped_dataframe.count()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Province/Territory&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;IATA_ID&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;WMO_ID&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;MSC_ID&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Latitude&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Longitude&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Elevation(m)&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Data_Provider&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Dataset/Network&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;AUTO/MAN&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Alberta&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;240&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;240&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;196&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;240&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;240&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;240&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;240&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;240&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;240&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;240&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;British Columbia&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;119&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;119&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;101&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;119&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;119&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;119&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;119&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;119&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;119&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;119&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Manitoba&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;44&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;New Brunswick&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;21&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;21&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;20&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;21&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;21&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;21&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;21&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;21&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;21&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;21&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Newfoundland and Labrador&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;36&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;36&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;34&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;36&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;36&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;36&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;36&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;36&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;36&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;36&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Northwest Territories&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;34&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Nova Scotia&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;42&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;42&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;39&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;42&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;42&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;42&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;42&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;42&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;42&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;42&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Nunavut&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;63&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;63&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;52&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;63&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;63&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;63&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;63&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;63&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;63&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;63&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Ontario&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;111&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;111&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;103&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;111&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;111&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;111&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;111&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;111&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;111&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;111&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Prince Edward Island&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;122&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;122&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;103&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;122&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;122&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;122&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;122&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;122&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;122&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;122&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Saskatchewan&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;57&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;57&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;56&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;57&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;57&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;57&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;57&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;57&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;57&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;57&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Yukon&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;23&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;23&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;17&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;23&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;23&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;23&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;23&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;23&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;23&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;23&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for name,group in grouped_dataframe:
   print(name) 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Alberta
British Columbia
Manitoba
New Brunswick
Newfoundland and Labrador
Northwest Territories
Nova Scotia
Nunavut
Ontario
Prince Edward Island
Quebec
Saskatchewan
Yukon
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;grouped_dataframe.get_group(&#39;Quebec&#39;).head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;IATA_ID&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;WMO_ID&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;MSC_ID&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Latitude&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Longitude&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Elevation(m)&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Data_Provider&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Dataset/Network&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;AUTO/MAN&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Province/Territory&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;48&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGAH&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;LA GRANDE IV&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;71823&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7093GJ5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;53.75&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-73.6828&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;306.3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;49&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGBC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;BAIE-COMEAU&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;71890&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7040442&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49.1351&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-68.2024&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;22.6&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;50&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGCH&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CHIBOUGAMAU-CHAPAIS&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;73011&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7091410&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49.7773&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-74.5304&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;389.3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;51&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGCL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CAUSAPSCAL AIRPORT&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;73005&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7051201&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;48.3088&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-67.2528&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;123&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;52&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CGGA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;GASPE AIRPORT&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;73116&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7052603&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;48.7833&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-64.4833&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;40&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MSC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AUTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We create a random color list for all of our provinces.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import random
number_of_colors = len(grouped_dataframe)
color = [&amp;quot;#&amp;quot;+&#39;&#39;.join([random.choice(&#39;0123456789ABCDEF&#39;) for j in range(6)])
             for i in range(number_of_colors)]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import cartopy.crs as ccrs
import cartopy.feature as cfeature
import matplotlib.pylab as plt
import numpy as np


fig = plt.figure(figsize=(28,16))   
ax = plt.axes(projection=ccrs.PlateCarree())
ax.set_extent((-150.0, -50, 40, 90))

ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))      # couche ocean
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))       # couche land
ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))      # couche lac

ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))    # couche frontieres
ax.add_feature(cfeature.RIVERS.with_scale(&#39;50m&#39;))     # couche rivières      
coast = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, scale=&#39;10m&#39;,     # ajout de la couche cotière 
                    facecolor=&#39;none&#39;, name=&#39;coastline&#39;)
ax.add_feature(coast, edgecolor=&#39;black&#39;)
states_provinces = cfeature.NaturalEarthFeature(
    category=&#39;cultural&#39;,
    name=&#39;admin_1_states_provinces_lines&#39;,
    scale=&#39;10m&#39;,
    facecolor=&#39;none&#39;)

ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;)  

ax.gridlines()
i = 0 
for name,group in grouped_dataframe:
    list_lon= grouped_dataframe.get_group(name)[&#39;Longitude&#39;].values
    list_lat= grouped_dataframe.get_group(name)[&#39;Latitude&#39;].values
    
    mm = ax.scatter(list_lon, list_lat, c=color[i], s=100, label=&#39;SWOB Met-ML MSC: &#39;+ name  )
    plt.legend(loc=&amp;quot;best&amp;quot;, markerscale=1., scatterpoints=1, fontsize=10)
    i+=1

# Define gridline locations and draw the lines using cartopy&#39;s built-in gridliner:
xticks = np.arange(-150.0,-40.0,20)
yticks =np.arange(10,80,10)     
fig.canvas.draw()
 
plt.savefig(&#39;Localisation_SWOB_CANADA.png&#39;, bbox_inches=&#39;tight&#39;, pad_inches=0.1)
plt.show()  
plt.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_42_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Shapefiles in python</title>
      <link>/post/shapefiles_in_python/</link>
      <pubDate>Mon, 17 Feb 2020 11:51:51 -0800</pubDate>
      <guid>/post/shapefiles_in_python/</guid>
      <description>

&lt;p&gt;﻿&lt;/p&gt;

&lt;h3 id=&#34;about-vector-data&#34;&gt;About Vector Data&lt;/h3&gt;

&lt;p&gt;Vector data are composed of discrete geometric locations (x, y values) known as vertices that define the “shape” of the
spatial object.&lt;/p&gt;

&lt;p&gt;The organization of the vertices determines the type of vector that you are working with. There are three types of vector data:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Points: Each individual point is defined by a single x, y coordinate. There can be many points in a vector point file.
&lt;img src=&#34;output_17_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Lines: Lines are composed of many (at least 2) vertices, or points, that are connected. For instance, a road or a stream may be represented by a line. This line is composed of a series of segments, each “bend” in the road or stream represents a vertex that has defined x, y location.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./output_20_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Polygons: A polygon consists of 3 or more vertices that are connected and “closed”. Thus the outlines of plot boundaries, lakes, oceans, and states or countries are often represented by polygons. Occasionally, a polygon can have a hole in the middle of it (like a doughnut), this is something to be aware of but not an issue you will deal with in this tutorial.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;output_30_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;shapefiles-points-lines-and-polygons&#34;&gt;Shapefiles: Points, Lines, and Polygons&lt;/h3&gt;

&lt;p&gt;Geospatial data in vector format are often stored in a shapefile format. Because the structure of points, lines, and polygons are different, each individual shapefile can only contain one vector type (all points, all lines or all polygons). You will not find a mixture of point, line and polygon objects in a single shapefile.&lt;/p&gt;

&lt;p&gt;Objects stored in a shapefile often have a set of associated attributes that describe the data. For example, a line shapefile that contains the locations of streams, might contain the associated stream name, stream “order” and other information about each stream line object.&lt;/p&gt;

&lt;p&gt;A shapefile is created by 3 or more files, all of which must retain the same NAME and be stored in the same file directory, in order for you to be able to work with them.&lt;/p&gt;

&lt;h3 id=&#34;shapefile-structure&#34;&gt;Shapefile Structure&lt;/h3&gt;

&lt;p&gt;There are 3 key files associated with any and all shapefiles:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;.shp: the file that contains the geometry for all features.&lt;/li&gt;
&lt;li&gt;.shx: the file that indexes the geometry.&lt;/li&gt;
&lt;li&gt;.dbf: the file that stores feature attributes in a tabular format.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sometimes, a shapefile will have other associated files including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;.prj: the file that contains information on projection format including the coordinate system and projection information. It is a plain text file describing the projection using well-known text (WKT) format.&lt;/li&gt;
&lt;li&gt;.sbn and .sbx: the files that are a spatial index of the features.&lt;/li&gt;
&lt;li&gt;.shp.xml: the file that is the geospatial metadata in XML format, (e.g. ISO 19115 or XML format).
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We will use the geopandas library to work with vector data in Python. You will also use matplotlib.pyplot to plot your data.&lt;/p&gt;

&lt;p&gt;First, we import librairies.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import warnings; warnings.filterwarnings(action=&#39;ignore&#39;)
from matplotlib import pyplot as plt
%matplotlib inline
import geopandas as gpd
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-point-shapefile&#34;&gt;1- Point shapefile&lt;/h3&gt;

&lt;p&gt;We can then open our first shapefile which contains point locations&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;shapes = gpd.read_file(&amp;quot;shapefiles\BV_SJ_ponts.shp&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each object in a shapefile has one or more attributes associated with it. Shapefile attributes are similar to fields or columns in a spreadsheet. Each row in the spreadsheet has a set of columns associated with it that describe the row element. In the case of a shapefile, each row represents a spatial object - for example, a road, represented as a line in a line shapefile, will have one “row” of attributes associated with it. These attributes can include different types of information that describe objects stored within a shapefile.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;shapes.head(2)
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Id&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;ORIG_FID&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;OCEAN_EN&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;OCEAN_FR&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;WSCSSDA&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;WSCSDA&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;WSCMDA&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;WSCSSDA_EN&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;WSCSDA_EN&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;WSCMDA_EN&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;WSCSSDA_FR&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;WSCSDA_FR&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;WSCMDA_FR&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;BUFF_DIST&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;ORIG_FID_1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Shape_Leng&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Shape_Area&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;geometry&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Atlantic Ocean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;OcÃ©an Atlantique&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;01AE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;01A&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;01&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Fish (Maine)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Saint John and Southern Bay of Fundy (N.B.)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Maritime Provinces Drainage Area&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Fish (Maine)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Saint-Jean et sud de la baie de Fundy (N.-B.)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Aire de drainage des provinces Maritimes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;23.6325&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.74042&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;POINT (-68.31290411677341 47.93509135554499)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Atlantic Ocean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;OcÃ©an Atlantique&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;01AE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;01A&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;01&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Fish (Maine)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Saint John and Southern Bay of Fundy (N.B.)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Maritime Provinces Drainage Area&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Fish (Maine)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Saint-Jean et sud de la baie de Fundy (N.-B.)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Aire de drainage des provinces Maritimes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;23.6325&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.74042&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;POINT (-68.10019745512986 47.8385423546759)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Atlantic Ocean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;OcÃ©an Atlantique&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;01AE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;01A&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;01&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Fish (Maine)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Saint John and Southern Bay of Fundy (N.B.)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Maritime Provinces Drainage Area&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Fish (Maine)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Saint-Jean et sud de la baie de Fundy (N.-B.)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Aire de drainage des provinces Maritimes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;23.6325&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.74042&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;POINT (-68.05084811719591 47.67967312057342)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Atlantic Ocean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;OcÃ©an Atlantique&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;01AE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;01A&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;01&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Fish (Maine)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Saint John and Southern Bay of Fundy (N.B.)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Maritime Provinces Drainage Area&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Fish (Maine)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Saint-Jean et sud de la baie de Fundy (N.-B.)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Aire de drainage des provinces Maritimes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;23.6325&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.74042&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;POINT (-67.94013835894734 47.46553718633378)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Atlantic Ocean&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;OcÃ©an Atlantique&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;01AE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;01A&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;01&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Fish (Maine)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Saint John and Southern Bay of Fundy (N.B.)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Maritime Provinces Drainage Area&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Fish (Maine)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Saint-Jean et sud de la baie de Fundy (N.-B.)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Aire de drainage des provinces Maritimes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;23.6325&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.74042&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;POINT (-67.79256589502562 47.36265881338679)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Notice that the geopandas data structure is a data.frame that contains a geometry column where the x, y point location values are stored. All of the other shapefile feature attributes are contained in columns, similar to what you may be used to if you’ve used a GIS tool such as ArcGIS or QGIS.&lt;/p&gt;

&lt;h3 id=&#34;shapefile-metadata-attributes&#34;&gt;Shapefile Metadata &amp;amp; Attributes&lt;/h3&gt;

&lt;p&gt;When you import the  shapefile layer into Python the gpd.read_file() function automatically stores information about the data as attributes. You are particularly interested in the geospatial metadata, describing the format, CRS, extent, and other components of the vector data, and the attributes which describe properties associated with each individual vector object.&lt;/p&gt;

&lt;h3 id=&#34;spatial-metadata&#34;&gt;Spatial Metadata&lt;/h3&gt;

&lt;p&gt;Key metadata for all shapefiles include:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- Object Type: the class of the imported object.
- Coordinate Reference System (CRS): the projection of the data.
- Extent: the spatial extent (geographic area that the shapefile covers) of the shapefile. Note that the spatial extent for a shapefile represents the extent for ALL spatial objects in the shapefile.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can view shapefile metadata using the class(), .crs and .total_bounds methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;type(shapes)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;geopandas.geodataframe.GeoDataFrame
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;shapes.total_bounds
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;array([-70.40000541,  45.21527633, -65.03721851,  48.06254733])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;shapes.crs
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;{&#39;init&#39;: &#39;epsg:4269&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The CRS for our data is epsg code: 4269.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;shapes.geom_type.head(2)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;0    Point
1    Point
dtype: object
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;shapes.geometry.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;0    POINT (-68.31290411677341 47.93509135554499)
1     POINT (-68.10019745512986 47.8385423546759)
2    POINT (-68.05084811719591 47.67967312057342)
3    POINT (-67.94013835894734 47.46553718633378)
4    POINT (-67.79256589502562 47.36265881338679)
Name: geometry, dtype: object
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;how-many-features-are-in-your-shapefile&#34;&gt;How Many Features Are in Your Shapefile?&lt;/h3&gt;

&lt;p&gt;You can view the number of features (counted by the number of rows in the attribute table) and feature attributes (number of columns) in our data using the pandas .shape method. Note that the data are returned as a vector of two values:&lt;/p&gt;

&lt;p&gt;(rows, columns)&lt;/p&gt;

&lt;p&gt;Also note that the number of columns includes a column where the geometry (the x, y coordinate locations) are stored.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;shapes.shape
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(72, 18)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;plot-our-shapefile&#34;&gt;Plot our Shapefile&lt;/h3&gt;

&lt;p&gt;you can visualize the data in your Python geodata.frame object using the .plot() method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;shapes.loc[:, &#39;geometry&#39;].plot()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0x9b129b0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_17_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-linestring-shapefile&#34;&gt;2- Linestring shapefile&lt;/h3&gt;

&lt;p&gt;We had previously a POINT object.&lt;/p&gt;

&lt;p&gt;We will then convert POINT to LINESTRING.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from shapely.geometry import LineString, mapping

def point_to_linestring(fili_shps):
    gdf = gpd.read_file(fili_shps) #POINTS
    latlon = [mapping(x)[&#39;coordinates&#39;] for x in gdf.geometry]
    lats = [x[1] for x in latlon]
    lons = [x[0] for x in latlon]
    linestr = LineString(zip(lons, lats))
    return gpd.GeoDataFrame(index=[0], crs=gdf.crs, geometry=[linestr])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;line_shapes = point_to_linestring(&amp;quot;shapefiles\BV_SJ_ponts.shp&amp;quot;)
line_shapes.loc[:, &#39;geometry&#39;].plot()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0xa55f128&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_20_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;line_shapes
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;geometry&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;LINESTRING (-68.31290411677341 47.93509135554499, &amp;hellip; )&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If we want to save our new shapefile:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;line_shapes.to_file(&amp;quot;shapefiles\BV_SJ_lines.shp&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And for example we can save latitude and longitude values into csv format:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import shapefile
import os

def shp2csv(shp_file):
    &#39;&#39;&#39;Outputs a csv file based on input shapefile vertices&#39;&#39;&#39;
    
    out = os.path.splitext(shp_file)[0]+&#39;_pnts.csv&#39;

    with open(out, &#39;w&#39;) as csv:
        with shapefile.Reader(shp_file) as sf:

            for shp_rec in sf.shapeRecords():
                csv.write(&#39;{}\n&#39;.format(shp_rec.record))

                for pnt in shp_rec.shape.points:
                    csv.write(&#39;{}\n&#39;.format(pnt))

shp2csv(&amp;quot;shapefiles\BV_SJ_lines.shp&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pandas as pd
BV_border = pd.read_csv(&#39;.\shapefiles\BV_SJ_lines_pnts.csv&#39;, sep=&#39;,&#39;,skiprows = range(0, 1))
BV_border.columns=[&amp;quot;lon&amp;quot;, &amp;quot;lat&amp;quot;]
BV_border[&amp;quot;lon&amp;quot;]=BV_border[&amp;quot;lon&amp;quot;].apply(lambda x: x.replace(&amp;quot;(&amp;quot;, &amp;quot;&amp;quot;)).apply(pd.to_numeric,1)
BV_border[&amp;quot;lat&amp;quot;]=BV_border[&amp;quot;lat&amp;quot;].apply(lambda x: x.replace(&amp;quot;)&amp;quot;, &amp;quot;&amp;quot;)).apply(pd.to_numeric,1)
BV_border.head()
BV_border.lon
BV_border.append(BV_border, ignore_index=True)
BV_border.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;lon&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;lat&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-68.1002&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47.8385&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-68.0508&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47.6797&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-67.9401&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47.4655&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-67.7926&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47.3627&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-67.6059&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47.4158&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib.pyplot as plt
import cartopy.crs as ccrs
from cartopy.io.shapereader import Reader
from cartopy.feature import ShapelyFeature

fname = r&#39;shapefiles\BV_SJ_lines.shp&#39;

fig=plt.figure(figsize=(10,10), frameon=True)  
ax = plt.axes(projection=ccrs.Robinson())
ax.set_extent([-70,-64,45,50])
        
#ax.coastlines(resolution=&#39;110m&#39;);
ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))      # couche ocean
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))       # couche land
ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))      # couche lac
    
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))    # couche frontieres
ax.add_feature(cfeature.RIVERS.with_scale(&#39;50m&#39;))     # couche rivières 
        
coast = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, scale=&#39;50m&#39;,     # ajout de la couche cotière 
                            facecolor=&#39;none&#39;, name=&#39;coastline&#39;)
ax.add_feature(coast, edgecolor=&#39;black&#39;)
states_provinces = cfeature.NaturalEarthFeature(
        category=&#39;cultural&#39;,
        name=&#39;admin_1_states_provinces_lines&#39;,
         scale=&#39;10m&#39;,
         facecolor=&#39;none&#39;)
    
ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;)  
ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;)  
    
ax.gridlines()


        # Define gridline locations and draw the lines using cartopy&#39;s built-in gridliner:
xticks = np.arange(-150.0,-40.0,20)
yticks =np.arange(10,80,10)
        
fig.canvas.draw()
colors = [&#39;red&#39;]
maskBV = [&#39;BV&#39;]                      
cs = ax.plot(BV_border.lon,BV_border.lat, transform=ccrs.PlateCarree(), color=colors[0], linewidth=2, label=maskBV[0])
shape_feature = ShapelyFeature(Reader(fname).geometries(),
                                ccrs.PlateCarree(), edgecolor=&#39;red&#39;)
ax.add_feature(shape_feature, facecolor=&#39;yellow&#39;)
plt.legend(loc=&amp;quot;best&amp;quot;, markerscale=2., fontsize=10)     
plt.savefig(&#39;./figure.png&#39;, bbox_inches=&#39;tight&#39;, pad_inches=0.1)
plt.show()  
plt.close()
       

print(&#39;Terminé&#39;)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_27_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Terminé
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-polygon-shapefile&#34;&gt;3- Polygon shapefile&lt;/h3&gt;

&lt;p&gt;We can now convert our linestring shapefile to a polygon shapefile:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from shapely.geometry import Polygon, mapping

def linestring_to_polygon(fili_shps):
    gdf = gpd.read_file(fili_shps) #LINESTRING
    geom = [x for x in gdf.geometry]
    all_coords = mapping(geom[0])[&#39;coordinates&#39;]
    lats = [x[1] for x in all_coords]
    lons = [x[0] for x in all_coords]
    linestr = Polygon(zip(lons, lats))
    return gpd.GeoDataFrame(index=[0], crs=gdf.crs, geometry=[linestr])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;poly_shapes = linestring_to_polygon(&amp;quot;shapefiles\BV_SJ_lines.shp&amp;quot;)
poly_shapes.to_file(&#39;shapefiles\BV_SJ_WGS84.shp&#39;)
poly_shapes.loc[:, &#39;geometry&#39;].plot()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0xa5f0a90&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_30_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;poly_shapes
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;geometry&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;POLYGON ((-68.31290411677341 47.93509135554499, &amp;hellip;))&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;4-check-if-a-point-in-inside-a-polygon&#34;&gt;4- Check if a point in inside a polygon&lt;/h3&gt;

&lt;p&gt;Function bellow will check if a point, defined by a specific latitude and longitude, is inside or not a polygon shapefile.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def check(lon, lat, ds_in):
  lyr_in = ds_in.GetLayer(0)  
  # create point geometry
  pt = ogr.Geometry(ogr.wkbPoint)
  pt.SetPoint_2D(0, lon, lat)
  # go over all the polygons in the layer see if one include the point
  for feat_in in lyr_in:
    # roughly subsets features, instead of go over everything
    ply = feat_in.GetGeometryRef()
    # test
    if ply.Contains(pt):
      # TODO do what you need to do here
        print(&#39;Point in shapefile polygon&#39;)
        return(lon, lat)
        return(True)
    else:
        print(&#39;Point not in shapefile polygon&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ds_in  = ogr.Open(&amp;quot;shapefiles\BV_SJ_WGS84.shp&amp;quot;)
lon = -68.
lat = 47
ind = check(lon, lat, ds_in)
ind
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Point in shapefile polygon

(-68.0, 47)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib.pyplot as plt
import cartopy.crs as ccrs
from cartopy.io.shapereader import Reader
from cartopy.feature import ShapelyFeature

fname = r&#39;shapefiles\BV_SJ_WGS84.shp&#39;
fig=plt.figure(figsize=(28,16), frameon=True)  
ax = plt.axes(projection=ccrs.Robinson())
ax.set_extent([-70,-64,45,50])
ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))      # couche ocean
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))       # couche land
ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))      # couche lac
   
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))    # couche frontieres
ax.add_feature(cfeature.RIVERS.with_scale(&#39;50m&#39;))     # couche rivières 
coast = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, scale=&#39;10m&#39;,     # ajout de la couche cotière 
                            facecolor=&#39;none&#39;, name=&#39;coastline&#39;)
ax.add_feature(coast, edgecolor=&#39;black&#39;)    
states_provinces = cfeature.NaturalEarthFeature(
            category=&#39;cultural&#39;,
            name=&#39;admin_1_states_provinces_lines&#39;,
            scale=&#39;10m&#39;,
            facecolor=&#39;none&#39;)
    
ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;) 
ax.plot(ind[0], ind[1], &#39;go&#39;, ms=20, transform=ccrs.Geodetic())

ax.text(ind[0] + .35, ind[1] + .15, 
                &#39;Point in shapefile polygon&#39;, 
                va=&#39;center&#39;, 
                ha=&#39;right&#39;, color= &#39;green&#39;, transform=ccrs.Geodetic(), fontweight=&#39;bold&#39;)

ax.plot(-66, 48.5, &#39;ro&#39;, ms=20, transform=ccrs.Geodetic())
ax.text(-66 + .35, 48.5 + .15, 
                &#39;Point outside shapefile polygon&#39;, 
                va=&#39;center&#39;, 
                ha=&#39;right&#39;, color= &#39;red&#39;, transform=ccrs.Geodetic(), fontweight=&#39;bold&#39;)

shape_feature = ShapelyFeature(Reader(fname).geometries(),
                                ccrs.PlateCarree(), edgecolor=&#39;black&#39;)
ax.add_feature(shape_feature, facecolor=&#39;yellow&#39;)

plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_35_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Canadian shapefile province</title>
      <link>/post/province_shapefiles/</link>
      <pubDate>Fri, 14 Feb 2020 09:14:48 -0800</pubDate>
      <guid>/post/province_shapefiles/</guid>
      <description>

&lt;p&gt;﻿&lt;/p&gt;

&lt;h3 id=&#34;from-shapefiles-to-netcdf-mask&#34;&gt;From shapefiles to Netcdf Mask&lt;/h3&gt;

&lt;p&gt;In this tutorial, we will use shapefiles to create masks over canadian provinces.&lt;/p&gt;

&lt;p&gt;We will use gridded dataset ANUSPLIN meteorological data.&lt;/p&gt;

&lt;p&gt;Agriculture and Agri-Food Canada have produced daily precipitation, minimum and maximum temperature across Canada (south of 60°N) for climate related application purpose using thin-plate smoothing splines, as implemented in the ANUSPLIN climate modeling software (Hutchinson et al., 2009; McKenney et al., 2011).&lt;/p&gt;

&lt;p&gt;The so-called ANUSPLIN data uses ground-based observations and generates daily gridded data from 1951 to 2017 on a Lambert conformal conic projection with 5’ arc minutes spacing (equivalent to a resolution of about 10 km). The key strength of this spatial interpolation method is its global dependence on all data, permitting robust and stable determination of spatially varying dependences on elevation. Hutchinson et al. (2009) have shown that while ANUSPLIN fall month’s absolute errors were remarkably small, those of winter months were quite large due to rather difficult observation and measurement conditions.&lt;/p&gt;

&lt;p&gt;Data are available on this &lt;a href=&#34;ftp://ftp.nrcan.gc.ca/pub/outgoing/canada_daily_grids&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I will present a  solution based on open-source Python modules:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    - xarray: for manipulating &amp;amp; reading gridded data, and – very important – operate out-of-memory thanks to its dask capabilities
    - numpy: for simple array manipulations
    - geopandas: to open shapefiles
    - osgeo: 
    - matplotlib: for plotting
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-first-we-need-to-import-librairies-and-create-aliases&#34;&gt;1- First we need to import librairies and create aliases.&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import xarray as xr 
import numpy as np
import regionmask
import geopandas as gpd
import pandas as pd
import matplotlib.pyplot as plt
from osgeo import ogr
import warnings; warnings.filterwarnings(action=&#39;ignore&#39;)
%matplotlib inline
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;working-over-canadian-province&#34;&gt;Working over canadian province&lt;/h4&gt;

&lt;p&gt;In this example we will use canadian province shapefiles developped by statistics canada.&lt;/p&gt;

&lt;p&gt;Shapefiles are available on this &lt;a href=&#34;https://www12.statcan.gc.ca/census-recensement/2011/geo/bound-limit/bound-limit-2016-eng.cfm&#34; target=&#34;_blank&#34;&gt;website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After downloaded the shapefile, we must load it using geopandas library:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;PATH_TO_SHAPEFILE = &#39;./Canadian_province/lpr_000b16a_e/lpr_000b16a_e.shp&#39;
province = gpd.read_file(PATH_TO_SHAPEFILE)
province
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;PRUID&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;PRNAME&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;PRENAME&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;PRFNAME&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;PREABBR&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;PRFABBR&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Newfoundland and Labrador / Terre-Neuve-et-Labrador&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Newfoundland and Labrador&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Terre-Neuve-et-Labrador&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N.L.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;T.-N.-L.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Prince Edward Island / Île-du-Prince-Édouard&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Prince Edward Island&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Île-du-Prince-Édouard&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;P.E.I.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Î.-P.-É.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nova Scotia / Nouvelle-Écosse&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nova Scotia&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nouvelle-Écosse&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N.S.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N.-É.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;13&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;New Brunswick / Nouveau-Brunswick&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;New Brunswick&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nouveau-Brunswick&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N.B.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N.-B.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;24&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec / Québec&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Québec&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Que.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Qc&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;35&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ontario&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ontario&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ontario&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ont.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ont.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;46&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Manitoba&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Manitoba&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Manitoba&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Man.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Man.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Saskatchewan&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Saskatchewan&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Saskatchewan&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Sask.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Sask.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;48&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Alberta&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Alberta&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Alberta&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Alta.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Alb.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;59&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;British Columbia / Colombie-Britannique&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;British Columbia&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Colombie-Britannique&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;B.C.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;C.-B.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;60&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Yukon&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Yukon&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Yukon&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Y.T.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Yn&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;61&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Northwest Territories / Territoires du Nord-Ouest&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Northwest Territories&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Territoires du Nord-Ouest&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N.W.T.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;T.N.-O.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;62&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nunavut&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nunavut&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nunavut&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nvt.&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Nt&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Shapes are here a GeoDataFrame containing all polygons illustrating the province boundaries.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ID_PROV = 5
print(province.PRNAME[ID_PROV])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Ontario
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;province.loc[:, &#39;geometry&#39;].plot()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0xad67400&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./output_6_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tmpWGS84 = province.to_crs({&#39;proj&#39;:&#39;longlat&#39;, &#39;ellps&#39;:&#39;WGS84&#39;, &#39;datum&#39;:&#39;WGS84&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tmpWGS84.plot()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0x1327ac88&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./output_8_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now we can load the ANUSPLIN_10km gridded data. The parameter chunks is very important, it defines how big are the “pieces” of data moved from the disk to the memory. With this value the entire computation on a workstation with 32 GB takes a couple of minutes.&lt;/p&gt;

&lt;p&gt;We will load all the temperature files using Xarray library.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;model=&#39;ANUSPLIN_10km_YEAR_Mean_tasmoy_1950-2017&#39;
t_in = &#39;J:/DONNEES_AMERIQUE_DU_NORD/ANUSPLIN_10km/Netcdf/INDICES_ANNEES/Mean_tasmoy/&#39;        
data = t_in + model + &#39;.nc&#39;
ds = xr.open_mfdataset(data, chunks = {&#39;time&#39;: 10})
ds
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:      (time: 68, x: 510, y: 1068)
Coordinates:
    lon          (y, x) float32 dask.array&amp;lt;shape=(1068, 510), chunksize=(1068, 510)&amp;gt;
    lat          (y, x) float32 dask.array&amp;lt;shape=(1068, 510), chunksize=(1068, 510)&amp;gt;
  * time         (time) float64 1.0 2.0 3.0 4.0 5.0 ... 64.0 65.0 66.0 67.0 68.0
Dimensions without coordinates: x, y
Data variables:
    Mean_tasmoy  (time, y, x) float32 dask.array&amp;lt;shape=(68, 1068, 510), chunksize=(10, 1068, 510)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our xarray Dataset contains a single variable (Mean_tasmoy) which is stored as a dask.array. This is the result of loading files with open_mfdataset.&lt;/p&gt;

&lt;p&gt;Now we will use  regionmask module to create a gridded mask with the function regions_cls documented &lt;a href=&#34;https://regionmask.readthedocs.io/en/stable/generated/regionmask.Regions_cls.html#regionmask.Regions_cls&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With this function we will create an object able to mask ANUSPLIN gridded data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;province_mask_poly = regionmask.Regions_cls(name = &#39;PRENAME&#39;, numbers = list(range(0,13)), names = list(tmpWGS84.PRENAME), abbrevs = list(tmpWGS84.PRENAME), outlines = list(tmpWGS84.geometry.values[i] for i in range(0,13)))
province_mask_poly
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;13 &#39;PRENAME&#39; Regions ()
Newfoundland and Labrador Prince Edward Island Nova Scotia New Brunswick Quebec Ontario Manitoba Saskatchewan Alberta British Columbia Yukon Northwest Territories Nunavut
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are ready to apply the mask on the gridded dataset xarray ANUSPLIN.&lt;/p&gt;

&lt;p&gt;We select only the first timestep to speed up the process.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mask = province_mask_poly.mask(ds.isel(time = 0), lat_name=&#39;lat&#39;, lon_name=&#39;lon&#39;)
mask
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray (y: 1068, x: 510)&amp;gt;
array([[nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       ...,
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan]])
Coordinates:
  * y        (y) int64 0 1 2 3 4 5 6 7 ... 1061 1062 1063 1064 1065 1066 1067
  * x        (x) int64 0 1 2 3 4 5 6 7 8 ... 501 502 503 504 505 506 507 508 509
    lat      (y, x) float32 83.45833 83.375 83.291664 ... 41.125 41.041668
    lon      (y, x) float32 -140.95833 -140.95833 ... -52.04167 -52.04167
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mask
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray (y: 1068, x: 510)&amp;gt;
array([[nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       ...,
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan]])
Coordinates:
  * y        (y) int64 0 1 2 3 4 5 6 7 ... 1061 1062 1063 1064 1065 1066 1067
  * x        (x) int64 0 1 2 3 4 5 6 7 8 ... 501 502 503 504 505 506 507 508 509
    lat      (y, x) float32 83.45833 83.375 83.291664 ... 41.125 41.041668
    lon      (y, x) float32 -140.95833 -140.95833 ... -52.04167 -52.04167
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mask can be saved (for example as a NetCDF) for a later use.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mask.to_netcdf(&#39;./mask_all_province.nc&#39;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A quick visualisation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.figure(figsize=(15,8))
ax = plt.axes()
mask.plot(ax = ax)
province.plot(ax = ax, alpha = 0.8, facecolor = &#39;none&#39;, lw = 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0x1b989828&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./output_20_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-extract-one-province&#34;&gt;2- Extract one province&lt;/h3&gt;

&lt;p&gt;We will sho how to mask Ontario province.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ID_PROV = 5
print(province.PRNAME[ID_PROV])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Ontario
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mask
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray (y: 1068, x: 510)&amp;gt;
array([[nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       ...,
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan]])
Coordinates:
  * y        (y) int64 0 1 2 3 4 5 6 7 ... 1061 1062 1063 1064 1065 1066 1067
  * x        (x) int64 0 1 2 3 4 5 6 7 8 ... 501 502 503 504 505 506 507 508 509
    lat      (y, x) float32 83.45833 83.375 83.291664 ... 41.125 41.041668
    lon      (y, x) float32 -140.95833 -140.95833 ... -52.04167 -52.04167
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;out_sel2 = ds.where(mask == ID_PROV)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;out_sel2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:      (time: 68, x: 510, y: 1068)
Coordinates:
  * y            (y) int64 0 1 2 3 4 5 6 ... 1061 1062 1063 1064 1065 1066 1067
  * x            (x) int64 0 1 2 3 4 5 6 7 8 ... 502 503 504 505 506 507 508 509
    lon          (y, x) float32 dask.array&amp;lt;shape=(1068, 510), chunksize=(1068, 510)&amp;gt;
    lat          (y, x) float32 dask.array&amp;lt;shape=(1068, 510), chunksize=(1068, 510)&amp;gt;
  * time         (time) float64 1.0 2.0 3.0 4.0 5.0 ... 64.0 65.0 66.0 67.0 68.0
Data variables:
    Mean_tasmoy  (time, y, x) float32 dask.array&amp;lt;shape=(68, 1068, 510), chunksize=(10, 1068, 510)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quick visualisation, we will display the first step of our DataArray masked.&lt;/p&gt;

&lt;p&gt;For out_sel2 array :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.figure(figsize=(15,8))
ax = plt.axes()
out_sel2.Mean_tasmoy.isel(time = 0).plot(ax = ax)
province.plot(ax = ax, alpha = 0.8, facecolor = &#39;none&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0x18bc95f8&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./output_28_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;out_sel2.to_netcdf(&#39;./Ontario.nc&#39;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib.pylab as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import numpy as np
import matplotlib as mpl
from netCDF4 import Dataset, num2date
import warnings
warnings.filterwarnings(&amp;quot;ignore&amp;quot;)
import datetime
import xarray as xr
import pandas as pd

filename=&#39;./Ontario.nc&#39;
nc_fid=Dataset(filename,&#39;r&#39;)
data=nc_fid.variables[&#39;Mean_tasmoy&#39;][:].squeeze()
lons=nc_fid.variables[&#39;lon&#39;][:].squeeze()
lats=nc_fid.variables[&#39;lat&#39;][:].squeeze()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data.shape
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(68, 1068, 510)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s use Xarray to compute climatology over 1988-2017.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data_m = data[-30:,:,:]
clim_89_2017=data_m.mean(axis=0)
clim_89_2017.shape
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(1068, 510)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig=plt.figure(figsize=(28,16), frameon=True)  
ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-100,-75,40,58])
ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))      # couche ocean
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))       # couche land
ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))      # couche lac
   
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))    # couche frontieres
ax.add_feature(cfeature.RIVERS.with_scale(&#39;50m&#39;))     # couche rivières 
coast = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, scale=&#39;10m&#39;,     # ajout de la couche cotière 
                            facecolor=&#39;none&#39;, name=&#39;coastline&#39;)
ax.add_feature(coast, edgecolor=&#39;black&#39;)    
states_provinces = cfeature.NaturalEarthFeature(
            category=&#39;cultural&#39;,
            name=&#39;admin_1_states_provinces_lines&#39;,
            scale=&#39;10m&#39;,
            facecolor=&#39;none&#39;)
    
ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;) 

 
mm = ax.contourf(lons,\
                   lats,\
                   clim_89_2017,\
                   vmin=-10,\
                   vmax=10, \
                   transform=ccrs.PlateCarree(),\
                   levels=np.arange(-10, 10, 1.),\
                   cmap=plt.cm.jet )
ax.gridlines()

# Define gridline locations and draw the lines using cartopy&#39;s built-in gridliner:
xticks = np.arange(-150.0,-40.0,20)
yticks =np.arange(10,80,10)

cbar.set_label(u&#39;\n Projection = Lambert Conformal Conic \nResolution: 5 Arcs-Minutes (10 km)\nData provided by Natural Resources Canada / Created by Guillaume Dueymes&#39;, size=&#39;medium&#39;) # Affichage de la légende de la barre de couleur

cbar = plt.colorbar(mm,  shrink=0.75, drawedges=&#39;True&#39;,extend=&#39;both&#39;)
cbar.ax.tick_params(labelsize=17) 
    
plt.xlabel(u&#39;\n\n\nTemperature / Température (°C)&#39;,size=&#39;x-large&#39;)
string_title=u&#39;Climate normals of mean annual temperature (°C)\n 1988 - 2017\n&#39;
plt.title(string_title, size=&#39;xx-large&#39;)
plt.savefig(&#39;./ANUSPLIN_Ontario_10km_YEAR_CLIM_1988-2017.png&#39;, bbox_inches=&#39;tight&#39;, pad_inches=0.1)
plt.show() 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./output_34_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Web scraping using Python</title>
      <link>/post/scrap_eccc/</link>
      <pubDate>Fri, 07 Feb 2020 12:55:20 -0800</pubDate>
      <guid>/post/scrap_eccc/</guid>
      <description>

&lt;p&gt;﻿&lt;/p&gt;

&lt;h3 id=&#34;scraping-web-data-using-python&#34;&gt;Scraping web data using Python&lt;/h3&gt;

&lt;p&gt;In this tutorial, we  will see how to scrap data from Environment Canada webpage.&lt;/p&gt;

&lt;h3 id=&#34;1-exploring-the-structure-of-the-eccc-web-page&#34;&gt;1- Exploring the structure of the ECCC web page&lt;/h3&gt;

&lt;p&gt;We will extract the current weather conditions and weather forecast for &lt;a href=&#34;https://meteo.gc.ca/city/pages/qc-147_metric_f.html&#34; target=&#34;_blank&#34;&gt;Montreal&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import requests
import pandas as pd
# we download the web page
page = requests.get(&amp;quot;https://meteo.gc.ca/city/pages/qc-147_metric_e.html&amp;quot;)

# Using BeautifulSoup to analyze html code
from bs4 import BeautifulSoup

# we will analyze the previous content with BeautifulSoup
soup = BeautifulSoup(page.content,&#39;html.parser&#39;)
soup.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;/&amp;gt;,
 &amp;lt;meta content=&amp;quot;width=device-width, initial-scale=1&amp;quot; name=&amp;quot;viewport&amp;quot;/&amp;gt;,
 &amp;lt;meta content=&amp;quot;Environment Canada&amp;quot; name=&amp;quot;dcterms.creator&amp;quot;/&amp;gt;,
 &amp;lt;meta content=&amp;quot;eng&amp;quot; name=&amp;quot;dcterms.language&amp;quot; title=&amp;quot;ISO639-2&amp;quot;/&amp;gt;,
 &amp;lt;meta content=&amp;quot;Current conditions and forecasts including 7 day outlook, daily high/low temperature, warnings, chance of precipitation, pressure, humidity/wind chill (when applicable) historical data, normals, record values and sunrise/sunset times&amp;quot; name=&amp;quot;description&amp;quot;/&amp;gt;,
 &amp;lt;meta content=&amp;quot;meteorology;weather;weather warnings;weather forecasts&amp;quot; name=&amp;quot;dcterms.subject&amp;quot; title=&amp;quot;scheme&amp;quot;/&amp;gt;,
 &amp;lt;meta content=&amp;quot;2013-04-16&amp;quot; name=&amp;quot;dcterms.issued&amp;quot; title=&amp;quot;W3CDTF&amp;quot;/&amp;gt;,
 &amp;lt;meta content=&amp;quot;2020-02-07&amp;quot; name=&amp;quot;dcterms.modified&amp;quot; title=&amp;quot;W3CDTF&amp;quot;/&amp;gt;,
 &amp;lt;title&amp;gt;Montréal, QC - 7 Day Forecast - Environment Canada&amp;lt;/title&amp;gt;,
 &amp;lt;meta content=&amp;quot;Montréal, QC - 7 Day Forecast - Environment Canada&amp;quot; name=&amp;quot;dcterms.title&amp;quot;/&amp;gt;,
 &amp;lt;link href=&amp;quot;/template/gcweb/v5.0.1/assets/favicon.ico&amp;quot; rel=&amp;quot;icon&amp;quot; type=&amp;quot;image/x-icon&amp;quot;/&amp;gt;,
 &amp;lt;link href=&amp;quot;/template/gcweb/v5.0.1/css/theme.min.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;/&amp;gt;,
 &amp;lt;link href=&amp;quot;/v175/css/city/jquery-ui-1.10.3.custom.min.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;/&amp;gt;,
 &amp;lt;noscript&amp;gt;&amp;lt;link href=&amp;quot;/template/gcweb/v5.0.1/css/noscript.min.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;/&amp;gt;&amp;lt;/noscript&amp;gt;,
 &amp;lt;link href=&amp;quot;/template/gcweb/v5.0.1/css/noscript.min.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;/&amp;gt;,
 &amp;lt;link href=&amp;quot;/rss/city/qc-147_e.xml&amp;quot; rel=&amp;quot;alternate&amp;quot; title=&amp;quot;ATOM feed for Montréal - Weather - Environment Canada&amp;quot; type=&amp;quot;application/atom+xml&amp;quot;/&amp;gt;,
 &amp;lt;link href=&amp;quot;/rss/warning/qc-147_e.xml&amp;quot; rel=&amp;quot;alternate&amp;quot; title=&amp;quot;ATOM feed for Montréal - Warning - Environment Canada&amp;quot; type=&amp;quot;application/atom+xml&amp;quot;/&amp;gt;,
 &amp;lt;link href=&amp;quot;/v175/css/city/city.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;/&amp;gt;,
 &amp;lt;link href=&amp;quot;https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;/&amp;gt;,
 &amp;lt;link href=&amp;quot;/v175/css/wxotemplate/wxo.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;
 &amp;lt;link href=&amp;quot;/v175/css/wxotemplate/print-sm.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;/&amp;gt;
 &amp;lt;!--[if lte IE 9]&amp;gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;/v175/css/wxotemplate/wxo-ie8.css&amp;quot; /&amp;gt;&amp;lt;![endif]--&amp;gt;
 &amp;lt;/link&amp;gt;,
 &amp;lt;link href=&amp;quot;/v175/css/wxotemplate/print-sm.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;/&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;soup.title
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;title&amp;gt;Montréal, QC - 7 Day Forecast - Environment Canada&amp;lt;/title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-reading-current-conditions&#34;&gt;1-  Reading current conditions&lt;/h3&gt;

&lt;h4 id=&#34;column-1&#34;&gt;Column 1&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;conditions = soup.find(id=&amp;quot;mainContent&amp;quot;)
col1 = conditions.find_all(class_=&amp;quot;dl-horizontal wxo-conds-col1&amp;quot;)
today1 = col1[1]
#print(today1.prettify())
tmp1  = today1.select(&amp;quot;.mrgn-bttm-0&amp;quot;)
print(tmp1)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&amp;lt;dd class=&amp;quot;mrgn-bttm-0&amp;quot;&amp;gt;Light Snow and Blowing Snow&amp;lt;/dd&amp;gt;, &amp;lt;dd class=&amp;quot;mrgn-bttm-0 wxo-metric-hide&amp;quot;&amp;gt;98.5 &amp;lt;abbr title=&amp;quot;kilopascals&amp;quot;&amp;gt;kPa&amp;lt;/abbr&amp;gt;
&amp;lt;/dd&amp;gt;, &amp;lt;dd class=&amp;quot;mrgn-bttm-0 wxo-imperial-hide wxo-city-hidden&amp;quot;&amp;gt;29.1 inches&amp;lt;/dd&amp;gt;, &amp;lt;dd class=&amp;quot;mrgn-bttm-0&amp;quot;&amp;gt;Falling&amp;lt;/dd&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;short_desc = [tmp1[0].get_text()]
short_desc
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&#39;Light Snow and Blowing Snow&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pression = [tmp1[1].get_text().replace(&#39;\n&#39;,&#39;&#39;)]
trend =[ tmp1[3].get_text()]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;weather = pd.DataFrame({&amp;quot;short_desc&amp;quot;: short_desc,
                        &amp;quot;pression&amp;quot;:   pression,
                        &amp;quot;trend&amp;quot;:   trend,
                       })
weather
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;short_desc&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;pression&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;trend&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Light Snow and Blowing Snow&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;98.5 kPa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Falling&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;column-2&#34;&gt;Column 2&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;col2 = conditions.find_all(class_=&amp;quot;dl-horizontal wxo-conds-col2&amp;quot;)
today2 = col2[1]
#print(today2.prettify())
tmp2  = today2.select(&amp;quot;.mrgn-bttm-0&amp;quot;)
print(tmp2)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&amp;lt;dd class=&amp;quot;mrgn-bttm-0 wxo-metric-hide&amp;quot;&amp;gt;-6.7°&amp;lt;abbr title=&amp;quot;Celsius&amp;quot;&amp;gt;C&amp;lt;/abbr&amp;gt;
&amp;lt;/dd&amp;gt;, &amp;lt;dd class=&amp;quot;mrgn-bttm-0 wxo-imperial-hide wxo-city-hidden&amp;quot;&amp;gt;19.9°
                    &amp;lt;abbr title=&amp;quot;Fahrenheit&amp;quot;&amp;gt;F&amp;lt;/abbr&amp;gt;
&amp;lt;/dd&amp;gt;, &amp;lt;dd class=&amp;quot;mrgn-bttm-0 wxo-metric-hide&amp;quot;&amp;gt;-8.8°&amp;lt;abbr title=&amp;quot;Celsius&amp;quot;&amp;gt;C&amp;lt;/abbr&amp;gt;
&amp;lt;/dd&amp;gt;, &amp;lt;dd class=&amp;quot;mrgn-bttm-0 wxo-imperial-hide wxo-city-hidden&amp;quot;&amp;gt;16.2°&amp;lt;abbr title=&amp;quot;Fahrenheit&amp;quot;&amp;gt;F&amp;lt;/abbr&amp;gt;
&amp;lt;/dd&amp;gt;, &amp;lt;dd class=&amp;quot;mrgn-bttm-0&amp;quot;&amp;gt;85%&amp;lt;/dd&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;temperature = [tmp2[0].get_text().replace(&#39;\n&#39;,&#39;&#39;)]
rosee = [tmp2[2].get_text().replace(&#39;\n&#39;,&#39;&#39;)]
humidity = [tmp2[4].get_text().replace(&#39;\n&#39;,&#39;&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;weather = pd.DataFrame({&amp;quot;temperature&amp;quot;: temperature,
                        &amp;quot;temperature_rosee&amp;quot;:   rosee,
                        &amp;quot;humidity&amp;quot;:   humidity,
                       })
weather
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;temperature&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;temperature_rosee&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;humidity&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-6.7°C&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-8.8°C&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;85%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;column-3&#34;&gt;Column 3&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;col3 = conditions.find_all(class_=&amp;quot;dl-horizontal wxo-conds-col3&amp;quot;)
today3 = col3[1]
#print(today2.prettify())
tmp3  = today3.select(&amp;quot;.mrgn-bttm-0&amp;quot;)
print(tmp3)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&amp;lt;dd class=&amp;quot;longContent mrgn-bttm-0 wxo-metric-hide&amp;quot;&amp;gt;
&amp;lt;abbr title=&amp;quot;North&amp;quot;&amp;gt;N&amp;lt;/abbr&amp;gt; 35  &amp;lt;br class=&amp;quot;visible-xs&amp;quot;/&amp;gt;gust 53 &amp;lt;abbr title=&amp;quot;kilometres per hour&amp;quot;&amp;gt;km/h&amp;lt;/abbr&amp;gt;
&amp;lt;/dd&amp;gt;, &amp;lt;dd class=&amp;quot;longContent mrgn-bttm-0 wxo-imperial-hide wxo-city-hidden&amp;quot;&amp;gt;
&amp;lt;abbr title=&amp;quot;North&amp;quot;&amp;gt;N&amp;lt;/abbr&amp;gt; 22  &amp;lt;br class=&amp;quot;visible-xs&amp;quot;/&amp;gt;gust 33 &amp;lt;abbr title=&amp;quot;miles per hour&amp;quot;&amp;gt;mph&amp;lt;/abbr&amp;gt;
&amp;lt;/dd&amp;gt;, &amp;lt;dd class=&amp;quot;mrgn-bttm-0 wxo-metric-hide&amp;quot;&amp;gt;-16&amp;lt;/dd&amp;gt;, &amp;lt;dd class=&amp;quot;mrgn-bttm-0 wxo-imperial-hide wxo-city-hidden&amp;quot;&amp;gt;3&amp;lt;/dd&amp;gt;, &amp;lt;dd class=&amp;quot;mrgn-bttm-0 wxo-metric-hide&amp;quot;&amp;gt;0.8 &amp;lt;abbr title=&amp;quot;kilometres&amp;quot;&amp;gt;km&amp;lt;/abbr&amp;gt;
&amp;lt;/dd&amp;gt;, &amp;lt;dd class=&amp;quot;mrgn-bttm-0 wxo-imperial-hide wxo-city-hidden&amp;quot;&amp;gt;0.5 mile
                        &amp;lt;/dd&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;wind = [tmp3[0].get_text().replace(&#39;\n&#39;,&#39;&#39;)]
visibility = [tmp3[2].get_text().replace(&#39;\n&#39;,&#39;&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;weather = pd.DataFrame({&amp;quot;short_desc&amp;quot;: short_desc,
                        &amp;quot;pression&amp;quot;:   pression,
                        &amp;quot;Trend&amp;quot;:   trend,
                        &amp;quot;temperature&amp;quot;: temperature,
                        &amp;quot;temperature_rosee&amp;quot;:   rosee,
                        &amp;quot;humidity&amp;quot;:   humidity,
                        &amp;quot;wind&amp;quot;:   wind,
                        &amp;quot;visibility&amp;quot;:   visibility,
                       })
weather
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;short_desc&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;pression&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Trend&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;temperature&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;temperature_rosee&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;humidity&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;wind&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;visibility&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Light Snow and Blowing Snow&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;98.5 kPa&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Falling&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-6.7°C&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-8.8°C&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;85%&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N 35  gust 53 km/h&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-16&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;weather.to_csv(&amp;quot;current.csv&amp;quot;, header = True, sep = &#39;,&#39;,encoding=&#39;utf-8&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-reading-forecasting-values&#34;&gt;2-  Reading forecasting values&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;period_tags = soup.find(id=&amp;quot;mainContent&amp;quot;)
row1 = period_tags.find_all(class_=&amp;quot;div-row div-row1 div-row-head&amp;quot;)
row1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&amp;lt;div class=&amp;quot;div-row div-row1 div-row-head&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;/forecast/hourly/qc-147_metric_e.html&amp;quot;&amp;gt;&amp;lt;strong title=&amp;quot;Friday&amp;quot;&amp;gt;Fri&amp;lt;/strong&amp;gt;&amp;lt;br/&amp;gt;7 &amp;lt;abbr title=&amp;quot;February&amp;quot;&amp;gt;Feb&amp;lt;/abbr&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;,
 &amp;lt;div class=&amp;quot;div-row div-row1 div-row-head&amp;quot;&amp;gt;
 &amp;lt;strong title=&amp;quot;Saturday&amp;quot;&amp;gt;Sat&amp;lt;/strong&amp;gt;&amp;lt;br/&amp;gt;8 &amp;lt;abbr title=&amp;quot;February&amp;quot;&amp;gt;Feb&amp;lt;/abbr&amp;gt;
 &amp;lt;/div&amp;gt;,
 &amp;lt;div class=&amp;quot;div-row div-row1 div-row-head&amp;quot;&amp;gt;
 &amp;lt;strong title=&amp;quot;Sunday&amp;quot;&amp;gt;Sun&amp;lt;/strong&amp;gt;&amp;lt;br/&amp;gt;9 &amp;lt;abbr title=&amp;quot;February&amp;quot;&amp;gt;Feb&amp;lt;/abbr&amp;gt;
 &amp;lt;/div&amp;gt;,
 &amp;lt;div class=&amp;quot;div-row div-row1 div-row-head&amp;quot;&amp;gt;
 &amp;lt;strong title=&amp;quot;Monday&amp;quot;&amp;gt;Mon&amp;lt;/strong&amp;gt;&amp;lt;br/&amp;gt;10 &amp;lt;abbr title=&amp;quot;February&amp;quot;&amp;gt;Feb&amp;lt;/abbr&amp;gt;
 &amp;lt;/div&amp;gt;,
 &amp;lt;div class=&amp;quot;div-row div-row1 div-row-head&amp;quot;&amp;gt;
 &amp;lt;strong title=&amp;quot;Tuesday&amp;quot;&amp;gt;Tue&amp;lt;/strong&amp;gt;&amp;lt;br/&amp;gt;11 &amp;lt;abbr title=&amp;quot;February&amp;quot;&amp;gt;Feb&amp;lt;/abbr&amp;gt;
 &amp;lt;/div&amp;gt;,
 &amp;lt;div class=&amp;quot;div-row div-row1 div-row-head&amp;quot;&amp;gt;
 &amp;lt;strong title=&amp;quot;Wednesday&amp;quot;&amp;gt;Wed&amp;lt;/strong&amp;gt;&amp;lt;br/&amp;gt;12 &amp;lt;abbr title=&amp;quot;February&amp;quot;&amp;gt;Feb&amp;lt;/abbr&amp;gt;
 &amp;lt;/div&amp;gt;,
 &amp;lt;div class=&amp;quot;div-row div-row1 div-row-head&amp;quot;&amp;gt;
 &amp;lt;strong title=&amp;quot;Thursday&amp;quot;&amp;gt;Thu&amp;lt;/strong&amp;gt;&amp;lt;br/&amp;gt;13 &amp;lt;abbr title=&amp;quot;February&amp;quot;&amp;gt;Feb&amp;lt;/abbr&amp;gt;
 &amp;lt;/div&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;period_tags = soup.find(id=&amp;quot;mainContent&amp;quot;)
row1 = period_tags.find_all(class_=&amp;quot;div-row div-row1 div-row-head&amp;quot;)
periods = [pt.get_text().replace(&#39;\xa0&#39;, &#39; &#39;).replace(&#39;\n&#39;,&#39;&#39;) for pt in row1]
periods
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&#39;Fri7 Feb&#39;,
 &#39;Sat8 Feb&#39;,
 &#39;Sun9 Feb&#39;,
 &#39;Mon10 Feb&#39;,
 &#39;Tue11 Feb&#39;,
 &#39;Wed12 Feb&#39;,
 &#39;Thu13 Feb&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;period_tags = soup.find(id=&amp;quot;mainContent&amp;quot;)
row2 = period_tags.find_all(class_=&amp;quot;div-row div-row2 div-row-data&amp;quot;)
row2[1]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;div-row div-row2 div-row-data&amp;quot;&amp;gt;
&amp;lt;img alt=&amp;quot;A mix of sun and cloud&amp;quot; class=&amp;quot;center-block&amp;quot; height=&amp;quot;51&amp;quot; src=&amp;quot;/weathericons/02.gif&amp;quot; width=&amp;quot;60&amp;quot;/&amp;gt;&amp;lt;p class=&amp;quot;mrgn-bttm-0&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;high wxo-metric-hide&amp;quot; title=&amp;quot;max&amp;quot;&amp;gt;-13°&amp;lt;abbr title=&amp;quot;Celsius&amp;quot;&amp;gt;C&amp;lt;/abbr&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;high wxo-imperial-hide wxo-city-hidden&amp;quot; title=&amp;quot;max&amp;quot;&amp;gt;9°&amp;lt;abbr title=&amp;quot;Fahrenheit&amp;quot;&amp;gt;F&amp;lt;/abbr&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p class=&amp;quot;mrgn-bttm-0 pop text-center&amp;quot;&amp;gt; &amp;lt;/p&amp;gt;
&amp;lt;p class=&amp;quot;mrgn-bttm-0&amp;quot;&amp;gt;A mix of sun and cloud&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;period_tags = soup.find(id=&amp;quot;mainContent&amp;quot;)
row2 = period_tags.find_all(class_=&amp;quot;div-row div-row2 div-row-data&amp;quot;)
temperature_f = [pt.get_text().split(&#39;\n&#39;)[1][:] for pt in row2]
temperature_f
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&#39;-5°C23°F&#39;,
 &#39;-13°C9°F&#39;,
 &#39;-6°C21°F&#39;,
 &#39;-3°C27°F&#39;,
 &#39;-2°C28°F&#39;,
 &#39;-6°C21°F&#39;,
 &#39;-6°C21°F&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;temperature_2=[]
for val in enumerate(temperature_f):
    temperature_2.append(val[1].split(&#39;C&#39;)[0] + &#39;C&#39;)
temperature_2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&#39;-5°C&#39;, &#39;-13°C&#39;, &#39;-6°C&#39;, &#39;-3°C&#39;, &#39;-2°C&#39;, &#39;-6°C&#39;, &#39;-6°C&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;conditions_f = [pt.get_text().split(&#39;\n&#39;)[3] for pt in row2]
conditions_f
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&#39;Snow at times heavy and blowing snow&#39;,
 &#39;A mix of sun and cloud&#39;,
 &#39;Sunny&#39;,
 &#39;Snow&#39;,
 &#39;Periods of snow&#39;,
 &#39;A mix of sun and cloud&#39;,
 &#39;Chance of flurries&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;weather_f = pd.DataFrame({&amp;quot;Period&amp;quot;: periods,
                       &amp;quot;temperature_f&amp;quot;: temperature_f,
                       &amp;quot;conditions_f&amp;quot;:conditions_f,
                       })
weather_f

&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Period&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;temperature_f&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;conditions_f&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Fri7 Feb&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-5°C23°F&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Snow at times heavy and blowing snow&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Sat8 Feb&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-13°C9°F&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;A mix of sun and cloud&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Sun9 Feb&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-6°C21°F&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Sunny&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Mon10 Feb&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-3°C27°F&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Snow&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Tue11 Feb&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-2°C28°F&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Periods of snow&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Wed12 Feb&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-6°C21°F&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;A mix of sun and cloud&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Thu13 Feb&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-6°C21°F&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Chance of flurries&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;3-download-of-weather-icons-for-the-next-7-days&#34;&gt;3- Download of weather icons for the next 7 days&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from urllib import request
row3 = period_tags.find_all(class_=&amp;quot;div-row div-row2 div-row-data&amp;quot;)
i = 0
for images in row3:
    s = images.find(&#39;img&#39;)
    f = open(str(i) + &#39;.gif&#39;, &#39;wb&#39;)
    f.write(request.urlopen(&amp;quot;https://meteo.gc.ca/weathericons/&amp;quot;+str(s)[str(s).find(&#39;gif&#39;)-3:(str(s).find(&#39;gif&#39;))-1]+&amp;quot;.gif&amp;quot;).read())
    f.close() 
    i += 1 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;scrap.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;weather_f.to_csv(&amp;quot;forecast.csv&amp;quot;, header = True, sep = &#39;,&#39;,encoding=&#39;utf-8&#39;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Web Map Service and Cartopy</title>
      <link>/post/cartopy_wms/</link>
      <pubDate>Fri, 07 Feb 2020 12:42:01 -0800</pubDate>
      <guid>/post/cartopy_wms/</guid>
      <description>

&lt;h2 id=&#34;cartopy-add-wms-image-from-environment-canada&#34;&gt;Cartopy: Add WMS image from Environment Canada&lt;/h2&gt;

&lt;p&gt;In this tutorial, we will use a Web Map Service and Cartopy python library to display products from Environment Canada&lt;/p&gt;

&lt;p&gt;A Web Map Service (WMS) defines an interface that allows a client to get maps of geospatial data and gain detailed information on specific features shown on the map. A &amp;ldquo;map&amp;rdquo; is defined here as a visual representation of geospatial data, not the geospatial data itself.&lt;/p&gt;

&lt;p&gt;Environnement Canada generates and archives  moasic .png images every 5 minutes. These images are served as a Web Map Service. This notebook shows how to add those images to a cartopy figure axes.&lt;/p&gt;

&lt;p&gt;Here is a &lt;a href=&#34;https://eccc-msc.github.io/open-data/msc-data/readme_fr/&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt; with availables datasets.&lt;/p&gt;

&lt;p&gt;Data Source: &lt;a href=&#34;https://geo.weather.gc.ca/geomet?service=WMS&amp;amp;version=1.3.0&amp;amp;request=GetCapabilities&amp;amp;layer=RADAR_1KM_RRAI&#34; target=&#34;_blank&#34;&gt;https://geo.weather.gc.ca/geomet?service=WMS&amp;amp;version=1.3.0&amp;amp;request=GetCapabilities&amp;amp;layer=RADAR_1KM_RRAI&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from datetime import datetime
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import matplotlib.pyplot as plt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-plot-rrai-1-km-for-a-specific-date&#34;&gt;1- plot RRAI 1 km for a specific date&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;DATE = datetime(2020, 2, 7, 19, 0)

fig = plt.figure(figsize=(14, 8))

ax = fig.add_subplot(1, 1, 1,projection=ccrs.LambertConformal(central_longitude=-100))
ax.add_feature(cfeature.COASTLINE.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.STATES.with_scale(&#39;50m&#39;))

# Date string format for data request
strDATE = DATE.strftime(&#39;%Y-%m-%dT%H:%M:%SZ&#39;)

ax.set_title(&#39;%s&#39; % DATE.strftime(&#39;%H:%M UTC %d %b %Y&#39;), loc=&#39;right&#39;)
ax.set_title( &#39;RADAR_1km_RRAI&#39;, loc=&#39;left&#39;, fontweight=&#39;bold&#39;, fontsize=15)
    
ax.add_wms(wms=&#39;https://geo.weather.gc.ca/geomet?service=WMS&amp;amp;version=1.3.0&amp;amp;request=GetCapabilities&amp;amp;layer=RADAR_1KM_RRAI&#39;,
                layers=&#39;RADAR_1KM_RRAI&#39; ,
                wms_kwargs={&#39;time&#39;:strDATE, &#39;transparent&#39;:True}, zorder=10)
    
ax.stock_img()
ax.set_extent((-80, -60, 40, 52))   

fig.subplots_adjust(wspace=0.02)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_3_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-plot-the-most-recent-time-available&#34;&gt;2- Plot the most recent time available&lt;/h3&gt;

&lt;p&gt;Simply leave out the &amp;lsquo;time&amp;rsquo; argument in the wms_kwargs dict. The transparent option should default to True.&lt;/p&gt;

&lt;p&gt;The timestamp of the image is retrieved from the &lt;a href=&#34;https://mesonet.agron.iastate.edu/data/gis/images/4326/USCOMP/n0q_0.json&#34; target=&#34;_blank&#34;&gt;JSON file&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Get the metadata for the most recent NEXRAD image from JSON file.
import requests

def get_timestamp():
    f = requests.get(&#39;https://mesonet.agron.iastate.edu/data/gis/images/4326/USCOMP/n0q_0.json&#39;).json()
    validDATE = datetime.strptime(f[&#39;meta&#39;][&#39;valid&#39;], &#39;%Y-%m-%dT%H:%M:%SZ&#39;)
    return validDATE
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(&#39;Latest Image:&#39;, get_timestamp())
print(&#39;Current Time:&#39;, datetime.utcnow())

diff = (datetime.utcnow()-get_timestamp())
print(&#39;Difference (minutes):&#39;, diff.seconds/60)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Latest Image: 2020-02-07 19:15:00
Current Time: 2020-02-07 19:17:32.276824
Difference (minutes): 2.533333333333333
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(14, 8))

ax = fig.add_subplot(1, 1, 1,
                     projection=ccrs.LambertConformal(central_longitude=-100))
ax.add_feature(cfeature.COASTLINE.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.STATES.with_scale(&#39;50m&#39;))

# Date string format for data reques

ax.set_title(&#39;Most Recent Time&#39;, fontweight=&#39;bold&#39;, loc=&#39;left&#39;)
ax.set_title(&#39;%s&#39; % get_timestamp().strftime(&#39;%H:%M UTC %d %b %Y&#39;), loc=&#39;right&#39;)
ax.add_wms(wms=&#39;https://geo.weather.gc.ca/geomet?service=WMS&amp;amp;version=1.3.0&amp;amp;request=GetCapabilities&amp;amp;layer=RADAR_1KM_RRAI&#39;,
           layers=&#39;RADAR_1KM_RRAI&#39;,
           wms_kwargs={&#39;transparent&#39;:True}, zorder=10)

# ^ For current time (most recent time in last 5 minutes), leave the &#39;time&#39; 
#   wms_kwargs unassigned. Transparetn should be True by default, but it
#   doesn&#39;t hurt to be explicit.

ax.set_extent((-80, -60, 40, 52)) 

fig.subplots_adjust(wspace=0.02)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_7_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3&#34;&gt;3&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(15, 5))

ax = fig.add_subplot(1, 2, 1,
                         projection=ccrs.LambertConformal(central_longitude=-100))
ax.add_feature(cfeature.COASTLINE.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.STATES.with_scale(&#39;50m&#39;))
    
# Date string format for data request
strDATE = DATE.strftime(&#39;%Y-%m-%dT%H:%M:%SZ&#39;)

ax.set_title(&#39;Most Recent Time&#39;, fontweight=&#39;bold&#39;, loc=&#39;left&#39;)
ax.set_title(&#39;%s&#39; % get_timestamp().strftime(&#39;%H:%M UTC %d %b %Y&#39;), loc=&#39;right&#39;)
ax.add_wms(wms=&#39;https://geo.weather.gc.ca/geomet?service=WMS&amp;amp;version=1.3.0&amp;amp;request=GetCapabilities&amp;amp;layer=RADAR_1KM_RRAI&#39;,
           layers=&#39;RADAR_1KM_RRAI&#39;,
           wms_kwargs={&#39;transparent&#39;:True}, zorder=10)
ax.set_extent((-80, -60, 40, 52))
# ^ If you add a background image or use tiles you neet to set transparent
#   as True and set the zorder as a higher number, i.e. 10.
    
ax.stock_img()
    
ax.set_extent([-120, -75, 23, 50])   
ax = fig.add_subplot(1, 2, 2,projection=ccrs.LambertConformal(central_longitude=-100))
ax.add_feature(cfeature.COASTLINE.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.STATES.with_scale(&#39;50m&#39;))

# Date string format for data reques
# https://mesonet.agron.iastate.edu/docs/nexrad_mosaic/

ax.set_title(&#39;Most Recent Time&#39;, fontweight=&#39;bold&#39;, loc=&#39;left&#39;)
ax.set_title(&#39;%s&#39; % get_timestamp().strftime(&#39;%H:%M UTC %d %b %Y&#39;), loc=&#39;right&#39;)
ax.add_wms(wms=&#39;https://geo.weather.gc.ca/geomet?service=WMS&amp;amp;version=1.3.0&amp;amp;request=GetCapabilities&amp;amp;layer=RADAR_1KM_RRAI&#39;,
           layers=&#39;RADAR_1KM_RRAI&#39;,
           wms_kwargs={&#39;transparent&#39;:True}, zorder=10)
ax.set_extent((-80, -60, 40, 52)) 
fig.subplots_adjust(wspace=0.02)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_9_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;An other example using &lt;a href=&#34;https://mesonet.agron.iastate.edu/docs/nexrad_composites/&#34; target=&#34;_blank&#34;&gt;NEXRAD mosaic&lt;/a&gt;  image from Iowa Environmental Mesonet.&lt;/p&gt;

&lt;p&gt;See the data source URL for dBZ colormaps. You can generate an approximate colormap with MetPy&amp;rsquo;s NWSReflectivity and NWSReflectivityExpanded ctables.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N0Q: Base Reflectivity - 8 bit/0.5 dbz resolution&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;colorbars&#34;&gt;Colorbars&lt;/h4&gt;

&lt;p&gt;See the data source website for the real colormaps.&lt;/p&gt;

&lt;p&gt;Approximate colorbars can be made with metpy. The NWSReflectivity colormap is nearly exact for N0R, but NWSReflectivityExpanded is very different for N0Q. When I need it, I probably will make a custom colormap sometime in the future.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from metpy.plots import colortables
import numpy as np
ctable = &#39;NWSReflectivityExpanded&#39;
norm, cmap = colortables.get_with_steps(ctable, 5, 2.5)

fig = plt.figure(figsize=(14, 8))

ax = fig.add_subplot(1, 1, 1,projection=ccrs.LambertConformal(central_longitude=-100))
ax.add_feature(cfeature.COASTLINE.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.STATES.with_scale(&#39;50m&#39;))

# Date string format for data reques
# https://mesonet.agron.iastate.edu/docs/nexrad_mosaic/

ax.set_title(&#39;Most Recent Time&#39;, fontweight=&#39;bold&#39;, loc=&#39;left&#39;)
ax.set_title(&#39;%s&#39; % get_timestamp().strftime(&#39;%H:%M UTC %d %b %Y&#39;), loc=&#39;right&#39;)
ax.add_wms(wms=&#39;https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0q-t.cgi?&#39;,
           layers=&#39;nexrad-n0q-wmst&#39;,
           wms_kwargs={&#39;transparent&#39;:True}, zorder=10)

# ^ For current time (most recent time in last 5 minutes), leave the &#39;time&#39; 
#   wms_kwargs unassigned. Transparetn should be True by default, but it
#   doesn&#39;t hurt to be explicit.
norm, cmap = colortables.get_with_steps(ctable, 5, 2.5)

fig = plt.figure(figsize=(5,.1))

# Make a placeholder mesh that the colorbar will be made with,
# then remove the axis and the image
im = plt.pcolormesh(np.ones([1,1]),norm=norm, cmap=cmap)
plt.axis(&#39;off&#39;)
im.remove()

# Add the colorbar
cbar_ax = fig.add_axes([0, .5, 1, 3])
cbar = fig.colorbar(im, cax=cbar_ax, orientation=&#39;horizontal&#39;,
                    label=&#39;N0Q: &#39; + ctable)

ax.set_extent((-80, -60, 40, 52)) 

fig.subplots_adjust(wspace=0.02)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_11_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;output_11_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can combine these two differents products:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(15, 5))

ax = fig.add_subplot(1, 2, 1,projection=ccrs.LambertConformal(central_longitude=-100))
ax.add_feature(cfeature.COASTLINE.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.STATES.with_scale(&#39;50m&#39;))
    
# Date string format for data request
strDATE = DATE.strftime(&#39;%Y-%m-%dT%H:%M:%SZ&#39;)

ax.set_title(&#39;RADAR_1km_RRAI&#39;, fontweight=&#39;bold&#39;, loc=&#39;left&#39;)
ax.set_title(&#39;%s&#39; % get_timestamp().strftime(&#39;%H:%M UTC %d %b %Y&#39;), loc=&#39;right&#39;)
ax.add_wms(wms=&#39;https://geo.weather.gc.ca/geomet?service=WMS&amp;amp;version=1.3.0&amp;amp;request=GetCapabilities&amp;amp;layer=RADAR_1KM_RRAI&#39;,
           layers=&#39;RADAR_1KM_RRAI&#39;,
           wms_kwargs={&#39;transparent&#39;:True}, zorder=10)
# ^ If you add a background image or use tiles you neet to set transparent
#   as True and set the zorder as a higher number, i.e. 10.
ax.set_extent([-120, -75, 23, 50])  

ax = fig.add_subplot(1, 2, 2,projection=ccrs.LambertConformal(central_longitude=-100))
ax.add_feature(cfeature.COASTLINE.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.STATES.with_scale(&#39;50m&#39;))

# Date string format for data reques
# https://mesonet.agron.iastate.edu/docs/nexrad_mosaic/

ax.set_title(&#39;NOQ&#39;, fontweight=&#39;bold&#39;, loc=&#39;left&#39;)
ax.set_title(&#39;%s&#39; % get_timestamp().strftime(&#39;%H:%M UTC %d %b %Y&#39;), loc=&#39;right&#39;)
ax.add_wms(wms=&#39;https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0q-t.cgi?&#39;,
           layers=&#39;nexrad-n0q-wmst&#39;,
           wms_kwargs={&#39;transparent&#39;:True}, zorder=10)
ax.set_extent((-120, -75, 23, 50)) 
fig.subplots_adjust(wspace=0.02)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_13_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;exemple-2-gdps&#34;&gt;Exemple 2 : GDPS&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(14, 8))

ax = fig.add_subplot(1, 1, 1,
                     projection=ccrs.LambertConformal(central_longitude=-100))
# Date string format for data reques
ax.set_title(&#39;Most Recent Time&#39;, fontweight=&#39;bold&#39;, loc=&#39;left&#39;)
ax.set_title(&#39;%s&#39; % get_timestamp().strftime(&#39;%H:%M UTC %d %b %Y&#39;), loc=&#39;right&#39;)
ax.add_wms(wms=&#39;https://geo.weather.gc.ca/geomet?service=WMS&amp;amp;version=1.3.0&amp;amp;request=GetCapabilities&amp;amp;layer=GDPS.ETA_TT&#39;,
           layers=&#39;GDPS.ETA_TT&#39;,
           wms_kwargs={&#39;transparent&#39;:True}, zorder=10)

ax.add_wms(wms=&#39;https://geo.weather.gc.ca/geomet?service=WMS&amp;amp;version=1.3.0&amp;amp;request=GetCapabilities&amp;amp;layer=GDPS.ETA_UU&#39;,
           layers=&#39;GDPS.ETA_UU&#39;,
           wms_kwargs={&#39;transparent&#39;:True}, zorder=10)

ax.add_feature(cfeature.COASTLINE.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))
ax.add_feature(cfeature.STATES.with_scale(&#39;50m&#39;))

ax.set_extent((-120, -75, 23, 50))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_16_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Create Synoptic NARR map</title>
      <link>/post/narr_synoptic/</link>
      <pubDate>Fri, 07 Feb 2020 11:31:00 -0800</pubDate>
      <guid>/post/narr_synoptic/</guid>
      <description>

&lt;h3 id=&#34;working-with-netcd4-python-data-synoptic-map&#34;&gt;Working with Netcd4-python data: Synoptic map&lt;/h3&gt;

&lt;p&gt;In this tutorial, we will use the features of the Python xarray library to process and analyze Netcdf files.
We will then use matplotlib to plot it, and cartopy to map our analyse.&lt;/p&gt;

&lt;p&gt;We will see the different steps to plot an exemple of synoptic map over North America with:
    + geopotential 850hpa
    + Temperature 850hpa
    + UU,VV 250hpa&lt;/p&gt;

&lt;p&gt;We fist import the necessary packages. The plt.rcParams[&amp;lsquo;figure.figsize&amp;rsquo;] just sets the size of the inline figures in this notebook to make them larger and easier to read.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import xarray as xr
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import matplotlib.pyplot as plt
import matplotlib as mpl
import numpy as np
import warnings
warnings.filterwarnings(&amp;quot;ignore&amp;quot;)
plt.rcParams[&#39;figure.figsize&#39;] = (20, 20)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will work with fields from NARR reanalysis at pressure levels.&lt;/p&gt;

&lt;p&gt;Data can be directly download on this &lt;a href=&#34;ftp://ftp.cdc.noaa.gov/Datasets/NARR/pressure/&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tas = xr.open_dataset(&#39;J:/REANALYSES/NARR/3hrs/NARR_air_lc_2018_01_3hrs.nc&#39;)
uu =  xr.open_dataset(&#39;J:/REANALYSES/NARR/3hrs/NARR_uwnd_lc_2018_01_3hrs.nc&#39;)
vv =  xr.open_dataset(&#39;J:/REANALYSES/NARR/3hrs/NARR_vwnd_lc_2018_01_3hrs.nc&#39;)
omega =  xr.open_dataset(&#39;J:/REANALYSES/NARR/Daily/omega/NARR_omega_lc_2018_01_d.nc&#39;)
hgt =  xr.open_dataset(&#39;J:/REANALYSES/NARR/3hrs/NARR_hgt_lc_2018_01_3hrs.nc&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;exploring-the-data&#34;&gt;- Exploring the data&lt;/h3&gt;

&lt;p&gt;We can quickly explore our datasets by using some methods of the xarray library:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- DS.var
- DS.dims
= DS.coords
- DS.attrs
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;hgt
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:            (level: 29, time: 248, x: 349, y: 277)
Coordinates:
  * time               (time) datetime64[ns] 2018-01-01 ... 2018-01-31T21:00:00
  * level              (level) float32 1000.0 975.0 950.0 ... 150.0 125.0 100.0
    lat                (y, x) float32 ...
    lon                (y, x) float32 ...
  * y                  (y) float32 0.0 32463.0 64926.0 ... 8927325.0 8959788.0
  * x                  (x) float32 0.0 32463.0 64926.0 ... 11264660.0 11297120.0
Data variables:
    Lambert_Conformal  int32 ...
    hgt                (time, level, y, x) float32 ...
Attributes:
    Conventions:    CF-1.2
    centerlat:      50.0
    centerlon:      -107.0
    comments:       
    institution:    National Centers for Environmental Prediction
    latcorners:     [ 1.000001  0.897945 46.3544   46.63433 ]
    loncorners:     [-145.5       -68.32005    -2.569891  148.6418  ]
    platform:       Model
    standardpar1:   50.0
    standardpar2:   50.000001
    title:          8x Daily NARR
    history:        created Mon Jul 18 17:37:00 MDT 2016 by NOAA/ESRL/PSD
    dataset_title:  NCEP North American Regional Reanalysis (NARR)
    references:     https://www.esrl.noaa.gov/psd/data/gridded/data.narr.html
    source:         http://www.emc.ncep.noaa.gov/mmb/rreanl/index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;hgt.coords
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Coordinates:
  * time     (time) datetime64[ns] 2018-01-01 ... 2018-01-31T21:00:00
  * level    (level) float32 1000.0 975.0 950.0 925.0 ... 150.0 125.0 100.0
    lat      (y, x) float32 ...
    lon      (y, x) float32 ...
  * y        (y) float32 0.0 32463.0 64926.0 ... 8894862.0 8927325.0 8959788.0
  * x        (x) float32 0.0 32463.0 64926.0 ... 11264660.0 11297120.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can quickly explore our datasets by using some methods of the xarray library.&lt;/p&gt;

&lt;p&gt;We want to analyse a specific date : 13/01/2018 at 12UTC.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tas.time
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray &#39;time&#39; (time: 248)&amp;gt;
array([&#39;2018-01-01T00:00:00.000000000&#39;, &#39;2018-01-01T03:00:00.000000000&#39;,
       &#39;2018-01-01T06:00:00.000000000&#39;, ..., &#39;2018-01-31T15:00:00.000000000&#39;,
       &#39;2018-01-31T18:00:00.000000000&#39;, &#39;2018-01-31T21:00:00.000000000&#39;],
      dtype=&#39;datetime64[ns]&#39;)
Coordinates:
  * time     (time) datetime64[ns] 2018-01-01 ... 2018-01-31T21:00:00
Attributes:
    axis:                T
    coordinate_defines:  point
    delta_t:             0000-00-00 03:00:00
    long_name:           Time
    standard_name:       time
    actual_range:        [1910952. 1911693.]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#To select a specifi date: 
date = &#39;2018-01-13T12&#39;
tas.sel(time=date).sel(level=500).isel(x=slice(60,340), y=slice(50,230))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:            (x: 280, y: 180)
Coordinates:
    time               datetime64[ns] 2018-01-13T12:00:00
    level              float32 500.0
    lat                (y, x) float32 ...
    lon                (y, x) float32 ...
  * y                  (y) float32 1623150.0 1655613.0 ... 7401564.0 7434027.0
  * x                  (x) float32 1947780.0 1980243.0 ... 10972490.0 11004960.0
Data variables:
    Lambert_Conformal  int32 ...
    air                (y, x) float32 ...
Attributes:
    Conventions:    CF-1.2
    centerlat:      50.0
    centerlon:      -107.0
    comments:       
    institution:    National Centers for Environmental Prediction
    latcorners:     [ 1.000001  0.897945 46.3544   46.63433 ]
    loncorners:     [-145.5       -68.32005    -2.569891  148.6418  ]
    platform:       Model
    standardpar1:   50.0
    standardpar2:   50.000001
    title:          8x Daily NARR
    history:        created Mon Jul 18 17:31:43 MDT 2016 by NOAA/ESRL/PSD
    dataset_title:  NCEP North American Regional Reanalysis (NARR)
    references:     https://www.esrl.noaa.gov/psd/data/gridded/data.narr.html
    source:         http://www.emc.ncep.noaa.gov/mmb/rreanl/index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;hgt850 = hgt[&#39;hgt&#39;].sel(time=date).sel(level=850).isel(x=slice(60,340), y=slice(50,230))
tt850 = tas[&#39;air&#39;].sel(time=date).sel(level=850).isel(x=slice(60,340), y=slice(50,230))
urel250 = uu[&#39;uwnd&#39;].sel(time=date).sel(level=250).isel(x=slice(60,340), y=slice(50,230))
vrel250 = vv[&#39;vwnd&#39;].sel(time=date).sel(level=250).isel(x=slice(60,340), y=slice(50,230))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def plotMap():
    #Set the projection information
    proj = ccrs.LambertConformal(central_longitude=-97.0,central_latitude=53, standard_parallels=[53])
    #Create a figure with an axes object on which we will plot. Pass the projection to that axes.
    fig, ax = plt.subplots(subplot_kw=dict(projection=proj))
    
    #Zoom in
    #ax.set_extent([-140,-60,10,70])
    
    #Add map features
    ax.add_feature(cfeature.LAND, facecolor=&#39;0.9&#39;) #Grayscale colors can be set using 0 (black) to 1 (white)
    ax.add_feature(cfeature.LAKES, alpha=0.9)  #Alpha sets transparency (0 is transparent, 1 is solid)
    ax.add_feature(cfeature.BORDERS, zorder=10)
    ax.add_feature(cfeature.COASTLINE, zorder=10)

    #We can use additional features from Natural Earth (http://www.naturalearthdata.com/features/)
    states_provinces = cfeature.NaturalEarthFeature(
            category=&#39;cultural&#39;,  name=&#39;admin_1_states_provinces_lines&#39;,
            scale=&#39;50m&#39;, facecolor=&#39;none&#39;)
    ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;, zorder=10)
    
    #Add lat/lon gridlines every 20° to the map
    ax.gridlines(xlocs=np.arange(0,361,20), ylocs=np.arange(-80,90,20)) 
    
    return fig, ax
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We specify the interval for our height contours. We use numpy&amp;rsquo;s function arange to select a range of contours from 500 to 2000 m, every 60 m.&lt;/p&gt;

&lt;p&gt;A key thing to note is the transform argument at the end of the contour call. This is what tells matplotlib to transform our variable in lat/lon coordinates onto our map projection coordinates.&lt;/p&gt;

&lt;p&gt;We then plot temperature in filled contours. Matplotlib has many colormaps from which to choose. Here, we use cm.jet_r.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#Import scipy.ndimage to get the gaussian_filter function
import scipy.ndimage as ndimage
hght_levels = np.arange(500,2000,60) 
#Plot a new figure and map axes
fig, ax = plotMap()
## Choisissons une colormap
cmap0=plt.cm.jet_r
cmap0.set_under(&#39;w&#39;) ## on met en blanc les valeurs inferieures au min de clev
cmap0.set_over(&#39;darkblue&#39;)

#Smooth and re-plot the temperature field
tt_smooth = ndimage.gaussian_filter(tt850.values-273.15, sigma=1.5, order=0)
tt_contour = ax.contourf(tt850.lon.values, tt850.lat.values, tt_smooth, zorder=2,  
                           cmap=cmap0, transform = ccrs.PlateCarree())

#Smooth and re-plot the height field
hght_smooth = ndimage.gaussian_filter(hgt850, sigma=3, order=0)
hght_contour = ax.contour(hgt850.lon, hgt850.lat, hght_smooth, levels=hght_levels, linewidths=1, colors=&#39;k&#39;,transform = ccrs.PlateCarree())
#Plot contour labels for the heights, leaving a break in the contours for the text (inline=True)
plt.clabel(hght_contour,  hght_levels, inline=True, fmt=&#39;%1i&#39;, fontsize=12)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a list of 18 text.Text objects&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_13_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can improve our synoptic map with adding wind barbs in Knots and using our own colormap.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#Import scipy.ndimage to get the gaussian_filter function
import scipy.ndimage as ndimage
hght_levels = np.arange(500,2000,60) 
tt_levels = np.arange(-40,40,2) 
#Plot a new figure and map axes
fig, ax = plotMap()
## Choisissons une colormap
Y=np.array([[77,0,111],[115,14,181],[160,17,222],[195,14,240],\
               [0,0,93],[21,38,177],[33,95,227],[32,162,247],[59,224,248],[202,255,250],\
               [4,255,179],[37,181,139],[32,132,81],[72,162,60],[157,240,96],[213,255,166],\
               [241,247,132],[248,185,68],[255,124,4],[235,78,14],[215,32,24],[189,24,40],[162,16,56],[135,16,65],[107,15,73]])/255.

colbar=mpl.colors.ListedColormap(Y)

cmap0=plt.cm.jet_r
cmap0.set_under(&#39;w&#39;) ## on met en blanc les valeurs inferieures au min de clev
cmap0.set_over(&#39;darkblue&#39;)

#Smooth and re-plot the temperature field
tt_smooth = ndimage.gaussian_filter(tt850.values-273.15, sigma=1.5, order=0)
tt_contour = ax.contourf(tt850.lon.values, tt850.lat.values, tt_smooth,  levels=tt_levels, zorder=2,  
                           cmap=colbar, transform = ccrs.PlateCarree())

#Smooth and re-plot the height field
hght_smooth = ndimage.gaussian_filter(hgt850, sigma=3, order=0)
hght_contour = ax.contour(hgt850.lon, hgt850.lat, hght_smooth, levels=hght_levels, linewidths=1, colors=&#39;red&#39;,transform = ccrs.PlateCarree())
#Plot contour labels for the heights, leaving a break in the contours for the text (inline=True)
plt.clabel(hght_contour,  hght_levels, inline=True, fmt=&#39;%1i&#39;, fontsize=20)

#Plot the barbs
ax.barbs(urel250.lon.values, urel250.lat.values, urel250.values*1.944, vrel250.values*1.944, regrid_shape=12, zorder=20, transform=ccrs.PlateCarree())

#Create a colorbar and shrink it down a bit.
cb = plt.colorbar(tt_contour, shrink=0.5, ticks=np.arange(-40, 40.1, 4))

#Set the title
ax.set_title(&#39;850-hPa Heights, 850-hPa Temperature, Wind (kts) \n &#39;+str(date), fontsize=14)

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Text(0.5, 1.0, &#39;850-hPa Heights, 850-hPa Temperature, Wind (kts) \n 2018-01-13T12&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_15_1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Python connection to MSS Server</title>
      <link>/post/mss_server/</link>
      <pubDate>Fri, 07 Feb 2020 10:57:37 -0800</pubDate>
      <guid>/post/mss_server/</guid>
      <description>

&lt;h3 id=&#34;connexion-to-microsoft-sql-server-management-studio&#34;&gt;Connexion to Microsoft SQL Server Management Studio&lt;/h3&gt;

&lt;p&gt;This is a short tutorial to connect python to a Miscrosoft SQL Server.&lt;/p&gt;

&lt;h3 id=&#34;steps-to-connect-with-pyodbc-python-library&#34;&gt;Steps to connect with pyodbc python library&lt;/h3&gt;

&lt;p&gt;You need to know some informations on your local server, database and tables you want to connect:
In our case:
    - The Server Name is: DESKTOP-BE6M578
    - The Database Name is: BDSOPFEU
    - The Table Name is: dbo.Meteo_stations
    - The Table dbo.Meteo_stations containes stations information&lt;/p&gt;

&lt;h3 id=&#34;1-retrieve-your-server-name&#34;&gt;1 Retrieve your server name&lt;/h3&gt;

&lt;p&gt;You can get your server name by opening Microsoft SQL Server. You’ll then see the Connect to Server box, where the server name will be displayed.&lt;/p&gt;

&lt;p&gt;In my case, the server name is: DESKTOP-BE6M578&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-retrieve-your-database-name&#34;&gt;2 Retrieve your Database name&lt;/h3&gt;

&lt;p&gt;Next, you’ll need to obtain the database name in which your desired table is stored.&lt;/p&gt;

&lt;p&gt;You can find the database name under the Object Explorer menu (underneath the Databases section) which is located on the left-hand side of your SQL Server.&lt;/p&gt;

&lt;p&gt;In our example, the database name is: BDSOPFEU&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image2.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-get-the-table-name&#34;&gt;3 Get the table name&lt;/h3&gt;

&lt;p&gt;Now you’ll need to get the name of your desired table.&lt;/p&gt;

&lt;p&gt;The name of your table would also be located under the Object Explorer menu (underneath the Tables section).&lt;/p&gt;

&lt;p&gt;Here, the name of the table is: dbo.Meteo_stations&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;image3.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-connect-python-to-our-microsoft-sql-server&#34;&gt;4 Connect Python to our Microsoft SQL Server&lt;/h3&gt;

&lt;p&gt;Now we have all the informations about our server and database to connect Python .&lt;/p&gt;

&lt;p&gt;Here is the structure of the code that you may use in Python:&lt;/p&gt;

&lt;p&gt;import pyodbc
conn = pyodbc.connect(&amp;lsquo;Driver={SQL Server};&amp;rsquo;
                      &amp;lsquo;Server=server_name;&amp;rsquo;
                      &amp;lsquo;Database=db_name;&amp;rsquo;
                      &amp;lsquo;Trusted_Connection=yes;&amp;lsquo;)&lt;/p&gt;

&lt;p&gt;cursor = conn.cursor()
cursor.execute(&amp;lsquo;SELECT * FROM db_name.Table&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;for row in cursor:
    print(row)
And this is how the code would look like in Python using our example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pyodbc 
connexion = pyodbc.connect(&#39;Driver={SQL Server};&#39;
                      &#39;Server=DESKTOP-BE6M578;&#39;
                      &#39;Database=BDSOPFEU;&#39;
                      &#39;Trusted_Connection=yes;&#39;)

cursor = connexion.cursor()
cursor.execute(&#39;SELECT * FROM BDSOPFEU.dbo.Meteo_stations&#39;)

# to loop over each row
#for row in cursor:
#    print(row)
row = cursor.fetchone()
print(row)
connexion.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(111, datetime.datetime(1978, 4, 1, 0, 0), 1, &#39;STE-PERPETUE&#39;, &#39;4113-1-5355&#39;, 111, datetime.datetime(1989, 10, 31, 0, 0), 400, &#39;M&#39;, &#39;N&#39;, 1, 1, &#39;MFFP_CEL&#39;, None, 13, &#39; &#39;, None, False, None, None, None)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;For having basic informations about our table:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;columns = [column[0] for column in cursor.description]
columns
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[&amp;lsquo;No_station&amp;rsquo;,
 &amp;lsquo;Ouverture&amp;rsquo;,
 &amp;lsquo;Base&amp;rsquo;,
 &amp;lsquo;Nom&amp;rsquo;,
 &amp;lsquo;Quadr&amp;rsquo;,
 &amp;lsquo;Secteur&amp;rsquo;,
 &amp;lsquo;Fermeture&amp;rsquo;,
 &amp;lsquo;Elevation&amp;rsquo;,
 &amp;rsquo;T_hr&amp;rsquo;,
 &amp;lsquo;Vent&amp;rsquo;,
 &amp;rsquo;T_donnees&amp;rsquo;,
 &amp;rsquo;T_station&amp;rsquo;,
 &amp;lsquo;Provenance&amp;rsquo;,
 &amp;lsquo;Stn_mere&amp;rsquo;,
 &amp;lsquo;Hre_levee&amp;rsquo;,
 &amp;lsquo;Memo&amp;rsquo;,
 &amp;lsquo;Contour&amp;rsquo;,
 &amp;lsquo;Active&amp;rsquo;,
 &amp;lsquo;Cladonie&amp;rsquo;,
 &amp;lsquo;Latitude&amp;rsquo;,
 &amp;lsquo;Longitude&amp;rsquo;]&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now, I’ll show you how to get data from SQL to pandas DataFrame.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pyodbc
import pandas as pd

connexion = pyodbc.connect(&#39;Driver={SQL Server};&#39;
                      &#39;Server=DESKTOP-BE6M578;&#39;
                      &#39;Database=BDSOPFEU;&#39;
                      &#39;Trusted_Connection=yes;&#39;)

SQL_Query = pd.read_sql_query(
&#39;&#39;&#39;SELECT
 Nom, No_station, Latitude, Longitude  
FROM dbo.Meteo_stations 
WHERE Active = &#39;True&#39; &#39;&#39;&#39;, connexion)

df = pd.DataFrame(SQL_Query)
df.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;Nom&lt;/th&gt;
      &lt;th&gt;No_station&lt;/th&gt;
      &lt;th&gt;Latitude&lt;/th&gt;
      &lt;th&gt;Longitude&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;LA PÈCHE&lt;/td&gt;
      &lt;td&gt;111&lt;/td&gt;
      &lt;td&gt;45:37:20&lt;/td&gt;
      &lt;td&gt;76:01:09&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;L&#39;ACADIE&lt;/td&gt;
      &lt;td&gt;129&lt;/td&gt;
      &lt;td&gt;45:17:39&lt;/td&gt;
      &lt;td&gt;73:20:56&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;KIPAWA&lt;/td&gt;
      &lt;td&gt;132&lt;/td&gt;
      &lt;td&gt;47:09:23&lt;/td&gt;
      &lt;td&gt;78:56:02&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;BAR.TEMISCAMINGUE&lt;/td&gt;
      &lt;td&gt;139&lt;/td&gt;
      &lt;td&gt;46:42:36&lt;/td&gt;
      &lt;td&gt;79:06:04&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;COULONGE&lt;/td&gt;
      &lt;td&gt;142&lt;/td&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;None&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pyodbc
import pandas as pd

connexion = pyodbc.connect(&#39;Driver={SQL Server};&#39;
                      &#39;Server=DESKTOP-BE6M578;&#39;
                      &#39;Database=BDSOPFEU;&#39;
                      &#39;Trusted_Connection=yes;&#39;)

SQL_Query = pd.read_sql_query(
&#39;&#39;&#39;SELECT
 Date,
 Heure,
 Pluie,
 Hr,
 Tsec,
 Thum,
 Vv,
 Vvr
FROM dbo.Meteo_obs 
 WHERE No_station = 111&#39;&#39;&#39;, connexion)

df = pd.DataFrame(SQL_Query)
df.tail()
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;Date&lt;/th&gt;
      &lt;th&gt;Heure&lt;/th&gt;
      &lt;th&gt;Pluie&lt;/th&gt;
      &lt;th&gt;Hr&lt;/th&gt;
      &lt;th&gt;Tsec&lt;/th&gt;
      &lt;th&gt;Thum&lt;/th&gt;
      &lt;th&gt;Vv&lt;/th&gt;
      &lt;th&gt;Vvr&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;154619&lt;/th&gt;
      &lt;td&gt;2019-06-25&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;0.0&lt;/td&gt;
      &lt;td&gt;47.0&lt;/td&gt;
      &lt;td&gt;18.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;5.0&lt;/td&gt;
      &lt;td&gt;16.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;154620&lt;/th&gt;
      &lt;td&gt;2019-06-25&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;4.2&lt;/td&gt;
      &lt;td&gt;92.0&lt;/td&gt;
      &lt;td&gt;13.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;2.0&lt;/td&gt;
      &lt;td&gt;16.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;154621&lt;/th&gt;
      &lt;td&gt;2019-06-25&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;13.0&lt;/td&gt;
      &lt;td&gt;95.0&lt;/td&gt;
      &lt;td&gt;13.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;4.0&lt;/td&gt;
      &lt;td&gt;16.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;154622&lt;/th&gt;
      &lt;td&gt;2019-06-25&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;13.8&lt;/td&gt;
      &lt;td&gt;96.0&lt;/td&gt;
      &lt;td&gt;13.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;6.0&lt;/td&gt;
      &lt;td&gt;17.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;154623&lt;/th&gt;
      &lt;td&gt;2019-06-25&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;13.8&lt;/td&gt;
      &lt;td&gt;96.0&lt;/td&gt;
      &lt;td&gt;14.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;6.0&lt;/td&gt;
      &lt;td&gt;20.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Mask countries using shapefile</title>
      <link>/post/shapefiles_country/</link>
      <pubDate>Tue, 04 Feb 2020 10:39:49 -0800</pubDate>
      <guid>/post/shapefiles_country/</guid>
      <description>

&lt;h3 id=&#34;using-country-shapefiles-to-create-netcdf-mask&#34;&gt;Using country shapefiles to create Netcdf mask&lt;/h3&gt;

&lt;p&gt;In this tutorial, we will use shapefiles to create mask over specific countries.&lt;/p&gt;

&lt;p&gt;In order to work with the whole globe, we will use gridded dataset ERA5 meteorological data.&lt;/p&gt;

&lt;p&gt;I will present a simple solution based on open-source Python modules:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    - xarray: for manipulating &amp;amp; reading gridded data, and – very important – operate out-of-memory thanks to its dask capabilities
    - regionmask: to mask a gridded file according to a shapefile
    - numpy: for simple array manipulations
    - geopandas: to open shapefiles
    - matplotlib: for plotting
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-import-librairies-and-create-aliases&#34;&gt;1-  Import librairies and create aliases.&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import xarray as xr 
import numpy as np
import regionmask
import geopandas as gpd
import pandas as pd
import matplotlib.pyplot as plt
import warnings; warnings.filterwarnings(action=&#39;ignore&#39;)
%matplotlib inline
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;working-over-countries&#34;&gt;Working over countries&lt;/h3&gt;

&lt;p&gt;In this example we will focus on countries in Africa. We will use &lt;a href=&#34;https://community.esri.com/external-link.jspa?url=http%3A%2F%2Fwww.maplibrary.org%2Flibrary%2Fstacks%2FAfrica%2Findex.htm&#34; target=&#34;_blank&#34;&gt;shapefiles developped in ESRI format&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After downloaded the shapefile, we must load it using geopandas library:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;PATH_TO_SHAPEFILE = &#39;./Countries/Africa_Countries.shp&#39;
countries = gpd.read_file(PATH_TO_SHAPEFILE)
countries.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;ID&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;CODE&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;COUNTRY&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;geometry&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;ALG&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;Algeria&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;POLYGON ((-5.7636199999979 25.58624999999302, &amp;hellip;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;ANG&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;Angola&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;POLYGON ((13.36632442474365 -8.32172966003418,&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;countries.shape[0]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;762
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;my_list = list(countries[&#39;CODE&#39;])
my_list_unique = set(list(countries[&#39;CODE&#39;]))
indexes = [my_list.index(x) for x in my_list_unique]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Shapes are here a GeoDataFrame containing all polygons illustrating the countries boundaries.&lt;/p&gt;

&lt;p&gt;Now we can load the ERA5 gridded data. The parameter chunks is very important, it defines how big are the “pieces” of data moved from the disk to the memory. With this value the entire computation on a workstation with 32 GB takes a couple of minutes.&lt;/p&gt;

&lt;p&gt;We will load all the temperature files for the year 2018 using Xarray library.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;model=&#39;ERA5_T2m_1h&#39;
t_in = &#39;J:/REANALYSES/ERA5/T2m_1h/&#39;        
data = t_in + model + &#39;_2018*_sfc.nc&#39;
ds = xr.open_mfdataset(data, chunks = {&#39;time&#39;: 10})
ds
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 721, longitude: 1440, time: 8760)
Coordinates:
  * longitude  (longitude) float32 0.0 0.25 0.5 0.75 ... 359.25 359.5 359.75
  * latitude   (latitude) float32 90.0 89.75 89.5 89.25 ... -89.5 -89.75 -90.0
  * time       (time) datetime64[ns] 2018-01-01 ... 2018-12-31T23:00:00
Data variables:
    t2m        (time, latitude, longitude) float32 dask.array&amp;lt;shape=(8760, 721, 1440), chunksize=(10, 721, 1440)&amp;gt;
Attributes:
    Conventions:  CF-1.6
    history:      2019-11-11 13:33:07 GMT by grib_to_netcdf-2.14.0: /opt/ecmw...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next function &lt;b&gt;assign_coords&lt;/b&gt; will convert the longitude from the 0-360 range to -180,180&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ds = ds.assign_coords(longitude=(((ds.longitude + 180) % 360) - 180)).sortby(&#39;longitude&#39;)
ds
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 721, longitude: 1440, time: 8760)
Coordinates:
  * longitude  (longitude) float32 -180.0 -179.75 -179.5 ... 179.25 179.5 179.75
  * latitude   (latitude) float32 90.0 89.75 89.5 89.25 ... -89.5 -89.75 -90.0
  * time       (time) datetime64[ns] 2018-01-01 ... 2018-12-31T23:00:00
Data variables:
    t2m        (time, latitude, longitude) float32 dask.array&amp;lt;shape=(8760, 721, 1440), chunksize=(10, 721, 1440)&amp;gt;
Attributes:
    Conventions:  CF-1.6
    history:      2019-11-11 13:33:07 GMT by grib_to_netcdf-2.14.0: /opt/ecmw...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;len(list(countries.geometry.values[i] for i in indexes))
len(list(countries.COUNTRY[indexes]))
len(indexes)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;52
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = range(0,countries.shape[0])
np.shape(a)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(762,)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our xarray Dataset contains a single variable (t2m) which is stored as a dask.array. This is the result of loading files with open_mfdataset.&lt;/p&gt;

&lt;p&gt;Now we will use regionmask module to create a gridded mask with the
&lt;a href=&#34;https://regionmask.readthedocs.io/en/stable/generated/regionmask.Regions_cls.html#regionmask.Regions_cls&#34; target=&#34;_blank&#34;&gt;function regions_cls&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With this function we will create an object able to mask ERA5 gridded data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;countries_mask_poly = regionmask.Regions_cls(name = &#39;COUNTRY&#39;, numbers = indexes, names = countries.COUNTRY[indexes], abbrevs = countries.COUNTRY[indexes], outlines = list(countries.geometry.values[i] for i in range(0,countries.shape[0])))
countries_mask_poly
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;52 &#39;COUNTRY&#39; Regions ()
Burkina Faso Senegal Botswana Liberia Chad Equatorial Guinea Djibouti Ghana Nigeria Sao Tome and Principe Swaziland Uganda Tanzania Comoros Guinea Algeria Niger Madagascar Burundi Cameroon Mali Zimbabwe Cote d`Ivoire Tunisia Sierra Leone Libya Rwanda Benin Malawi Gabon South Africa Western Sahara Zambia Central African Republic Togo Namibia Gambia Congo-Brazzaville Democratic Republic of Congo Morocco Eritrea Cape Verde Angola Ethiopia Lesotho Egypt Guinea-Bissau Kenya Mozambique Sudan Mauritania Somalia
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are ready to apply the mask on the gridded dataset xarray ERA5.&lt;/p&gt;

&lt;p&gt;We select only the first timestep to speed up the process.&lt;/p&gt;

&lt;p&gt;This step could take few minutes because of ERA5 resolution and grid : Dimensions:    (latitude: 721, longitude: 1440)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mask = countries_mask_poly.mask(ds.isel(time = 0), lat_name=&#39;latitude&#39;, lon_name=&#39;longitude&#39;)
mask
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray &#39;region&#39; (latitude: 721, longitude: 1440)&amp;gt;
array([[nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       ...,
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan]])
Coordinates:
  * latitude   (latitude) float32 90.0 89.75 89.5 89.25 ... -89.5 -89.75 -90.0
  * longitude  (longitude) float32 -180.0 -179.75 -179.5 ... 179.25 179.5 179.75
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mask can be saved (for example as a NetCDF) for a later use.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mask.to_netcdf(&#39;./mask_Africa_by_countries.nc&#39;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use  &lt;a href=&#34;https://www.giss.nasa.gov/tools/panoply/&#34; target=&#34;_blank&#34;&gt;Panoply&lt;/a&gt; free software to plot our netcdf file.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a quick visualisation using Matplotlib:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.figure(figsize=(16,8))
ax = plt.axes()
mask.plot(ax = ax)
countries.plot(ax = ax, alpha = 0.8, facecolor = &#39;none&#39;, lw = 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0xbdf0d68&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./output1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s now extract one specific country from our mask. We will for example extract informations only over Algeria.
Remember, index for Algeria is: 0  .&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mask_algeria = mask.where(mask == 0 )
mask_algeria.to_netcdf(&#39;./mask_Algeria.nc&#39;) 

plt.figure(figsize=(16,8))
ax = plt.axes()
mask_algeria.plot(ax = ax)
countries.plot(ax = ax, alpha = 0.8, facecolor = &#39;none&#39;, lw = 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0x7528278&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./output2.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-extract-time-series&#34;&gt;2- Extract time-series&lt;/h3&gt;

&lt;p&gt;We can now for each country aggregate the grid cells in the national borders.
We will first develop two methods to mask our area. Then, we will extract the time series.&lt;/p&gt;

&lt;h3 id=&#34;method-1&#34;&gt;- Method 1:&lt;/h3&gt;

&lt;p&gt;I will focus on Algeria.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ID_COUNTRY = 0
print(countries.COUNTRY[ID_COUNTRY])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Algeria
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As first step, I will save the latitude and longitude vectors because I will use it later. Then, I select the mask points where the value is equal to target value (the ID_COUNTRY code). In the numpy array sel_mask all the values are nan except for the selected ones.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lat = mask.latitude.values
lon = mask.longitude.values

sel_mask = mask.where(mask == ID_COUNTRY).values
sel_mask
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;array([[nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       ...,
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To speed-up the process I want to crop the xarray Dataset selecting the smallest box containing the entire mask. To do this I store in id_lon and id_lat the coordinate points where the mask has at least a non-nan value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;id_lon = lon[np.where(~np.all(np.isnan(sel_mask), axis=0))]
id_lat = lat[np.where(~np.all(np.isnan(sel_mask), axis=1))]
id_lat
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;array([37.  , 36.75, 36.5 , 36.25, 36.  , 35.75, 35.5 , 35.25, 35.  ,
       34.75, 34.5 , 34.25, 34.  , 33.75, 33.5 , 33.25, 33.  , 32.75,
       32.5 , 32.25, 32.  , 31.75, 31.5 , 31.25, 31.  , 30.75, 30.5 ,
       30.25, 30.  , 29.75, 29.5 , 29.25, 29.  , 28.75, 28.5 , 28.25,
       28.  , 27.75, 27.5 , 27.25, 27.  , 26.75, 26.5 , 26.25, 26.  ,
       25.75, 25.5 , 25.25, 25.  , 24.75, 24.5 , 24.25, 24.  , 23.75,
       23.5 , 23.25, 23.  , 22.75, 22.5 , 22.25, 22.  , 21.75, 21.5 ,
       21.25, 21.  , 20.75, 20.5 , 20.25, 20.  , 19.75, 19.5 , 19.25,
       19.  ], dtype=float32)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Xarray dataset is reduced selecting only the target year and the coordinates containing the target region. Then the dataset is load from the dask array using compute and then filtered using the mask.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;out_sel1 = ds.sel(latitude = slice(id_lat[0], id_lat[-1]), longitude = slice(id_lon[0], id_lon[-1])).compute().where(mask == ID_COUNTRY)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;out_sel1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 73, longitude: 82, time: 8760)
Coordinates:
  * latitude   (latitude) float64 37.0 36.75 36.5 36.25 ... 19.5 19.25 19.0
  * longitude  (longitude) float64 -8.5 -8.25 -8.0 -7.75 ... 11.25 11.5 11.75
  * time       (time) datetime64[ns] 2018-01-01 ... 2018-12-31T23:00:00
Data variables:
    t2m        (time, latitude, longitude) float32 nan nan nan ... nan nan nan
Attributes:
    Conventions:  CF-1.6
    history:      2019-11-11 13:33:07 GMT by grib_to_netcdf-2.14.0: /opt/ecmw...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;method-2&#34;&gt;- Method 2:&lt;/h3&gt;

&lt;p&gt;We can directly use xarray library to apply netcdf mask with using .where() method and DataArray mask:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;out_sel2 = ds.where(mask == 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;out_sel2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 721, longitude: 1440, time: 8760)
Coordinates:
  * longitude  (longitude) float32 -180.0 -179.75 -179.5 ... 179.25 179.5 179.75
  * latitude   (latitude) float32 90.0 89.75 89.5 89.25 ... -89.5 -89.75 -90.0
  * time       (time) datetime64[ns] 2018-01-01 ... 2018-12-31T23:00:00
Data variables:
    t2m        (time, latitude, longitude) float32 dask.array&amp;lt;shape=(8760, 721, 1440), chunksize=(10, 721, 1440)&amp;gt;
Attributes:
    Conventions:  CF-1.6
    history:      2019-11-11 13:33:07 GMT by grib_to_netcdf-2.14.0: /opt/ecmw...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quick visualisation, we will display the first step of our DataArray masked.&lt;/p&gt;

&lt;p&gt;For out_sel2 array :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.figure(figsize=(12,8))
ax = plt.axes()
out_sel2.t2m.isel(time = 0).plot(ax = ax)
countries.plot(ax = ax, alpha = 0.8, facecolor = &#39;none&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0xe73e550&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./output3.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;For out_sel1 array :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.figure(figsize=(12,8))
ax = plt.axes()
out_sel1.t2m.isel(time = 0).plot(ax = ax)
countries.plot(ax = ax, alpha = 0.8, facecolor = &#39;none&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0xe8024a8&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./output4.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Finally we can aggregate by the arithmetic mean using the groupby function to obtain a time-series of national average temperatures.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = out_sel1.groupby(&#39;time&#39;).mean()
x
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:  (time: 8760)
Coordinates:
  * time     (time) datetime64[ns] 2018-01-01 ... 2018-12-31T23:00:00
Data variables:
    t2m      (time) float32 285.01346 284.65833 283.95526 ... 282.03668 281.461
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we plot the time-series…&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x.t2m.plot()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&amp;lt;matplotlib.lines.Line2D at 0xe9dc518&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./output5.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Let&amp;rsquo;s resample our dataset by day and then compute a daily mean.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = out_sel1.resample(time = &#39;1D&#39;).mean()-273.15
x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;xarray.Dataset&gt;
Dimensions:    (latitude: 73, longitude: 82, time: 365)
Coordinates:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;longitude  (longitude) float64 -8.5 -8.25 -8.0 -7.75 &amp;hellip; 11.25 11.5 11.75&lt;/li&gt;
&lt;li&gt;latitude   (latitude) float64 37.0 36.75 36.5 36.25 &amp;hellip; 19.5 19.25 19.0&lt;/li&gt;

&lt;li&gt;&lt;p&gt;time       (time) datetime64[ns] 2018-01-01 2018-01-02 &amp;hellip; 2018-12-31
Data variables:
t2m        (time, latitude, longitude) float32 nan nan nan &amp;hellip; nan nan nan&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;daily_mean = x.t2m.mean(dim=(&#39;longitude&#39;,&#39;latitude&#39;))
daily_mean
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;xarray.DataArray &#39;t2m&#39; (time: 365)&gt;
array([14.550091, 13.812102, 13.700798, &amp;hellip;, 10.975014, 11.182918, 10.956429],
      dtype=float32)
Coordinates:
  * time     (time) datetime64[ns] 2018-01-01 2018-01-02 &amp;hellip; 2018-12-31&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;daily_mean.plot()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[&lt;matplotlib.lines.Line2D at 0xe243f98&gt;]&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;./output6.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And we save it as a csv&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;daily_mean.to_pandas().to_csv(&#39;average-temperature-algeria.csv&#39;, header = [&#39;t2m&#39;])
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-extract-time-series-for-one-specific-localisation&#34;&gt;2- Extract time-series for one specific localisation&lt;/h3&gt;

&lt;p&gt;In this example, we eant to extract time-series for Alger:&lt;/p&gt;

&lt;p&gt;With:
      - longitude = 3.04
      - latitude = 36.75&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lati = 36.75
loni = 3.04
data  = out_sel1.sel(longitude=loni  , latitude=lati  , method=&#39;nearest&#39;) 
data.t2m
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray &#39;t2m&#39; (time: 8760)&amp;gt;
array([289.91342, 289.63348, 289.2745 , ..., 285.62613, 284.9182 , 284.80624],
      dtype=float32)
Coordinates:
    latitude   float64 36.75
    longitude  float64 3.0
  * time       (time) datetime64[ns] 2018-01-01 ... 2018-12-31T23:00:00
Attributes:
    units:      K
    long_name:  2 metre temperature
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data[&#39;t2m&#39;] = data[&#39;t2m&#39;] - 273.15
df = data.t2m.to_dataframe()
fig = plt.figure(figsize=(16,8))
df[&#39;t2m&#39;].plot()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0x20773fd0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./output7.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s plot montlhy temperature distribution for Alger:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df[&#39;month&#39;] = df.index.strftime(&amp;quot;%b&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;time&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;latitude&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;longitude&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;t2m&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;month&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2018-01-01 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;36.75&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;16.7634&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Jan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2018-01-01 01:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;36.75&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;16.4835&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Jan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2018-01-01 02:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;36.75&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;16.1245&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Jan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2018-01-01 03:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;36.75&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;16.197&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Jan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2018-01-01 04:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;36.75&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;16.0389&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Jan&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ax = plt.axes()
sns.boxplot(x=&amp;quot;month&amp;quot;, y=&amp;quot;t2m&amp;quot;, data=df, palette=&amp;quot;Set1&amp;quot;)  
figure = ax.get_figure()    
figure.set_size_inches(12, 8) 
plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./output8.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Convert shapefile to netcdf</title>
      <link>/post/shapefile_netcdf/</link>
      <pubDate>Fri, 31 Jan 2020 07:20:28 -0800</pubDate>
      <guid>/post/shapefile_netcdf/</guid>
      <description>

&lt;p&gt;﻿&lt;/p&gt;

&lt;h2 id=&#34;from-shapefiles-to-netcdf-mask&#34;&gt;From shapefiles to Netcdf Mask&lt;/h2&gt;

&lt;p&gt;Many times we need to create Netcdf mask files over continents or maybe countries. In this tutorial, we will use shapefiles to create those masks.&lt;/p&gt;

&lt;p&gt;In order to work with the whole globe, we will use gridded dataset ERA5 meteorological data.&lt;/p&gt;

&lt;p&gt;I will present a simple solution based on open-source Python modules:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    - xarray: for manipulating &amp;amp; reading gridded data, and – very important – operate out-of-memory thanks to its dask capabilities
    - regionmask: to mask a gridded file according to a shapefile
    - numpy: for simple array manipulations
    - geopandas: to open shapefiles
    - matplotlib: for plotting
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-first-we-need-to-import-librairies-and-create-aliases&#34;&gt;1- First we need to import librairies and create aliases.&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import xarray as xr 
import numpy as np
import regionmask
import geopandas as gpd
import pandas as pd
import matplotlib.pyplot as plt
import warnings; warnings.filterwarnings(action=&#39;ignore&#39;)
%matplotlib inline
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;working-over-continents&#34;&gt;Working over continents&lt;/h2&gt;

&lt;p&gt;In this example we will use the  classification developed by ARCGIS.&lt;/p&gt;

&lt;p&gt;Shapefiles are available on this &lt;a href=&#34;https://www.arcgis.com/home/item.html?id=5cf4f223c4a642eb9aa7ae1216a04372&#34; target=&#34;_blank&#34;&gt;website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After downloaded the shapefile, we must load it using geopandas library:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;PATH_TO_SHAPEFILE = &#39;./continent_shapefile/continent.shp&#39;
continents = gpd.read_file(PATH_TO_SHAPEFILE)
continents
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;0             Asia
1    North America
2           Europe
3           Africa
4    South America
5          Oceania
6        Australia
7       Antarctica
Name: CONTINENT, dtype: GeoDataFrame&lt;/p&gt;

&lt;p&gt;Shapes are here a GeoDataFrame containing all polygons illustrating the continent boundaries.&lt;/p&gt;

&lt;p&gt;Now we can load the ERA5 gridded data. The parameter chunks is very important, it defines how big are the “pieces” of data moved from the disk to the memory. With this value the entire computation on a workstation with 32 GB takes a couple of minutes.&lt;/p&gt;

&lt;p&gt;We will load all the temperature files for the year 2018 using Xarray library.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;model=&#39;ERA5_T2m_1h&#39;
t_in = &#39;J:/REANALYSES/ERA5/T2m_1h/&#39;        
data = t_in + model + &#39;_2018*_sfc.nc&#39;
ds = xr.open_mfdataset(data, chunks = {&#39;time&#39;: 10})
ds
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 721, longitude: 1440, time: 8760)
Coordinates:
  * longitude  (longitude) float32 0.0 0.25 0.5 0.75 ... 359.25 359.5 359.75
  * latitude   (latitude) float32 90.0 89.75 89.5 89.25 ... -89.5 -89.75 -90.0
  * time       (time) datetime64[ns] 2018-01-01 ... 2018-12-31T23:00:00
Data variables:
    t2m        (time, latitude, longitude) float32 dask.array&amp;lt;shape=(8760, 721, 1440), chunksize=(10, 721, 1440)&amp;gt;
Attributes:
    Conventions:  CF-1.6
    history:      2019-11-11 13:33:07 GMT by grib_to_netcdf-2.14.0: /opt/ecmw...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next function &lt;b&gt;assign_coords&lt;/b&gt; will convert the longitude from the 0-360 range to -180,180&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ds = ds.assign_coords(longitude=(((ds.longitude + 180) % 360) - 180)).sortby(&#39;longitude&#39;)
ds
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 721, longitude: 1440, time: 8760)
Coordinates:
  * longitude  (longitude) float32 -180.0 -179.75 -179.5 ... 179.25 179.5 179.75
  * latitude   (latitude) float32 90.0 89.75 89.5 89.25 ... -89.5 -89.75 -90.0
  * time       (time) datetime64[ns] 2018-01-01 ... 2018-12-31T23:00:00
Data variables:
    t2m        (time, latitude, longitude) float32 dask.array&amp;lt;shape=(8760, 721, 1440), chunksize=(10, 721, 1440)&amp;gt;
Attributes:
    Conventions:  CF-1.6
    history:      2019-11-11 13:33:07 GMT by grib_to_netcdf-2.14.0: /opt/ecmw...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our xarray Dataset contains a single variable (t2m) which is stored as a dask.array. This is the result of loading files with open_mfdataset.&lt;/p&gt;

&lt;p&gt;Now we will use regionmask module to create a gridded mask with the
&lt;a href=&#34;https://regionmask.readthedocs.io/en/stable/generated/regionmask.Regions_cls.html#regionmask.Regions_cls&#34; target=&#34;_blank&#34;&gt;function regions_cls&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With this function we will create an object able to mask ERA5 gridded data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;continents_mask_poly = regionmask.Regions_cls(name = &#39;CONTINENT&#39;, numbers = list(range(0,8)), names = list(continents.CONTINENT), abbrevs = list(continents.CONTINENT), outlines = list(continents.geometry.values[i] for i in range(0,8)))
continents_mask_poly
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;8 &#39;CONTINENT&#39; Regions ()
Asia North America Europe Africa South America Oceania Australia Antarctica
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are ready to apply the mask on the gridded dataset xarray ERA5.&lt;/p&gt;

&lt;p&gt;We select only the first timestep to speed up the process.&lt;/p&gt;

&lt;p&gt;This step could take few minutes because of ERA5 resolution and grid : Dimensions:    (latitude: 721, longitude: 1440)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mask = continents_mask_poly.mask(ds.isel(time = 0), lat_name=&#39;latitude&#39;, lon_name=&#39;longitude&#39;)
mask
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray &#39;region&#39; (latitude: 721, longitude: 1440)&amp;gt;
array([[nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       ...,
       [nan,  7.,  7., ...,  7.,  7.,  7.],
       [nan,  7.,  7., ...,  7.,  7.,  7.],
       [nan, nan, nan, ..., nan, nan, nan]])
Coordinates:
  * latitude   (latitude) float32 90.0 89.75 89.5 89.25 ... -89.5 -89.75 -90.0
  * longitude  (longitude) float32 -180.0 -179.75 -179.5 ... 179.25 179.5 179.75
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mask can be saved (for example as a NetCDF) for a later use.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mask.to_netcdf(&#39;./mask_all_continents.nc&#39;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A quick visualisation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.figure(figsize=(15,8))
ax = plt.axes()
mask.plot(ax = ax)
continents.plot(ax = ax, alpha = 0.8, facecolor = &#39;none&#39;, lw = 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0x787df98&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./continent1.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-extract-time-series&#34;&gt;2- Extract time-series&lt;/h2&gt;

&lt;p&gt;We can now for each contient aggregate the grid cells.&lt;/p&gt;

&lt;p&gt;We will first develop two methods to mask our area. Then, we will extract the time series.&lt;/p&gt;

&lt;h3 id=&#34;method-1&#34;&gt;- Method 1:&lt;/h3&gt;

&lt;p&gt;We will do this work over Africa.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ID_CONTINENT = 3
print(continents.CONTINENT[ID_CONTINENT])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Africa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As first step, I will save the latitude and longitude vectors because I will use it later. Then, I select the mask points where the value is equal to target value (the ID_CONTINENT code define before).&lt;/p&gt;

&lt;p&gt;In the numpy array sel_mask all the values are nan except for the selected ones.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lat = mask.latitude.values
lon = mask.longitude.values

sel_mask = mask.where(mask == ID_CONTINENT).values
sel_mask
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;array([[nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       ...,
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan]])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To speed-up the process I want to crop the xarray Dataset selecting the smallest box containing the entire mask. To do this I store in id_lon and id_lat the coordinate points where the mask has at least a non-nan value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;id_lon = lon[np.where(~np.all(np.isnan(sel_mask), axis=0))]
id_lat = lat[np.where(~np.all(np.isnan(sel_mask), axis=1))]
id_lat
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;array([ 37.25,  37.  ,  36.75,  36.5 ,  36.25,  36.  ,  35.75,  35.5 ,
        35.25,  35.  ,  34.75,  34.5 ,  34.25,  34.  ,  33.75,  33.5 ,
        33.25,  33.  ,  32.75,  32.5 ,  32.25,  32.  ,  31.75,  31.5 ,
        31.25,  31.  ,  30.75,  30.5 ,  30.25,  30.  ,  29.75,  29.5 ,
        29.25,  29.  ,  28.75,  28.5 ,  28.25,  28.  ,  27.75,  27.5 ,
        27.25,  27.  ,  26.75,  26.5 ,  26.25,  26.  ,  25.75,  25.5 ,
        25.25,  25.  ,  24.75,  24.5 ,  24.25,  24.  ,  23.75,  23.5 ,
        23.25,  23.  ,  22.75,  22.5 ,  22.25,  22.  ,  21.75,  21.5 ,
        21.25,  21.  ,  20.75,  20.5 ,  20.25,  20.  ,  19.75,  19.5 ,
        19.25,  19.  ,  18.75,  18.5 ,  18.25,  18.  ,  17.75,  17.5 ,
        17.25,  17.  ,  16.75,  16.5 ,  16.25,  16.  ,  15.75,  15.5 ,
        15.25,  15.  ,  14.75,  14.5 ,  14.25,  14.  ,  13.75,  13.5 ,
        13.25,  13.  ,  12.75,  12.5 ,  12.25,  12.  ,  11.75,  11.5 ,
        11.25,  11.  ,  10.75,  10.5 ,  10.25,  10.  ,   9.75,   9.5 ,
         9.25,   9.  ,   8.75,   8.5 ,   8.25,   8.  ,   7.75,   7.5 ,
         7.25,   7.  ,   6.75,   6.5 ,   6.25,   6.  ,   5.75,   5.5 ,
         5.25,   5.  ,   4.75,   4.5 ,   4.25,   4.  ,   3.75,   3.5 ,
         3.25,   3.  ,   2.75,   2.5 ,   2.25,   2.  ,   1.75,   1.5 ,
         1.25,   1.  ,   0.75,   0.5 ,   0.25,   0.  ,  -0.25,  -0.5 ,
        -0.75,  -1.  ,  -1.25,  -1.5 ,  -1.75,  -2.  ,  -2.25,  -2.5 ,
        -2.75,  -3.  ,  -3.25,  -3.5 ,  -3.75,  -4.  ,  -4.25,  -4.5 ,
        -4.75,  -5.  ,  -5.25,  -5.5 ,  -5.75,  -6.  ,  -6.25,  -6.5 ,
        -6.75,  -7.  ,  -7.25,  -7.5 ,  -7.75,  -8.  ,  -8.25,  -8.5 ,
        -8.75,  -9.  ,  -9.25,  -9.5 ,  -9.75, -10.  , -10.25, -10.5 ,
       -10.75, -11.  , -11.25, -11.5 , -11.75, -12.  , -12.25, -12.5 ,
       -12.75, -13.  , -13.25, -13.5 , -13.75, -14.  , -14.25, -14.5 ,
       -14.75, -15.  , -15.25, -15.5 , -15.75, -16.  , -16.25, -16.5 ,
       -16.75, -17.  , -17.25, -17.5 , -17.75, -18.  , -18.25, -18.5 ,
       -18.75, -19.  , -19.25, -19.5 , -19.75, -20.  , -20.25, -20.5 ,
       -20.75, -21.  , -21.25, -21.5 , -21.75, -22.  , -22.25, -22.5 ,
       -22.75, -23.  , -23.25, -23.5 , -23.75, -24.  , -24.25, -24.5 ,
       -24.75, -25.  , -25.25, -25.5 , -25.75, -26.  , -26.25, -26.5 ,
       -26.75, -27.  , -27.25, -27.5 , -27.75, -28.  , -28.25, -28.5 ,
       -28.75, -29.  , -29.25, -29.5 , -29.75, -30.  , -30.25, -30.5 ,
       -30.75, -31.  , -31.25, -31.5 , -31.75, -32.  , -32.25, -32.5 ,
       -32.75, -33.  , -33.25, -33.5 , -33.75, -34.  , -34.25, -34.5 ,
       -34.75], dtype=float32)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Xarray dataset is reduced selecting only the target year and the coordinates containing the target region. Then the dataset is load from the dask array using compute and then filtered using the mask.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;out_sel1 = ds.sel(latitude = slice(id_lat[0], id_lat[-1]), longitude = slice(id_lon[0], id_lon[-1])).compute().where(mask == ID_CONTINENT)
out_sel1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 289, longitude: 333, time: 8760)
Coordinates:
  * latitude   (latitude) float64 37.25 37.0 36.75 36.5 ... -34.25 -34.5 -34.75
  * longitude  (longitude) float64 -25.25 -25.0 -24.75 ... 57.25 57.5 57.75
  * time       (time) datetime64[ns] 2018-01-01 ... 2018-12-31T23:00:00
Data variables:
    t2m        (time, latitude, longitude) float32 nan nan nan ... nan nan nan
Attributes:
    Conventions:  CF-1.6
    history:      2019-11-11 13:33:07 GMT by grib_to_netcdf-2.14.0: /opt/ecmw...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;method-2&#34;&gt;- Method 2:&lt;/h3&gt;

&lt;p&gt;We can directly use xarray library to apply netcdf mask with using .where() method and DataArray mask:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mask
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray &#39;region&#39; (latitude: 721, longitude: 1440)&amp;gt;
array([[nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       [nan, nan, nan, ..., nan, nan, nan],
       ...,
       [nan,  7.,  7., ...,  7.,  7.,  7.],
       [nan,  7.,  7., ...,  7.,  7.,  7.],
       [nan, nan, nan, ..., nan, nan, nan]])
Coordinates:
  * latitude   (latitude) float32 90.0 89.75 89.5 89.25 ... -89.5 -89.75 -90.0
  * longitude  (longitude) float32 -180.0 -179.75 -179.5 ... 179.25 179.5 179.75
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;out_sel2 = ds.where(mask == 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;out_sel1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 289, longitude: 333, time: 8760)
Coordinates:
  * latitude   (latitude) float64 37.25 37.0 36.75 36.5 ... -34.25 -34.5 -34.75
  * longitude  (longitude) float64 -25.25 -25.0 -24.75 ... 57.25 57.5 57.75
  * time       (time) datetime64[ns] 2018-01-01 ... 2018-12-31T23:00:00
Data variables:
    t2m        (time, latitude, longitude) float32 nan nan nan ... nan nan nan
Attributes:
    Conventions:  CF-1.6
    history:      2019-11-11 13:33:07 GMT by grib_to_netcdf-2.14.0: /opt/ecmw...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;out_sel2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 721, longitude: 1440, time: 8760)
Coordinates:
  * longitude  (longitude) float32 -180.0 -179.75 -179.5 ... 179.25 179.5 179.75
  * latitude   (latitude) float32 90.0 89.75 89.5 89.25 ... -89.5 -89.75 -90.0
  * time       (time) datetime64[ns] 2018-01-01 ... 2018-12-31T23:00:00
Data variables:
    t2m        (time, latitude, longitude) float32 dask.array&amp;lt;shape=(8760, 721, 1440), chunksize=(10, 721, 1440)&amp;gt;
Attributes:
    Conventions:  CF-1.6
    history:      2019-11-11 13:33:07 GMT by grib_to_netcdf-2.14.0: /opt/ecmw...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quick visualisation, we will display the first step of our DataArray masked.&lt;/p&gt;

&lt;p&gt;For out_sel1 array :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.figure(figsize=(12,8))
ax = plt.axes()
out_sel1.t2m.isel(time = 0).plot(ax = ax)
continents.plot(ax = ax, alpha = 0.8, facecolor = &#39;none&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0xba03908&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./continent2.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;For out_sel2 array :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.figure(figsize=(15,8))
ax = plt.axes()
out_sel2.t2m.isel(time = 0).plot(ax = ax)
continents.plot(ax = ax, alpha = 0.8, facecolor = &#39;none&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.axes._subplots.AxesSubplot at 0x759f9e8&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;!&lt;img src=&#34;./continent3.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Finally we can resample our dataset by day and then compute a daily mean.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With out_sel1:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;daily_mean = out_sel1.resample(time = &#39;1D&#39;).mean()-273.15
daily_mean
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 289, longitude: 333, time: 365)
Coordinates:
  * latitude   (latitude) float64 37.25 37.0 36.75 36.5 ... -34.25 -34.5 -34.75
  * longitude  (longitude) float64 -25.25 -25.0 -24.75 ... 57.25 57.5 57.75
  * time       (time) datetime64[ns] 2018-01-01 2018-01-02 ... 2018-12-31
Data variables:
    t2m        (time, latitude, longitude) float32 nan nan nan ... nan nan nan
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To compute spatial mean over Africa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;daily_mean = daily_mean.t2m.mean(dim=(&#39;longitude&#39;,&#39;latitude&#39;))
daily_mean
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray &#39;t2m&#39; (time: 365)&amp;gt;
array([20.868923, 20.559137, 20.618475, ..., 20.510223, 20.604036, 20.943094],
      dtype=float32)
Coordinates:
  * time     (time) datetime64[ns] 2018-01-01 2018-01-02 ... 2018-12-31
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we plot the time-series…&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;daily_mean.plot()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&amp;lt;matplotlib.lines.Line2D at 0xc2d4cf8&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./continent4.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And we save it as a csv.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;daily_mean.to_pandas().to_csv(&#39;average-daily-temperature.csv&#39;, header = [&#39;t2m&#39;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just to see if we find same results with masking method 2. We will plot the same time serie with out_sel2 Xarray:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;daily_mean2 = out_sel2.resample(time = &#39;1D&#39;).mean()-273.15
daily_mean2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.Dataset&amp;gt;
Dimensions:    (latitude: 721, longitude: 1440, time: 365)
Coordinates:
  * latitude   (latitude) float32 90.0 89.75 89.5 89.25 ... -89.5 -89.75 -90.0
  * longitude  (longitude) float32 -180.0 -179.75 -179.5 ... 179.25 179.5 179.75
  * time       (time) datetime64[ns] 2018-01-01 2018-01-02 ... 2018-12-31
Data variables:
    t2m        (time, latitude, longitude) float32 dask.array&amp;lt;shape=(365, 721, 1440), chunksize=(1, 721, 1440)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;daily_mean2 = daily_mean2.t2m.mean(dim=(&#39;longitude&#39;,&#39;latitude&#39;))
daily_mean2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray &#39;t2m&#39; (time: 365)&amp;gt;
dask.array&amp;lt;shape=(365,), dtype=float32, chunksize=(1,)&amp;gt;
Coordinates:
  * time     (time) datetime64[ns] 2018-01-01 2018-01-02 ... 2018-12-31
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;daily_mean2.plot()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&amp;lt;matplotlib.lines.Line2D at 0xc2d1f28&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./continent5.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Temperature Radial Chart</title>
      <link>/post/temperature_radial_chart/</link>
      <pubDate>Fri, 06 Dec 2019 20:00:03 -0800</pubDate>
      <guid>/post/temperature_radial_chart/</guid>
      <description>

&lt;h3 id=&#34;plot-of-a-radial-temperature-chart&#34;&gt;Plot of a radial temperature chart&lt;/h3&gt;

&lt;p&gt;In this post, we will plot a radial temperature chart using daily temperature from Environment Canada.&lt;/p&gt;

&lt;p&gt;The objective of this product is to obtain an analysis of the daily evolution of the temperature and its positioning in relation to the norm and the historical records of the Julian day.&lt;/p&gt;

&lt;p&gt;In this work, we will extract data from Environment and Climate Change Canada for the RIGAUD station in Quebec. Here is the information about this station:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Name: RIGAUD
Username: 5252
Latitude: 45.5 degN
Longitude: -74.37 degW
Period covered: 1963 - today
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A list of stations is available on this &lt;a href=&#34;ftp://ftp.tor.ec.gc.ca/Pub/Get_More_Data_More_data/Repository%20of%20stations%20FR.csv&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The data will be uploaded directly to Environment and Climate Change Canada&amp;rsquo;s  &lt;a href=&#34;Repository%20of%20stations%20FR.csv&#34; target=&#34;_blank&#34;&gt;website&lt;/a&gt; &lt;a href=&#34;http://climate.weather.gc.ca/)&#34; target=&#34;_blank&#34;&gt;http://climate.weather.gc.ca/)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The data is in XML format. XML or eXtensible Markup Language is a generic markup language. To read this format, we will call the &lt;a href=&#34;https://docs.python.org/2/library/xml.etree.elementtree.html#module-xml.etree.ElementTree&#34; target=&#34;_blank&#34;&gt;&amp;lsquo;xml.etree.ElementTree&amp;rsquo; library&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First, we import the necessary libraries:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- matplotlib: module to plot our graph
- datetime: python module for manipulating dates
- wget: module to extract data on a url
- pandas: module for working with data structures
- os: &amp;quot;system&amp;quot; module to create, delete ... files from our environment
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib.pyplot as plt
import numpy as np
import matplotlib.ticker as ticker
from datetime import date
import os
import wget
import pandas as pd
import xml.etree.ElementTree as ET
import warnings
warnings.filterwarnings(&amp;quot;ignore&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, we will extract the year 2000 daily records of the station RIGAUD (ID: 5252).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;id_stat = 5252
year = 2000
tmp_file = wget.download(&#39;http://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=xml&amp;amp;stationID=&#39;+str(int(id_stat))+&#39;&amp;amp;Year=&#39;+str(year)+&#39;&amp;amp;Month=01&amp;amp;Day=14&amp;amp;timeframe=2&#39;)
tree=ET.parse(tmp_file)
os.remove(tmp_file)
root=tree.getroot()
stationsdata = root.findall(&#39;.//stationdata&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;-1 / unknown
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notre fichier XML a la structure suivant:&lt;br /&gt;
Our XML file got this structure:&lt;/p&gt;

&lt;p&gt;&lt;stationdata year=&#34;1955&#34; month=&#34;1&#34; day=&#34;1&#34;&gt;
    &lt;maxtemp units=&#34;°C&#34; description=&#34;Maximum Temperature&#34;&gt;3.3&lt;/maxtemp&gt;
    &lt;mintemp units=&#34;°C&#34; description=&#34;Minimum Temperature&#34;&gt;-4.4&lt;/mintemp&gt;
    &lt;meantemp units=&#34;°C&#34; description=&#34;Mean Temperature&#34;&gt;-0.6&lt;/meantemp&gt;
    &lt;heatdegdays units=&#34;°C&#34; description=&#34;Heating Degree Days&#34;&gt;18.6&lt;/heatdegdays&gt;
    &lt;cooldegdays units=&#34;°C&#34; description=&#34;Cooling Degree Days&#34;&gt;0.0&lt;/cooldegdays&gt;
    &lt;totalrain units=&#34;mm&#34; description=&#34;Total Rain&#34;&gt;0.0&lt;/totalrain&gt;
    &lt;totalsnow units=&#34;cm&#34; description=&#34;Total Snow&#34;&gt;0.0&lt;/totalsnow&gt;
    &lt;totalprecipitation units=&#34;mm&#34; description=&#34;Total Precipitation&#34;&gt;0.0&lt;/totalprecipitation&gt;
    &lt;snowonground units=&#34;cm&#34; description=&#34;Snow on Ground&#34;/&gt;
    &lt;dirofmaxgust units=&#34;10s Deg&#34; description=&#34;Direction of Maximum Gust&#34;/&gt;
    &lt;speedofmaxgust units=&#34;km/h&#34; description=&#34;Speed of Maximum Gust&#34;/&gt;
&lt;/stationdata&gt;&lt;/p&gt;

&lt;p&gt;We need to target the maxtemp and mintemp tags for our work, so the stationdata[0] and station[1] fields.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;resultmax = []
resultmin = []
for stationdata in stationsdata:
    champs1=stationdata.find(&#39;maxtemp&#39;)              
    resultmax.append(champs1.text)   #  we append data for each day in a year 
    data_max=np.array(resultmax,&amp;quot;float&amp;quot;)     
for stationdata in stationsdata:
    champs2=stationdata.find(&#39;mintemp&#39;)              
    resultmin.append(champs2.text)   #  we append data for each day in a year 
    data_min=np.array(resultmin,&amp;quot;float&amp;quot;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We then have two python lists with daily minimum and maximum temperatures.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(resultmax[0:5])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[&#39;-1.0&#39;, &#39;5.5&#39;, &#39;2.0&#39;, &#39;4.0&#39;, &#39;-3.0&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can do the same over the whole recording period of the station (1963-2019) by applying a for loop over the years.&lt;/p&gt;

&lt;p&gt;For each year and each variable to be extracted we will increment a list in the variables min_array = [] and max_array = [].&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;yi = 1963
yf = 2019
id_stat = 5252
station = &#39;RIGAUD&#39;
max_array = []
min_array = []
for year in range(yi,yf+1):    ### loop over yars 
    tmp_file = wget.download(&#39;http://climate.weather.gc.ca/climate_data/bulk_data_e.html?format=xml&amp;amp;stationID=&#39;+str(int(id_stat))+&#39;&amp;amp;Year=&#39;+str(year)+&#39;&amp;amp;Month=01&amp;amp;Day=14&amp;amp;timeframe=2&#39;)
    tree=ET.parse(tmp_file)
    os.remove(tmp_file)
    root=tree.getroot()
    stationsdata = root.findall(&#39;.//stationdata&#39;)
    resultmax = []
    resultmin = []
    for  stationdata in stationsdata:
         champs1=stationdata.find(&#39;maxtemp&#39;)              
         resultmax.append(champs1.text)   #  loop over days for tmax 
         data_max=np.array(resultmax,&amp;quot;float&amp;quot;)     
    for  stationdata in stationsdata:
         champs2=stationdata.find(&#39;mintemp&#39;)              
         resultmin.append(champs2.text)   #  loop over days for tmin 
         data_min=np.array(resultmin,&amp;quot;float&amp;quot;) 
         
    max_array.append(data_max)
    min_array.append(data_min)
len(max_array)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;-1 / unknown




57
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For each min_array and max_array fields, we get a list of lists. We will flatten thoses lists:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def flatten(input):
    new_list = []
    for i in input:
        for j in i:
            new_list.append(j)
    return new_list
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;min_array=flatten(min_array) 
max_array=flatten(max_array)
len(min_array)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;20819
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we now have two lists of 20454 days for each min_array and max_array fields.&lt;/p&gt;

&lt;p&gt;Knowing that the period extends from January 1, 1963 to December 31, 2018, we can add a temporal dimension to our dataframe with the datetime module of python.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;start = date(1963, 1, 1)
end = date(2019, 12, 31)
delta=(end-start) 
nb_days = delta.days + 1 
rng = pd.date_range(start, periods=nb_days, freq=&#39;D&#39;)
tmin_dataset = pd.Series(min_array, index=rng)
tmax_dataset = pd.Series(max_array, index=rng)
tmax_dataset.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;1963-01-01   -11.1
1963-01-02    -6.7
1963-01-03    -3.9
1963-01-04    -2.2
1963-01-05    -3.9
Freq: D, dtype: float64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the big advantages of the pandas dataframe is that we can very easily work with time series.
Here we will calculate the daily climatologies of the tmin_dataset and tmax_dataset variables over the 1981-2010 normal period.&lt;/p&gt;

&lt;p&gt;Also, with the pandas groupby tools, we can calculate the daily minimum and maximum of tmin_dataset and tmax_dataset over the full period of the recording.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;mintmin = []
maxtmax = []
climtmin = []
climtmax = []

clim_min_dataset=tmin_dataset[&#39;1981&#39;:&#39;2010&#39;]
clim_max_dataset=tmax_dataset[&#39;1981&#39;:&#39;2010&#39;]
climtmin = clim_min_dataset.groupby([clim_min_dataset.index.month, clim_min_dataset.index.day]).mean()
climtmax = clim_max_dataset.groupby([clim_max_dataset.index.month, clim_max_dataset.index.day]).mean()

mintmin = tmin_dataset.groupby([tmin_dataset.index.month, tmin_dataset.index.day]).min()
maxtmax = tmax_dataset.groupby([tmax_dataset.index.month, tmax_dataset.index.day]).max()


data_min_tmin=np.array(mintmin,&amp;quot;float&amp;quot;)  
data_max_tmax=np.array(maxtmax,&amp;quot;float&amp;quot;) 
data_clim_tmax=np.array(climtmax,&amp;quot;float&amp;quot;)     
data_clim_tmin=np.array(climtmin,&amp;quot;float&amp;quot;) 

print(len(data_clim_tmax))
print(len(maxtmax))

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;366
366
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can know visualize our timeries with a radial chart.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = []
ndays=366
Azs=np.arange(0,ndays)
angle = Azs * 2.0 * np.pi / ndays

fig=plt.figure(figsize=(12,12))
ax = fig.add_subplot(111, polar=True)

ax.plot([angle[0],angle[0]], [data_min[0],data_max[0]],&#39;red&#39;, alpha=1.0, linewidth=3.0, label=str(yf))
ax.plot([angle[0],angle[0]], [data_clim_tmin[0],data_clim_tmax[0]],&#39;blue&#39;, alpha=0.3, linewidth=3.0, label=&#39;Climatology (1981-2010)&#39;)
ax.plot([angle[0],angle[0]], [data_min_tmin[0],data_max_tmax[0]],&#39;grey&#39;, alpha=0.4, linewidth=3.0, label=&#39;Extreme (&#39;+str(yi)+&#39;-&#39;+str(yf)+&#39;)&#39;)

leg=plt.legend(bbox_to_anchor=(0.15, 1.0),fontsize=10)
leg.get_frame().set_linewidth(0.0)
leg.set_title(str(station)+&#39; &#39;+str(yf), prop={&#39;size&#39;: 10, &#39;weight&#39;: &#39;heavy&#39;})

ax.plot([angle,angle], [data_min,data_max],&#39;red&#39;, alpha=1.0, linewidth=3.0)
ax.plot([angle,angle], [data_clim_tmin,data_clim_tmax],&#39;blue&#39;, alpha=0.3, linewidth=3.0)
ax.plot([angle,angle], [data_min_tmin,data_max_tmax],&#39;grey&#39;, alpha=0.4, linewidth=3.0)

ax.set_rmin(-40)
ax.set_rmax(+40)
ax.grid(True)
ax.set_theta_direction(-1)
ax.set_theta_offset(np.pi / 2)

ax.set_rticks([-30,-20, -10, 0, 10, 20, 30])  # less radial ticks
ax.set_rlabel_position(-45.)  # get radial labels away from plotted line
ax.set_yticklabels([&#39;$-30^{\circ}$&#39;, &#39;$-20^{\circ}$&#39;, &#39;$-10^{\circ}$&#39;, &#39;$0^{\circ}$&#39;, &#39;$10^{\circ}$&#39;, &#39;$20^{\circ}$&#39;, &#39;$30^{\circ}$&#39; ],
   fontsize=10)

# Set the major and minor tick locations
ax.xaxis.set_major_locator(ticker.MultipleLocator(np.pi/6))
ax.xaxis.set_minor_locator(ticker.MultipleLocator(np.pi/12))
ax.grid(linewidth=1,color=&#39;grey&#39;, linestyle=&#39;-&#39;)

# Turn off major tick labels
ax.xaxis.set_major_formatter(ticker.NullFormatter())
ax.set_frame_on(False)

# Set the minor tick width to 0 so you don&#39;t see them
for tick in ax.xaxis.get_minor_ticks():
    tick.tick1line.set_markersize(0)
    tick.tick2line.set_markersize(0)
    tick.label1.set_horizontalalignment(&#39;center&#39;)

# Set the names of your ticks, with blank spaces for the major ticks
ax.set_xticklabels([&#39;&#39;,&#39;Jan&#39;,&#39;&#39;,&#39;Feb&#39;,&#39;&#39;,&#39;Mar&#39;,&#39;&#39;,&#39;Apr&#39;,&#39;&#39;,&#39;May&#39;,&#39;&#39;,&#39;Jun&#39;,&#39;&#39;,&#39;Jul&#39;,&#39;&#39;,&#39;Aug&#39;,&#39;&#39;,&#39;Sep&#39;,&#39;&#39;,&#39;Oct&#39;,&#39;&#39;,&#39;Nov&#39;,&#39;&#39;,&#39;Dec&#39;],minor=True)

plt.show()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_18_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ECCC homogenized dataset</title>
      <link>/post/eccc_temp/</link>
      <pubDate>Fri, 06 Dec 2019 19:50:39 -0800</pubDate>
      <guid>/post/eccc_temp/</guid>
      <description>

&lt;h2 id=&#34;extract-daily-temperature-from-environment-canada-using-python&#34;&gt;Extract daily temperature from Environment Canada using Python&lt;/h2&gt;

&lt;p&gt;The objective of this product is to retrieve daily temperature data from the second generation homogenized dataset of Environment and Climate Change Canada developed by Vincent et al. 2012.&lt;/p&gt;

&lt;p&gt;Adjusted and homogenized Canadian climate dataset (DCCAH) were prepared to provide a better spatial and temporal representation of the climate trends in Canada.&lt;/p&gt;

&lt;p&gt;In the Second Generation of Homogenized Temperature, new adjustments were applied to the daily minimum temperatures at synoptic stations (mainly airports) to address the bias due to the change in observing time in July 1961 (Vincent et al. 2009).&lt;/p&gt;

&lt;p&gt;Daily homogenized temperatures (minimum, maximum and mean) can be dowloaded on this &lt;a href=&#34;ftp://ccrp.tor.ec.gc.ca/pub/EC_data/AHCCD_daily/&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Raw dataset can be downloaded &lt;a href=&#34;http://climate.weather.gc.ca/historical_data/search_historic_data_f.html&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this post, we will work on a specific province in Canada (using filters). To do this, we will use  Temperature_Stations.xls available on ftp site. This file provide us a list of all stations available.&lt;/p&gt;

&lt;p&gt;We first need to import our librairies:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
import pandas as pd
import os
from datetime import date
import calendar
import numpy as np
import pathlib
import warnings
warnings.filterwarnings(&amp;quot;ignore&amp;quot;)
from itertools import islice
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will work with daily minimum temperature data only for the Northwest Territories of Canada.&lt;/p&gt;

&lt;p&gt;Referring to the document Temperature_Stations.xls, we see that the acronym for this province is: NWT.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dataframe = pd.read_excel(&amp;quot;./Temperature_Stations.xls&amp;quot;, skiprows = range(0, 3))
dataframe.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Prov&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Nom de station&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;stnid&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;année déb.&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;mois déb.&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;année fin.&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;mois fin.&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;lat (deg)&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;long (deg)&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;élév (m)&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;stns jointes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;BC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;AGASSIZ&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1100120&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1893&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2018&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49.25&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-121.77&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;15&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;BC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;ATLIN&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1200560&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1905&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2018&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;59.57&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-133.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;674&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;BC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;BARKERVILLE&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1090660&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1888&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2015&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;53.07&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-121.52&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1265&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;BC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;BEAVERDELL&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1130771&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1939&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2006&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49.48&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-119.05&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;838&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;BC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;BELLA COOLA&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1060841&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1895&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2017&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;52.37&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-126.68&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;18&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Using this Dataframe we can define some input parameters to filter our data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;varin = &#39;dn&#39;                          # variable acronym                                                                  
path = &#39;Homog_daily_min_temp_v2018&#39;   # path to get data                                       
varout = &#39;Tasmin&#39;                      
province = &#39;NWT&#39;                      # Province to work with
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now filter our dataset.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;globals()[&#39;dataframe_&#39;+province] = dataframe.loc[(dataframe[&amp;quot;Prov&amp;quot;] == province),:]
globals()[&#39;dataframe_&#39;+province]
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Prov&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Nom de station&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;stnid&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;année déb.&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;mois déb.&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;année fin.&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;mois fin.&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;lat (deg)&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;long (deg)&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;élév (m)&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;stns jointes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;65&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NWT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CAPE PARRY&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2200675&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1957&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2018&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;70.17&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-124.72&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;87&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;N&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;66&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NWT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FORT GOOD HOPE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2201450&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1944&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2018&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;66.23&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-128.65&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;82&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;68&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NWT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FORT RELIANCE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2201903&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1948&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2018&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;62.72&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-109.17&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;168&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;69&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NWT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FORT SIMPSON&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2202103&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1895&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2018&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;61.77&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-121.23&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;169&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;70&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NWT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;FORT SMITH&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2202201&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1913&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2018&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;60.02&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-111.97&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;205&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;71&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NWT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;HAY RIVER&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2202401&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1893&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2018&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;60.83&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-115.78&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;166&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;72&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NWT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;INUVIK&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2202578&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1957&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2018&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;68.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-133.48&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;103&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;73&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NWT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;MOULD BAY&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;250M001&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1948&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2018&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;76.23&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-119.35&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;74&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NWT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NORMAN WELLS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2202801&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1943&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2018&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;65.28&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-126.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;73&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;75&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NWT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;SACHS HARBOUR&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2503648&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1955&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2018&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;72&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-125.27&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;86&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;76&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NWT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;TUKTOYAKTUK&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2203914&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1957&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2018&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;69.45&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-133&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;18&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;77&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NWT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;YELLOWKNIFE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2204101&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1942&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2018&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;62.47&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-114.43&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;206&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We found 13 stations for this province.&lt;/p&gt;

&lt;p&gt;We want to work with YELLOWKNIFE station:  stnid = 2204101.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;stnid = &#39;2204101&#39;   
f1 = open(&#39;./&#39;+path+&#39;/&#39;+str(varin)+str(stnid)+&#39;.txt&#39;, &#39;r&#39;)
for line in islice(f1, 7):
        print(line)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;2204101,    YELLOWKNIFE    ,  NWT, station joined    , Homogenized daily minimum temperature        , Deg Celcius,          Updated to December 2018

2204101,    YELLOWKNIFE    ,  NWT, station jointe    , Temperature quotidienne minimale homogeneisee, Deg Celcius, Mise a jour jusqu a decembre 2018

 Year Mo  Day 01  Day 02  Day 03  Day 04  Day 05  Day 06  Day 07  Day 08  Day 09  Day 10  Day 11  Day 12  Day 13  Day 14  Day 15  Day 16  Day 17  Day 18  Day 19  Day 20  Day 21  Day 22  Day 23  Day 24  Day 25  Day 26  Day 27  Day 28  Day 29  Day 30  Day 31

Annee Mo Jour 01 Jour 02 Jour 03 Jour 04 Jour 05 Jour 06 Jour 07 Jour 08 Jour 09 Jour 10 Jour 11 Jour 12 Jour 13 Jour 14 Jour 15 Jour 16 Jour 17 Jour 18 Jour 19 Jour 20 Jour 21 Jour 22 Jour 23 Jour 24 Jour 25 Jour 26 Jour 27 Jour 28 Jour 29 Jour 30 Jour 31

 1942  7    12.2    13.3    11.7    10.0     9.4    11.7    14.4    14.4    13.3    12.2    10.6    11.7    11.1    12.8    14.4    15.0    13.9    14.4    13.9    14.4    13.9    13.3    11.7    12.2    11.1    12.2    13.3    10.0    10.6    11.7     8.3 

 1942  8     7.8     5.0     9.4    12.8     9.4     9.4    10.0    10.6    12.8    10.6    12.2    12.2     9.4    15.0    12.8    11.7    14.4    14.4    11.7     8.3     9.4     7.8    12.2     8.9     3.9     7.2    10.6    11.1     7.2     5.0     3.3 

 1942  9     3.9     6.1     6.1     8.3     9.4    11.1    11.1     6.7     6.1     9.4     5.0     9.4     7.2     4.4     5.0     4.4     3.3     1.1     2.2    -0.6    -2.2     0.0    -1.7     1.1    -4.4    -0.6     0.0    -0.6     1.7     1.1 -9999.9M
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cleaning-data&#34;&gt;Cleaning data:&lt;/h3&gt;

&lt;p&gt;We see that in our dataset we have for each line the daily data by year and by month according to the structure:&lt;/p&gt;

&lt;p style=&#34;color:blue;font-size:12px;&#34;&gt;  Year Mo  Day 01  Day 02  Day 03  Day 04  Day 05  Day 06  Day 07  Day 08  Day 09  Day 10  Day 11  Day 12  Day 13  Day 14  Day 15  Day 16  Day 17  Day 18  Day 19  Day 20  Day 21  Day 22  Day 23  Day 24  Day 25  Day 26  Day 27  Day 28  Day 29  Day 30  Day 31 &lt;/p&gt;  

&lt;p&gt;There is a 4 rows header. We will delete this header and also delete the alphanumeric characters, clean the missing values and create a dataframe.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;f1 = open(&#39;./&#39;+path+&#39;/&#39;+str(varin)+str(stnid)+&#39;.txt&#39;, &#39;r&#39;)
f2 = open(&#39;./tmp.txt&#39;, &#39;w&#39;)
for line in f1:
    for word in line:
            if word == &#39;M&#39;:
                f2.write(word.replace(&#39;M&#39;, &#39; &#39;))
            elif word == &#39;a&#39;:
                f2.write(word.replace(&#39;a&#39;, &#39; &#39;))                    
            else:
                f2.write(word)
f1.close()
f2.close()      
df_station = pd.read_csv(&#39;./tmp.txt&#39;, delim_whitespace=True, skiprows = range(0, 4))
df_station.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1942&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;12.2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;13.3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;11.7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10.0&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;9.4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;11.7.1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;14.4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;14.4.1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;13.3.1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;12.2.1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10.6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;11.7.2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;11.1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;12.8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;14.4.2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;15.0&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;13.9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;14.4.3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;13.9.1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;14.4.4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;13.9.2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;13.3.2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;11.7.3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;12.2.2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;11.1.1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;12.2.3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;13.3.3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10.0.1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;10.6.1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;11.7.4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8.3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1942&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;15&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;14.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;14.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1942&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-2.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-4.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-9999.9&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1942&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-2.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-2.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-2.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-6.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-10.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-11.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-7.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-2.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-3.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-8.3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1942&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-11.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-13.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-13.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-12.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-12.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-12.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-12.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-17.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-12.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-21.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-16.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-16.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-17.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-11.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-22.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-25&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-25&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-22.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-17.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-23.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-26.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-13.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-18.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-26.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-32.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-31.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-34.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-26.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-30&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-27.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-9999.9&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1942&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-23.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-20.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-20.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-25&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-20.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-20.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-26.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-27.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-30&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-31.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-28.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-23.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-25&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-31.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-33.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-37.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-37.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-38.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-40.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-39.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-33.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-35&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-35.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-33.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-26.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-31.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-34.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-28.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-24.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-33.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-40.6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;That&amp;rsquo;s better but we still have some missing values. We will also change column names.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df_station.columns = [&#39;Year&#39;, &#39;Month&#39;, &#39;D1&#39;,&#39;D2&#39;,&#39;D3&#39;,&#39;D4&#39;,&#39;D5&#39;,&#39;D6&#39;,&#39;D7&#39;,&#39;D8&#39;,&#39;D9&#39;,&#39;D10&#39;,
                                  &#39;D11&#39;,&#39;D12&#39;,&#39;D13&#39;,&#39;D14&#39;,&#39;D15&#39;,&#39;D16&#39;,&#39;D17&#39;,&#39;D18&#39;,&#39;D19&#39;,&#39;D20&#39;,
                                  &#39;D21&#39;,&#39;D22&#39;,&#39;D23&#39;,&#39;D24&#39;,&#39;D25&#39;,&#39;D26&#39;,&#39;D27&#39;,&#39;D28&#39;,&#39;D29&#39;,&#39;D30&#39;,&#39;D31&#39;]
     
os.remove(&amp;quot;./tmp.txt&amp;quot;)
   
   # nettoyage des valeurs manquantes 
try:  
    df_station = df_station.replace({&#39;E&#39;:&#39;&#39;}, regex=True)
except:
       pass
try: 
    df_station = df_station.replace({&#39;a&#39;:&#39;&#39;}, regex=True)
except:
       pass
try:     
    df_station = df_station.replace({&#39;-9999.9&#39;:&#39;&#39;}, regex=True)
except:
       pass
try:     
    df_station = df_station.replace({-9999.9:&#39;&#39;}, regex=True)
except:
       pass    
    
for col in  df_station.columns[2:]:
       df_station[col] = pd.to_numeric(df_station[col], errors=&#39;coerce&#39;)      
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df_station.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Year&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Month&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D1&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D3&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D4&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D5&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D6&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D7&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D8&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D9&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D10&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D11&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D12&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D13&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D14&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D15&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D16&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D17&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D18&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D19&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D20&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D21&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D22&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D23&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D24&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D25&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D26&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D27&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D28&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D29&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D30&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;D31&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1942&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;15&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;14.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;14.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1942&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-2.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-4.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-9999.9&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1942&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-2.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-2.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-2.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-6.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-10.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-11.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-7.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-2.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-1.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-3.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-8.3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1942&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-11.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-13.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-13.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-12.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-12.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-12.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-12.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-17.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-12.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-21.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-16.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-16.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-17.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-11.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-22.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-25&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-25&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-22.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-17.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-23.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-26.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-13.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-18.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-26.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-32.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-31.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-34.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-26.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-30&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-27.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-9999.9&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1942&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-23.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-20.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-20.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-25&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-20.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-20.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-26.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-27.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-30&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-31.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-28.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-23.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-25&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-31.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-33.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-37.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-37.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-38.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-40.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-39.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-33.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-35&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-35.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-33.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-26.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-31.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-34.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-28.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-24.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-33.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-40.6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We can now detect the minimum and maximum recording years and write the daily data on a single column.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;yearmin = df_station[&#39;Year&#39;].min()                                  
yearmax = df_station[&#39;Year&#39;].max()                                   
m_start =  df_station[&#39;Month&#39;].loc[(df_station[&#39;Year&#39;] == yearmin)].min()
m_end   =  df_station[&#39;Month&#39;].loc[(df_station[&#39;Year&#39;] == yearmax)].max()
d_end = calendar.monthrange(yearmax, m_end)[1]                     

tmp_tmin = [ ] 
for year in range(yearmin,yearmax+1):    ### Loop over years
    for month in range(1,13):
        df = []
        last_day = calendar.monthrange(year, month)[1] 
        tmin = df_station.loc[(df_station[&amp;quot;Year&amp;quot;] == year) &amp;amp; (df_station[&amp;quot;Month&amp;quot;] == month)].iloc[:,2:last_day+2].values
           
        if len(tmin) == 0:
            a = np.empty((calendar.monthrange(year,month)[1]))
            a[:] = np.nan
            df=pd.DataFrame(a)
        else:
            df=pd.DataFrame(tmin.T)
               
        start = date(year, month, 1)
        end =   date(year, month, last_day)
        delta=(end-start) 
        nb_days = delta.days + 1 
        rng = pd.date_range(start, periods=nb_days, freq=&#39;D&#39;)          
        df[&#39;datetime&#39;] = rng
        df.index = df[&#39;datetime&#39;]
        tmp_tmin.append(df)
           
tmp_tmin = pd.concat(tmp_tmin) 
df = pd.DataFrame({&#39;datetime&#39;: tmp_tmin[&#39;datetime&#39;], &#39;Var&#39;: tmp_tmin.iloc[:,0]}, columns = [&#39;datetime&#39;,&#39;Tmin&#39;]) 
df.index = df[&#39;datetime&#39;]
tmp_tmin = tmp_tmin.drop([&amp;quot;datetime&amp;quot;], axis=1)
tmp_tmin.tail()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;datetime&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2018-12-27 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-32.6&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2018-12-28 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-33.3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2018-12-29 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-27.7&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2018-12-30 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-35.2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2018-12-31 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-33.8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;visualization&#34;&gt;Visualization:&lt;/h3&gt;

&lt;p&gt;Quick visualization of the monthly average temperatures for the month of January.
We will group the data by month and calculate the average.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib.pylab as plt
import datetime
month_tmin = tmp_tmin.resample(&#39;M&#39;).mean()
month_tmin.tail()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;datetime&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2018-08-31 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8.9871&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2018-09-30 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-0.673333&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2018-10-31 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-4.99032&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2018-11-30 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-15.5233&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;2018-12-31 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-21.8129&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tmin_janvier = month_tmin[month_tmin.index.month==1]
tmin_janvier.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;datetime&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;1942-01-31 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;nan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;1943-01-31 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-32.6871&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;1944-01-31 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-25.471&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;1945-01-31 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-28.6355&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;1946-01-31 00:00:00&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-33.4032&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.rcParams[&amp;quot;figure.figsize&amp;quot;]=[10,6]        
plt.plot(tmin_janvier.index, tmin_janvier[:],  label=&#39;Tmin Station&#39;, linewidth=2, c=&#39;r&#39;)
plt.title(&#39;Monthly mean of daily minimum temperature: January from &#39; + datetime.date(yearmin, 1, 1).strftime(&#39;%Y&#39;)+ &#39; et &#39;  + datetime.date(yearmax, 1, 1).strftime(&#39;%Y&#39;), fontsize=15, color=&#39;black&#39;, weight=&#39;semibold&#39;)
plt.xlabel(&#39;Year&#39;, fontsize=15, color=&#39;black&#39;, weight=&#39;semibold&#39;)
plt.ylabel(&#39;°C&#39;, fontsize=15, color=&#39;black&#39;, weight=&#39;semibold&#39;)
plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;output_20_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;final-code&#34;&gt;Final code&lt;/h2&gt;

&lt;p&gt;The following code retrieves all stations for a specific province but for a common period.&lt;/p&gt;

&lt;p&gt;For example, we wish to extract all daily temperature data for the province of the Northwest Territories but only for the common period 1989-2018.&lt;/p&gt;

&lt;p&gt;We wish to have one file per station.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pandas as pd
import os
from datetime import date
import calendar
import numpy as np
import pathlib

################################################                                                            #
varin = &#39;dn&#39;                                                                  
path = &#39;Homog_daily_min_temp_v2018&#39;                                           
varout = &#39;Tasmoy&#39;
province = &#39;NWT&#39;  
yearmin = 1989 
yearmax = 2018
###############################################################################

dataframe = pd.read_excel(&amp;quot;./Temperature_Stations.xls&amp;quot;, skiprows = range(0, 3))

globals()[&#39;dataframe_&#39;+province] = dataframe.loc[(dataframe[&amp;quot;Prov&amp;quot;] == province) &amp;amp; (dataframe[&amp;quot;année déb.&amp;quot;] &amp;lt;= yearmin) &amp;amp; (dataframe[&amp;quot;année fin.&amp;quot;] &amp;gt;= yearmax),:]

names = []
for i, row in globals()[&#39;dataframe_&#39;+province].iterrows():
   stnid = row[&#39;stnid&#39;]   
   f1 = open(&#39;./&#39;+path+&#39;/&#39;+str(varin)+str(stnid)+&#39;.txt&#39;, &#39;r&#39;)
   f2 = open(&#39;./tmp.txt&#39;, &#39;w&#39;)

   for line in f1:
        for word in line:
            if word == &#39;M&#39;:
                f2.write(word.replace(&#39;M&#39;, &#39; &#39;))
            elif word == &#39;a&#39;:
                f2.write(word.replace(&#39;a&#39;, &#39; &#39;))                    
            else:
                f2.write(word)
   f1.close()
   f2.close()
          
   station = pd.read_csv(&#39;./tmp.txt&#39;, delim_whitespace=True, skiprows = range(0, 4))
   
   station.columns = [&#39;Annee&#39;, &#39;Mois&#39;, &#39;D1&#39;,&#39;D2&#39;,&#39;D3&#39;,&#39;D4&#39;,&#39;D5&#39;,&#39;D6&#39;,&#39;D7&#39;,&#39;D8&#39;,&#39;D9&#39;,&#39;D10&#39;,
                                  &#39;D11&#39;,&#39;D12&#39;,&#39;D13&#39;,&#39;D14&#39;,&#39;D15&#39;,&#39;D16&#39;,&#39;D17&#39;,&#39;D18&#39;,&#39;D19&#39;,&#39;D20&#39;,
                                  &#39;D21&#39;,&#39;D22&#39;,&#39;D23&#39;,&#39;D24&#39;,&#39;D25&#39;,&#39;D26&#39;,&#39;D27&#39;,&#39;D28&#39;,&#39;D29&#39;,&#39;D30&#39;,&#39;D31&#39;]
     
   os.remove(&amp;quot;./tmp.txt&amp;quot;)
 
   try:  
       station = station.replace({&#39;E&#39;:&#39;&#39;}, regex=True)
   except:
       pass
   try: 
       station = station.replace({&#39;a&#39;:&#39;&#39;}, regex=True)
   except:
       pass
   try:     
       station = station.replace({&#39;-9999.9&#39;:&#39;&#39;}, regex=True)
   except:
       pass
   try:     
       station = station.replace({-9999.9:&#39;&#39;}, regex=True)
   except:
       pass    
       
   for col in  station.columns[2:]:
       station[col] = pd.to_numeric(station[col], errors=&#39;coerce&#39;)
        
   m_start =  station[&#39;Mois&#39;].loc[(station[&#39;Annee&#39;] == yearmin)].min()
   m_end   =  station[&#39;Mois&#39;].loc[(station[&#39;Annee&#39;] == yearmax)].max()
   
   d_end = calendar.monthrange(yearmax, m_end)[1]
     
   tmp_tmin = [ ] 
   for year in range(yearmin,yearmax+1):    ### Boucle sur les annees
       for month in range(1,13):
           df = []
           last_day = calendar.monthrange(year, month)[1] 
           tmin = station.loc[(station[&amp;quot;Annee&amp;quot;] == year) &amp;amp; (station[&amp;quot;Mois&amp;quot;] == month)].iloc[:,2:last_day+2].values
           
           if len(tmin) == 0:
               a = np.empty((calendar.monthrange(year,month)[1]))
               a[:] = np.nan
               df=pd.DataFrame(a)
           else:
               df=pd.DataFrame(tmin.T)
               
           start = date(year, month, 1)
           end =   date(year, month, last_day)
           delta=(end-start) 
           nb_days = delta.days + 1 
           rng = pd.date_range(start, periods=nb_days, freq=&#39;D&#39;)          
           df[&#39;datetime&#39;] = rng
           df.index = df[&#39;datetime&#39;]
           tmp_tmin.append(df)
           
   tmp_tmin = pd.concat(tmp_tmin) 
   df = pd.DataFrame({&#39;datetime&#39;: tmp_tmin[&#39;datetime&#39;], &#39;Var&#39;: tmp_tmin.iloc[:,0]}, columns = [&#39;datetime&#39;,&#39;Tmin&#39;]) 
   df.index = df[&#39;datetime&#39;]
   tmp_tmin = tmp_tmin.drop([&amp;quot;datetime&amp;quot;], axis=1)
      
   name = row[&#39;Nom de station&#39;].replace(&#39; &#39;,&#39;_&#39;)
   name = name.replace(&amp;quot;&#39;&amp;quot;,&#39;&#39;)
   names.append(name)
   mypath=&#39;./Daily_data_by_Province/&#39;+varout+&#39;/&#39;
   pathlib.Path(mypath).mkdir(parents=True, exist_ok=True)
   
   tmp_tmin.to_csv(mypath+name+&#39;_daily_&#39;+varout+&#39;_&#39;+str(yearmin)+&#39;-&#39;+str(yearmax)+&#39;.csv&#39;)
         
latlon = pd.DataFrame({&#39;Latitude&#39;: globals()[&#39;dataframe_&#39;+province][&amp;quot;lat (deg)&amp;quot;], &#39;Longitude&#39;: globals()[&#39;dataframe_&#39;+province][&amp;quot;long (deg)&amp;quot;] }, columns = [&#39;Latitude&#39;,&#39;Longitude&#39;]) 
latlon.to_csv(&#39;./Daily_data_by_Province/stations_latlon_&#39;+province+&#39;.csv&#39;)
names = pd.DataFrame(names)
names.to_csv(&#39;./Daily_data_by_Province/stations_noms_&#39;+province+&#39;.csv&#39;)

base_filename = &#39;./Daily_data_by_Province/stations_noms_&#39;+province+&#39;.txt&#39;
names[0].to_csv(base_filename, sep=&#39;\t&#39;, index = False) 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ANUSPLIN 10km climatology</title>
      <link>/post/cartopy_climatology/</link>
      <pubDate>Mon, 02 Dec 2019 17:56:14 -0800</pubDate>
      <guid>/post/cartopy_climatology/</guid>
      <description>

&lt;h3 id=&#34;anusplin-climatology-using-cartopy&#34;&gt;ANUSPLIN climatology using Cartopy&lt;/h3&gt;

&lt;p&gt;Agriculture and Agri-Food Canada have produced daily precipitation, minimum and maximum temperature across Canada (south of 60°N) for climate related application purpose using thin-plate smoothing splines, as implemented in the ANUSPLIN climate modeling software (Hutchinson et al., 2009; McKenney et al., 2011).&lt;/p&gt;

&lt;p&gt;The so-called ANUSPLIN data uses ground-based observations and generates daily gridded data from 1951 to 2017 on a Lambert conformal conic projection with 5’ arc minutes spacing (equivalent to a resolution of about 10 km). The key strength of this spatial interpolation method is its global dependence on all data, permitting robust and stable determination of spatially varying dependences on elevation. Hutchinson et al. (2009) have shown that while ANUSPLIN fall month’s absolute errors were remarkably small, those of winter months were quite large due to rather difficult observation and measurement conditions.&lt;/p&gt;

&lt;p&gt;Data are available on &lt;a href=&#34;ftp://ftp.nrcan.gc.ca/pub/outgoing/canada_daily_grids&#34; target=&#34;_blank&#34;&gt;link&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this post, we will see how to use Cartopy with Netcdf in order to display a nice climatology.&lt;/p&gt;

&lt;p&gt;We will display a climatoly of ANUSPLIN from 1981 to 2010.&lt;/p&gt;

&lt;p&gt;This dataset is only availabe with ascii grid format, I&amp;rsquo;ll here show how to convert it into Netcdf using Python in an other post.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://scitools.org.uk/cartopy/docs/latest/#&#34; target=&#34;_blank&#34;&gt;Cartopy&lt;/a&gt; python library allows you to analyze, process and plot georeferenced data with the help of Matplotlib.&lt;/p&gt;

&lt;p&gt;We first import our librairies:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from netCDF4 import Dataset, num2date
import warnings
warnings.filterwarnings(&amp;quot;ignore&amp;quot;)
import datetime
import xarray as xr
import pandas as pd
filename=&#39;K:/DATA/ANUSPLIN_10km/Netcdf/all_domaine/YEAR/Mean_tasmoy/ANUSPLIN_10km_MEAN_YEAR_Mean_tasmoy_1950-2017.nc&#39;
nc_fid=Dataset(filename,&#39;r&#39;)
nc_fid.variables
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;OrderedDict([(&#39;lon&#39;, &amp;lt;class &#39;netCDF4._netCDF4.Variable&#39;&amp;gt;
              float32 lon(y, x)
                  units: degrees_east
                  long_name: Longitude
                  CoordinateAxisType: Lon
              unlimited dimensions: 
              current shape = (1068, 510)
              filling on, default _FillValue of 9.969209968386869e+36 used),
             (&#39;lat&#39;, &amp;lt;class &#39;netCDF4._netCDF4.Variable&#39;&amp;gt;
              float32 lat(y, x)
                  units: degrees_north
                  long_name: Latitude
                  CoordinateAxisType: Lat
              unlimited dimensions: 
              current shape = (1068, 510)
              filling on, default _FillValue of 9.969209968386869e+36 used),
             (&#39;time&#39;, &amp;lt;class &#39;netCDF4._netCDF4.Variable&#39;&amp;gt;
              float64 time(time)
                  long_name: Time
                  delta_t: 
              unlimited dimensions: 
              current shape = (68,)
              filling on, default _FillValue of 9.969209968386869e+36 used),
             (&#39;Mean_tasmoy&#39;, &amp;lt;class &#39;netCDF4._netCDF4.Variable&#39;&amp;gt;
              float32 Mean_tasmoy(time, y, x)
                  long_name: Mean_tasmoy
                  units: Celcius
                  missing_value: -999.0
                  coordinates: lon lat
              unlimited dimensions: 
              current shape = (68, 1068, 510)
              filling on, default _FillValue of 9.969209968386869e+36 used)])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data=nc_fid.variables[&#39;Mean_tasmoy&#39;][:].squeeze()
lons=nc_fid.variables[&#39;lon&#39;][:].squeeze()
lats=nc_fid.variables[&#39;lat&#39;][:].squeeze()
time = nc_fid.variables[&#39;time&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data.shape
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(68, 1068, 510)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data_m = data[32:62,:,:]
clim_81_2010=data_m.mean(axis=0)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;clim_81_2010.shape
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(1068, 510)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will add some cities to display on our map. We first need to create a dataframe with names of stations and localisations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;names=[&#39;Whitehorse&#39;,&#39;Yellowknife&#39;,&#39;Iqaluit&#39;,&#39;Victoria&#39;,&#39;Edmonton&#39;,&#39;Regina&#39;,&#39;Winnipeg&#39;,&#39;Toronto&#39;,&#39;Ottawa&#39;,&#39;Quebec&#39;,&#39;Halifax&#39;,&#39;Charlottetown&#39;,&#39;St-John s&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;latitudes=[60.721188,62.453972,63.748611,48.407326,53.631611,50.445210,
          49.895077,43.651070,45.424721,46.829853,44.651070,46.238888,47.560539]
longitudes=[-135.056839,-114.371788,-68.519722,-123.329773,-113.323975,-104.618896,
           -97.138451,-79.347015,-75.695000,-71.254028,-63.582687,-63.129166,-52.712830]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df = pd.DataFrame(list(zip(names, latitudes, longitudes)), 
               columns =[&#39;Names&#39;, &#39;latitudes&#39;, &#39;longitudes&#39;]) 
df
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;right&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Names&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;latitudes&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;longitudes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Whitehorse&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;60.7212&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-135.057&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Yellowknife&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;62.454&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-114.372&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Iqaluit&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;63.7486&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-68.5197&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Victoria&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;48.4073&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-123.33&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Edmonton&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;53.6316&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-113.324&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Regina&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;50.4452&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-104.619&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Winnipeg&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;49.8951&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-97.1385&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Toronto&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;43.6511&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-79.347&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Ottawa&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;45.4247&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-75.695&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Quebec&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;46.8299&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-71.254&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Halifax&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;44.6511&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-63.5827&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Charlottetown&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;46.2389&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-63.1292&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;right&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;St-John s&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;47.5605&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-52.7128&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib.pylab as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import numpy as np
import matplotlib as mpl
from carto import scale_bar

Y=np.array([[50,136,189],[102,194,165],[171,221,164],[230,245,152],\
               [255,255,191],[254,224,139],[253,174,97],[244,109,67],[213,62,79]])/255.

colbar=mpl.colors.ListedColormap(Y)
fig=plt.figure(figsize=(28,16), frameon=True)  
ax = plt.subplot(111, projection=ccrs.LambertConformal())
ax.set_extent([-130,-55,35,80])
 #ax.coastlines(resolution=&#39;110m&#39;);
ax.add_feature(cfeature.OCEAN.with_scale(&#39;50m&#39;))      # couche ocean
ax.add_feature(cfeature.LAND.with_scale(&#39;50m&#39;))       # couche land
ax.add_feature(cfeature.LAKES.with_scale(&#39;50m&#39;))      # couche lac
   
ax.add_feature(cfeature.BORDERS.with_scale(&#39;50m&#39;))    # couche frontieres
ax.add_feature(cfeature.RIVERS.with_scale(&#39;50m&#39;))     # couche rivières 
coast = cfeature.NaturalEarthFeature(category=&#39;physical&#39;, scale=&#39;10m&#39;,     # ajout de la couche cotière 
                            facecolor=&#39;none&#39;, name=&#39;coastline&#39;)
ax.add_feature(coast, edgecolor=&#39;black&#39;)    
states_provinces = cfeature.NaturalEarthFeature(
            category=&#39;cultural&#39;,
            name=&#39;admin_1_states_provinces_lines&#39;,
            scale=&#39;10m&#39;,
            facecolor=&#39;none&#39;)
    
ax.add_feature(states_provinces, edgecolor=&#39;gray&#39;) 

ax.plot(df[&#39;longitudes&#39;], df[&#39;latitudes&#39;], &#39;ko&#39;, ms=5, transform=ccrs.Geodetic())

for lg, lt, name in zip(df[&#39;longitudes&#39;], df[&#39;latitudes&#39;], df[&#39;Names&#39;]):
    if name in [u&#39;Nazaré&#39;, &#39;Marinha Grande&#39;]:
        ax.text(lg - .05, lt + .05, 
                name, 
                va=&#39;center&#39;, 
                ha=&#39;right&#39;, transform=ccrs.Geodetic(), fontweight=&#39;bold&#39;)
    else:    
        ax.text(lg + .5, lt + .5, 
                name, 
                va=&#39;center&#39;, 
                ha=&#39;left&#39;, transform=ccrs.Geodetic(), fontweight=&#39;bold&#39;)
        
 
mm = ax.pcolormesh(lons,\
                   lats,\
                   clim_81_2010,\
                   vmin=-30,\
                   vmax=15, \
                   transform=ccrs.PlateCarree(),\
                   cmap=colbar )
ax.gridlines()

# Define gridline locations and draw the lines using cartopy&#39;s built-in gridliner:
xticks = np.arange(-150.0,-40.0,20)
yticks =np.arange(10,80,10)

# Standard 6,000 km scale bar.
scale_bar(ax, (0.85, 0.05), 500 ,plot_kwargs = dict(linestyle=&#39;dashed&#39;, color=&#39;black&#39;))

cbar = plt.colorbar(mm, orientation=&#39;horizontal&#39;, shrink=0.5, drawedges=&#39;True&#39;, ticks=np.arange(-30, 15.1, 5),extend=&#39;both&#39;)
cbar.set_label(u&#39;\n Projection = Lambert Conformal Conic \nResolution: 5 Arcs-Minutes (10 km)\nData provided by Natural Resources Canada / Created by Guillaume Dueymes&#39;, size=&#39;medium&#39;) # Affichage de la légende de la barre de couleur
cbar.ax.tick_params(labelsize=17) 
 
plt.xlabel(u&#39;\n\n\nTemperature / Température (°C)&#39;,size=&#39;x-large&#39;)
string_title=u&#39;Climate normals of mean annual temperature (°C)\n reference period 1981-2010\n&#39;
plt.title(string_title, size=&#39;xx-large&#39;)
plt.savefig(&#39;./ANUSPLIN_NLDAS_10km_YEAR_CLIM_1981-2010.png&#39;, bbox_inches=&#39;tight&#39;, pad_inches=0.1)
plt.show() 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./Plot_Climatoloy_Netcdf_10_0.png&#34; alt=&#34;png&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Writing technical content in Academic</title>
      <link>/post/writing-technical-content/</link>
      <pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate>
      <guid>/post/writing-technical-content/</guid>
      <description>&lt;p&gt;Academic is designed to give technical content creators a seamless experience. You can focus on the content and Academic handles the rest.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Highlight your code snippets, take notes on math classes, and draw diagrams from textual representation.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;On this page, you&#39;ll find some examples of the types of technical content that can be rendered with Academic.&lt;/p&gt;

&lt;h2 id=&#34;examples&#34;&gt;Examples&lt;/h2&gt;

&lt;h3 id=&#34;code&#34;&gt;Code&lt;/h3&gt;

&lt;p&gt;Academic supports a Markdown extension for highlighting code syntax. You can enable this feature by toggling the &lt;code&gt;highlight&lt;/code&gt; option in your &lt;code&gt;config/_default/params.toml&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```python
import pandas as pd
data = pd.read_csv(&amp;quot;data.csv&amp;quot;)
data.head()
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;renders as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pandas as pd
data = pd.read_csv(&amp;quot;data.csv&amp;quot;)
data.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;math&#34;&gt;Math&lt;/h3&gt;

&lt;p&gt;Academic supports a Markdown extension for $\LaTeX$ math. You can enable this feature by toggling the &lt;code&gt;math&lt;/code&gt; option in your &lt;code&gt;config/_default/params.toml&lt;/code&gt; file and adding &lt;code&gt;markup: mmark&lt;/code&gt; to your page front matter.&lt;/p&gt;

&lt;p&gt;To render &lt;em&gt;inline&lt;/em&gt; or &lt;em&gt;block&lt;/em&gt; math, wrap your LaTeX math with &lt;code&gt;$$...$$&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Example &lt;strong&gt;math block&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tex&#34;&gt;$$\gamma_{n} = \frac{ 
\left | \left (\mathbf x_{n} - \mathbf x_{n-1} \right )^T 
\left [\nabla F (\mathbf x_{n}) - \nabla F (\mathbf x_{n-1}) \right ] \right |}
{\left \|\nabla F(\mathbf{x}_{n}) - \nabla F(\mathbf{x}_{n-1}) \right \|^2}$$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;renders as&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\gamma_{n} = \frac{ \left | \left (\mathbf x_{n} - \mathbf x_{n-1} \right )^T \left [\nabla F (\mathbf x_{n}) - \nabla F (\mathbf x_{n-1}) \right ] \right |}{\left \|\nabla F(\mathbf{x}_{n}) - \nabla F(\mathbf{x}_{n-1}) \right \|^2}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Example &lt;strong&gt;inline math&lt;/strong&gt; &lt;code&gt;$$\left \|\nabla F(\mathbf{x}_{n}) - \nabla F(\mathbf{x}_{n-1}) \right \|^2$$&lt;/code&gt; renders as &lt;span  class=&#34;math&#34;&gt;\(\left \|\nabla F(\mathbf{x}_{n}) - \nabla F(\mathbf{x}_{n-1}) \right \|^2\)&lt;/span&gt; .&lt;/p&gt;

&lt;p&gt;Example &lt;strong&gt;multi-line math&lt;/strong&gt; using the &lt;code&gt;\\&lt;/code&gt; math linebreak:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tex&#34;&gt;$$f(k;p_0^*) = \begin{cases} p_0^* &amp;amp; \text{if }k=1, \\
1-p_0^* &amp;amp; \text {if }k=0.\end{cases}$$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;renders as&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[f(k;p_0^*) = \begin{cases} p_0^* &amp; \text{if }k=1, \\
1-p_0^* &amp; \text {if }k=0.\end{cases}\]&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;diagrams&#34;&gt;Diagrams&lt;/h3&gt;

&lt;p&gt;Academic supports a Markdown extension for diagrams. You can enable this feature by toggling the &lt;code&gt;diagram&lt;/code&gt; option in your &lt;code&gt;config/_default/params.toml&lt;/code&gt; file or by adding &lt;code&gt;diagram: true&lt;/code&gt; to your page front matter.&lt;/p&gt;

&lt;p&gt;An example &lt;strong&gt;flowchart&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```mermaid
graph TD;
  A--&amp;gt;B;
  A--&amp;gt;C;
  B--&amp;gt;D;
  C--&amp;gt;D;
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;renders as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
  A--&amp;gt;B;
  A--&amp;gt;C;
  B--&amp;gt;D;
  C--&amp;gt;D;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An example &lt;strong&gt;sequence diagram&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```mermaid
sequenceDiagram
  participant Alice
  participant Bob
  Alice-&amp;gt;John: Hello John, how are you?
  loop Healthcheck
      John-&amp;gt;John: Fight against hypochondria
  end
  Note right of John: Rational thoughts &amp;lt;br/&amp;gt;prevail...
  John--&amp;gt;Alice: Great!
  John-&amp;gt;Bob: How about you?
  Bob--&amp;gt;John: Jolly good!
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;renders as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;sequenceDiagram
  participant Alice
  participant Bob
  Alice-&amp;gt;John: Hello John, how are you?
  loop Healthcheck
      John-&amp;gt;John: Fight against hypochondria
  end
  Note right of John: Rational thoughts &amp;lt;br/&amp;gt;prevail...
  John--&amp;gt;Alice: Great!
  John-&amp;gt;Bob: How about you?
  Bob--&amp;gt;John: Jolly good!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An example &lt;strong&gt;Gantt diagram&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```mermaid
gantt
  dateFormat  YYYY-MM-DD
  section Section
  A task           :a1, 2014-01-01, 30d
  Another task     :after a1  , 20d
  section Another
  Task in sec      :2014-01-12  , 12d
  another task      : 24d
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;renders as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;gantt
  dateFormat  YYYY-MM-DD
  section Section
  A task           :a1, 2014-01-01, 30d
  Another task     :after a1  , 20d
  section Another
  Task in sec      :2014-01-12  , 12d
  another task      : 24d
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;todo-lists&#34;&gt;Todo lists&lt;/h3&gt;

&lt;p&gt;You can even write your todo lists in Academic too:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;- [x] Write math example
- [x] Write diagram example
- [ ] Do something else
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;renders as&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;input type=&#34;checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34;&gt; Write math example&lt;/li&gt;
&lt;li&gt;&lt;input type=&#34;checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34;&gt; Write diagram example&lt;/li&gt;
&lt;li&gt;&lt;input type=&#34;checkbox&#34; disabled=&#34;&#34;&gt; Do something else&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;tables&#34;&gt;Tables&lt;/h3&gt;

&lt;p&gt;Represent your data in tables:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;| First Header  | Second Header |
| ------------- | ------------- |
| Content Cell  | Content Cell  |
| Content Cell  | Content Cell  |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;renders as&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;First Header&lt;/th&gt;
&lt;th&gt;Second Header&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Content Cell&lt;/td&gt;
&lt;td&gt;Content Cell&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Content Cell&lt;/td&gt;
&lt;td&gt;Content Cell&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;asides&#34;&gt;Asides&lt;/h3&gt;

&lt;p&gt;Academic supports a Markdown extension for asides, also referred to as &lt;em&gt;notices&lt;/em&gt; or &lt;em&gt;hints&lt;/em&gt;. By prefixing a paragraph with &lt;code&gt;A&amp;gt;&lt;/code&gt;, it will render as an aside. You can enable this feature by adding &lt;code&gt;markup: mmark&lt;/code&gt; to your page front matter, or alternatively using the &lt;a href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/#alerts&#34;&gt;&lt;em&gt;Alert&lt;/em&gt; shortcode&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;A&amp;gt; A Markdown aside is useful for displaying notices, hints, or definitions to your readers.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;renders as&lt;/p&gt;

&lt;aside&gt;
&lt;p&gt;A Markdown aside is useful for displaying notices, hints, or definitions to your readers.&lt;/p&gt;
&lt;/aside&gt;

&lt;h3 id=&#34;did-you-find-this-page-helpful-consider-sharing-it-&#34;&gt;Did you find this page helpful? Consider sharing it 🙌&lt;/h3&gt;
</description>
    </item>
    
  </channel>
</rss>
